Author: Alexander Shalamov <alexander.shalamov@intel.com>

Tizen 2.1 has nss version 3.12, while chromim requires 3.15.
This patch reverts chromium commits that require nss 3.15.

Following patches were reverted:
81eb5cf Merge 209318 "A speculative fix for the TLS 1.2 client authentic..."
a8b3519 Miscellaneous cleanup of TLS 1.2 code.
abf7641 Linux: fix compatibility with nss-3.15 .
ad37797 Fix TLS 1.2 client authentication on Mac OS X.
f11ead2 Support the new TLS 1.2 HMAC-SHA256 cipher suites specified in RFC 5246 and RFC 5289.
321caf0 Support the new supported_signature_algorithms field of the CertificateRequest message in TLS 1.2.
7799de1 Implement TLS 1.2.
1aa3f6b Add support for CNG-based keys on Windows. This permits ECC client certs.
86303ce Fix bugs in the code in ssl3_HandleHandshakeMessage that handles a CertificateStatus message.
f97ed25 Update NSS libSSL to NSS_3_15_BETA2.

diff --git a/src/net/socket/nss_ssl_util.cc b/src/net/socket/nss_ssl_util.cc
index be33ac5..ff5a894 100644
--- a/src/net/socket/nss_ssl_util.cc
+++ b/src/net/socket/nss_ssl_util.cc
@@ -190,8 +190,6 @@ int MapNSSError(PRErrorCode err) {
       return ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY;
     case SEC_ERROR_INVALID_KEY:
     case SSL_ERROR_SIGN_HASHES_FAILURE:
-      LOG(ERROR) << "ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED: NSS error " << err
-                 << ", OS error " << PR_GetOSError();
       return ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
     // A handshake (initial or renegotiation) may fail because some signature
     // (for example, the signature in the ServerKeyExchange message for an
diff --git a/src/net/socket/ssl_client_socket_nss.cc b/src/net/socket/ssl_client_socket_nss.cc
index a7d2ab6..e83be3f 100644
--- a/src/net/socket/ssl_client_socket_nss.cc
+++ b/src/net/socket/ssl_client_socket_nss.cc
@@ -1862,14 +1862,19 @@ int SSLClientSocketNSS::Core::DoHandshake() {
       // TODO(agl): figure out how to plumb an OCSP response into the Mac
       // system library and update IsOCSPStaplingSupported for Mac.
       if (IsOCSPStaplingSupported()) {
-        const SECItemArray* ocsp_responses =
-            SSL_PeerStapledOCSPResponses(nss_fd_);
-        if (ocsp_responses->len) {
+        unsigned int len = 0;
+        SSL_GetStapledOCSPResponse(nss_fd_, NULL, &len);
+        if (len) {
+          const unsigned int orig_len = len;
+          scoped_ptr<uint8[]> ocsp_response(new uint8[orig_len]);
+          SSL_GetStapledOCSPResponse(nss_fd_, ocsp_response.get(), &len);
+          DCHECK_EQ(orig_len, len);
+
   #if defined(OS_WIN)
           if (nss_handshake_state_.server_cert) {
             CRYPT_DATA_BLOB ocsp_response_blob;
-            ocsp_response_blob.cbData = ocsp_responses->items[0].len;
-            ocsp_response_blob.pbData = ocsp_responses->items[0].data;
+            ocsp_response_blob.cbData = len;
+            ocsp_response_blob.pbData = ocsp_response.get();
             BOOL ok = CertSetCertificateContextProperty(
                 nss_handshake_state_.server_cert->os_cert_handle(),
                 CERT_OCSP_RESPONSE_PROP_ID,
@@ -1883,11 +1888,15 @@ int SSLClientSocketNSS::Core::DoHandshake() {
   #elif defined(USE_NSS)
           CacheOCSPResponseFromSideChannelFunction cache_ocsp_response =
               GetCacheOCSPResponseFromSideChannelFunction();
+          SECItem ocsp_response_item;
+          ocsp_response_item.type = siBuffer;
+          ocsp_response_item.data = ocsp_response.get();
+          ocsp_response_item.len = len;
 
           cache_ocsp_response(
               CERT_GetDefaultCertDB(),
               nss_handshake_state_.server_cert_chain[0], PR_Now(),
-              &ocsp_responses->items[0], NULL);
+              &ocsp_response_item, NULL);
   #endif
         }
       }
diff --git a/src/net/ssl/ssl_config_service.cc b/src/net/ssl/ssl_config_service.cc
index 0561e7f..f195887 100644
--- a/src/net/ssl/ssl_config_service.cc
+++ b/src/net/ssl/ssl_config_service.cc
@@ -20,15 +20,13 @@ static uint16 g_default_version_min = SSL_PROTOCOL_VERSION_SSL3;
 
 static uint16 g_default_version_max =
 #if defined(USE_OPENSSL)
-#if defined(SSL_OP_NO_TLSv1_2)
-    SSL_PROTOCOL_VERSION_TLS1_2;
-#elif defined(SSL_OP_NO_TLSv1_1)
+#if defined(SSL_OP_NO_TLSv1_1)
     SSL_PROTOCOL_VERSION_TLS1_1;
 #else
     SSL_PROTOCOL_VERSION_TLS1;
 #endif
 #else
-    SSL_PROTOCOL_VERSION_TLS1_2;
+    SSL_PROTOCOL_VERSION_TLS1_1;
 #endif
 
 SSLConfig::CertAndStatus::CertAndStatus() : cert_status(0) {}
diff --git a/src/net/third_party/nss/README.chromium b/src/net/third_party/nss/README.chromium
index 197c2d6..1827da1 100644
--- a/src/net/third_party/nss/README.chromium
+++ b/src/net/third_party/nss/README.chromium
@@ -1,17 +1,17 @@
 Name: Network Security Services (NSS)
 URL: http://www.mozilla.org/projects/security/pki/nss/
-Version: 3.15 Beta 2
+Version: 3.14
 Security Critical: Yes
 License: MPL 2
 License File: NOT_SHIPPED
 
-This directory includes a copy of NSS's libssl from the hg repo at:
-  https://hg.mozilla.org/projects/nss
+This directory includes a copy of NSS's libssl from the CVS repo at:
+  :pserver:anonymous@cvs-mirror.mozilla.org:/cvsroot
 
 The same module appears in crypto/third_party/nss (and third_party/nss on some
 platforms), so we don't repeat the license file here.
 
-The snapshot was updated to the hg tag: NSS_3_15_BETA2
+The snapshot was updated to the CVS tag: NSS_3_14_RTM
 
 Patches:
 
@@ -33,6 +33,10 @@ Patches:
     patches/peercertchain.patch
     https://bugzilla.mozilla.org/show_bug.cgi?id=731485
 
+  * Add OCSP stapling support
+    patches/ocspstapling.patch
+    https://bugzilla.mozilla.org/show_bug.cgi?id=360420
+
   * Add support for client auth with native crypto APIs on Mac and Windows
     patches/clientauth.patch
     ssl/sslplatf.c
@@ -42,6 +46,9 @@ Patches:
     patches/didhandshakeresume.patch
     https://bugzilla.mozilla.org/show_bug.cgi?id=731798
 
+  * Add a function to restart a handshake after a client certificate request.
+    patches/restartclientauth.patch
+
   * Allow SSL_HandshakeNegotiatedExtension to be called before the handshake
     is finished.
     https://bugzilla.mozilla.org/show_bug.cgi?id=681839
@@ -51,8 +58,10 @@ Patches:
     https://bugzilla.mozilla.org/show_bug.cgi?id=51413
     patches/getrequestedclientcerttypes.patch
 
-  * Add a function to restart a handshake after a client certificate request.
-    patches/restartclientauth.patch
+  * Enable False Start only when the server supports forward secrecy.
+    patches/falsestartnpn.patch
+    https://bugzilla.mozilla.org/show_bug.cgi?id=810582
+    https://bugzilla.mozilla.org/show_bug.cgi?id=810583
 
   * Add support for TLS Channel IDs
     patches/channelid.patch
@@ -61,6 +70,10 @@ Patches:
     patches/tlsunique.patch
     https://bugzilla.mozilla.org/show_bug.cgi?id=563276
 
+  * Don't crash when the SSL keylog file cannot be opened.
+    patches/sslkeylogerror.patch
+    https://bugzilla.mozilla.org/show_bug.cgi?id=810579
+
   * Define the EC_POINT_FORM_UNCOMPRESSED macro. In NSS 3.13.2 the macro
     definition was moved from the internal header ec.h to blapit.h. When
     compiling against older system NSS headers, we need to define the macro.
@@ -70,46 +83,19 @@ Patches:
     This change was made in https://chromiumcodereview.appspot.com/10454066.
     patches/secretexporterlocks.patch
 
-  * Allow the constant-time CBC processing code to be compiled against older
-    NSS that doesn't contain the CBC constant-time changes.
+  * Implement CBC processing in constant-time to address the "Lucky Thirteen"
+    attack.
     patches/cbc.patch
-    https://code.google.com/p/chromium/issues/detail?id=172658#c12
+    https://bugzilla.mozilla.org/show_bug.cgi?id=822365
+
+  * Fix a crash in dtls_FreeHandshakeMessages.
+    patches/dtlsinitclist.patch
+    https://bugzilla.mozilla.org/show_bug.cgi?id=822433 (fixed in NSS 3.14.2)
 
   * Define AES_256_KEY_LENGTH if the system blapit.h header doesn't define it.
     Remove this patch when all system NSS packages are NSS 3.12.10 or later.
     patches/aes256keylength.patch
 
-  * Change ssl3_SuiteBOnly to always return PR_TRUE. The softoken in NSS
-    versions older than 3.15 report an EC key size range of 112 bits to 571
-    bits, even when it is compiled to support only the NIST P-256, P-384, and
-    P-521 curves. Remove this patch when all system NSS softoken packages are
-    NSS 3.15 or later.
-    patches/suitebonly.patch
-
-  * Define the SECItemArray type and declare the SECItemArray handling
-    functions, which were added in NSS 3.15. Remove this patch when all system
-    NSS packages are NSS 3.15 or later.
-    patches/secitemarray.patch
-
-  * Remove unused variables in ssl3_SendCertificateStatus.
-    patches/unusedvariables.patch
-    https://bugzilla.mozilla.org/show_bug.cgi?id=866949
-
-  * Fix bugs in the code in ssl3_HandleHandshakeMessage that handles a
-    CertificateStatus message.
-    patches/handlecertstatus.patch
-    https://bugzilla.mozilla.org/show_bug.cgi?id=867795
-
-  * Implement TLS 1.2.
-    patches/tls12.patch
-    patches/tls12certrequest.patch
-    patches/tls12hmacsha256.patch
-    patches/tls12handshakehashes.patch
-    https://bugzilla.mozilla.org/show_bug.cgi?id=480514
-
-  * Update Chromium-specific code for TLS 1.2.
-    patches/tls12chromium.patch
-
 Apply the patches to NSS by running the patches/applypatches.sh script.  Read
 the comments at the top of patches/applypatches.sh for instructions.
 
diff --git a/src/net/third_party/nss/patches/aes256keylength.patch b/src/net/third_party/nss/patches/aes256keylength.patch
index e77e16e..f978c07 100644
--- a/src/net/third_party/nss/patches/aes256keylength.patch
+++ b/src/net/third_party/nss/patches/aes256keylength.patch
@@ -1,6 +1,10 @@
-diff -pu a/nss/lib/ssl/sslsnce.c b/nss/lib/ssl/sslsnce.c
---- a/nss/lib/ssl/sslsnce.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslsnce.c	2013-04-27 09:41:36.887048239 -0700
+Index: mozilla/security/nss/lib/ssl/sslsnce.c
+===================================================================
+RCS file: /cvsroot/mozilla/security/nss/lib/ssl/sslsnce.c,v
+retrieving revision 1.63
+diff -p -u -r1.63 sslsnce.c
+--- mozilla/security/nss/lib/ssl/sslsnce.c	14 Jun 2012 19:04:59 -0000	1.63
++++ mozilla/security/nss/lib/ssl/sslsnce.c	2 Mar 2013 00:31:22 -0000
 @@ -87,6 +87,11 @@
  #include "nspr.h"
  #include "sslmutex.h"
diff --git a/src/net/third_party/nss/patches/applypatches.sh b/src/net/third_party/nss/patches/applypatches.sh
index e8d9f5f..01340a3 100755
--- a/src/net/third_party/nss/patches/applypatches.sh
+++ b/src/net/third_party/nss/patches/applypatches.sh
@@ -10,50 +10,40 @@
 # chromium source tree.
 patches_dir=/Users/wtc/chrome1/src/net/third_party/nss/patches
 
-patch -p4 < $patches_dir/versionskew.patch
+patch -p5 < $patches_dir/versionskew.patch
 
-patch -p4 < $patches_dir/renegoscsv.patch
+patch -p5 < $patches_dir/renegoscsv.patch
 
-patch -p4 < $patches_dir/cachecerts.patch
+patch -p5 < $patches_dir/cachecerts.patch
 
-patch -p4 < $patches_dir/peercertchain.patch
+patch -p5 < $patches_dir/peercertchain.patch
 
-patch -p4 < $patches_dir/clientauth.patch
+patch -p5 < $patches_dir/ocspstapling.patch
 
-patch -p4 < $patches_dir/didhandshakeresume.patch
+patch -p5 < $patches_dir/clientauth.patch
 
-patch -p4 < $patches_dir/negotiatedextension.patch
+patch -p5 < $patches_dir/didhandshakeresume.patch
 
-patch -p4 < $patches_dir/getrequestedclientcerttypes.patch
+patch -p5 < $patches_dir/negotiatedextension.patch
 
-patch -p4 < $patches_dir/restartclientauth.patch
+patch -p5 < $patches_dir/getrequestedclientcerttypes.patch
 
-patch -p4 < $patches_dir/channelid.patch
+patch -p5 < $patches_dir/restartclientauth.patch
 
-patch -p4 < $patches_dir/tlsunique.patch
+patch -p5 < $patches_dir/falsestartnpn.patch
 
-patch -p4 < $patches_dir/ecpointform.patch
+patch -p5 < $patches_dir/channelid.patch
 
-patch -p4 < $patches_dir/secretexporterlocks.patch
+patch -p5 < $patches_dir/tlsunique.patch
 
-patch -p4 < $patches_dir/cbc.patch
+patch -p5 < $patches_dir/sslkeylogerror.patch
 
-patch -p4 < $patches_dir/aes256keylength.patch
+patch -p5 < $patches_dir/ecpointform.patch
 
-patch -p4 < $patches_dir/suitebonly.patch
+patch -p5 < $patches_dir/secretexporterlocks.patch
 
-patch -p4 < $patches_dir/secitemarray.patch
+patch -p6 < $patches_dir/cbc.patch
 
-patch -p4 < $patches_dir/unusedvariables.patch
+patch -p5 < $patches_dir/dtlsinitclist.patch
 
-patch -p4 < $patches_dir/handlecertstatus.patch
-
-patch -p4 < $patches_dir/tls12.patch
-
-patch -p4 < $patches_dir/tls12chromium.patch
-
-patch -p4 < $patches_dir/tls12certrequest.patch
-
-patch -p4 < $patches_dir/tls12hmacsha256.patch
-
-patch -p4 < $patches_dir/tls12handshakehashes.patch
+patch -p5 < $patches_dir/aes256keylength.patch
diff --git a/src/net/third_party/nss/patches/cachecerts.patch b/src/net/third_party/nss/patches/cachecerts.patch
index f904ae7..8c3e60b 100644
--- a/src/net/third_party/nss/patches/cachecerts.patch
+++ b/src/net/third_party/nss/patches/cachecerts.patch
@@ -1,6 +1,6 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:19:50.358559102 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:19:58.798678612 -0700
+diff -pu -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:19:29.665155332 -0800
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:20:08.835732728 -0800
 @@ -42,6 +42,7 @@
  #endif
  
@@ -9,15 +9,15 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  static PK11SymKey *ssl3_GenerateRSAPMS(sslSocket *ss, ssl3CipherSpec *spec,
                                         PK11SlotInfo * serverKeySlot);
  static SECStatus ssl3_DeriveMasterSecret(sslSocket *ss, PK11SymKey *pms);
-@@ -5697,6 +5698,7 @@ ssl3_HandleServerHello(sslSocket *ss, SS
+@@ -5575,6 +5576,7 @@ ssl3_HandleServerHello(sslSocket *ss, SS
  	/* copy the peer cert from the SID */
  	if (sid->peerCert != NULL) {
  	    ss->sec.peerCert = CERT_DupCertificate(sid->peerCert);
 +	    ssl3_CopyPeerCertsFromSID(ss, sid);
  	}
  
- 	/* NULL value for PMS signifies re-use of the old MS */
-@@ -7048,6 +7050,7 @@ compression_found:
+ 
+@@ -6916,6 +6918,7 @@ compression_found:
  	ss->sec.ci.sid = sid;
  	if (sid->peerCert != NULL) {
  	    ss->sec.peerCert = CERT_DupCertificate(sid->peerCert);
@@ -25,7 +25,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  	}
  
  	/*
-@@ -8501,6 +8504,44 @@ ssl3_CleanupPeerCerts(sslSocket *ss)
+@@ -8323,6 +8326,44 @@ ssl3_CleanupPeerCerts(sslSocket *ss)
      ss->ssl3.peerCertChain = NULL;
  }
  
@@ -68,9 +68,9 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
 +}
 +
  /* Called from ssl3_HandleHandshakeMessage() when it has deciphered a complete
-  * ssl3 CertificateStatus message.
+  * ssl3 Certificate message.
   * Caller must hold Handshake and RecvBuf locks.
-@@ -8780,6 +8821,7 @@ ssl3_AuthCertificate(sslSocket *ss)
+@@ -8510,6 +8551,7 @@ ssl3_HandleCertificate(sslSocket *ss, SS
      }
  
      ss->sec.ci.sid->peerCert = CERT_DupCertificate(ss->sec.peerCert);
@@ -78,10 +78,10 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      if (!ss->sec.isServer) {
          CERTCertificate *cert = ss->sec.peerCert;
-diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-04-27 09:19:58.798678612 -0700
-@@ -570,10 +570,13 @@ typedef enum {	never_cached,
+diff -pu -r a/net/third_party/nss/ssl/sslimpl.h b/net/third_party/nss/ssl/sslimpl.h
+--- a/net/third_party/nss/ssl/sslimpl.h	2012-09-27 18:46:45.000000000 -0700
++++ b/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:20:08.835732728 -0800
+@@ -571,10 +571,13 @@ typedef enum {	never_cached, 
  		invalid_cache		/* no longer in any cache. */
  } Cached;
  
@@ -92,12 +92,12 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  
      CERTCertificate *     peerCert;
 +    CERTCertificate *     peerCertChain[MAX_PEER_CERT_CHAIN_SIZE];
-     SECItemArray          peerCertStatus; /* client only */
      const char *          peerID;     /* client only */
      const char *          urlSvrName; /* client only */
-diff -pu a/nss/lib/ssl/sslnonce.c b/nss/lib/ssl/sslnonce.c
---- a/nss/lib/ssl/sslnonce.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslnonce.c	2013-04-27 09:19:58.798678612 -0700
+     CERTCertificate *     localCert;
+diff -pu -r a/net/third_party/nss/ssl/sslnonce.c b/net/third_party/nss/ssl/sslnonce.c
+--- a/net/third_party/nss/ssl/sslnonce.c	2012-04-25 07:50:12.000000000 -0700
++++ b/net/third_party/nss/ssl/sslnonce.c	2012-11-09 15:20:08.835732728 -0800
 @@ -165,6 +165,7 @@ lock_cache(void)
  static void
  ssl_DestroySID(sslSessionID *sid)
@@ -113,6 +113,6 @@ diff -pu a/nss/lib/ssl/sslnonce.c b/nss/lib/ssl/sslnonce.c
 +    for (i = 0; i < MAX_PEER_CERT_CHAIN_SIZE && sid->peerCertChain[i]; i++) {
 +	CERT_DestroyCertificate(sid->peerCertChain[i]);
 +    }
-     if (sid->peerCertStatus.len) {
-         SECITEM_FreeArray(&sid->peerCertStatus, PR_FALSE);
-         sid->peerCertStatus.items = NULL;
+     if ( sid->localCert ) {
+ 	CERT_DestroyCertificate(sid->localCert);
+     }
diff --git a/src/net/third_party/nss/patches/cbc.patch b/src/net/third_party/nss/patches/cbc.patch
index 3053336..2f18da3 100644
--- a/src/net/third_party/nss/patches/cbc.patch
+++ b/src/net/third_party/nss/patches/cbc.patch
@@ -1,7 +1,16 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:39:58.595657996 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:41:05.836609068 -0700
-@@ -2028,6 +2028,20 @@ ssl3_ComputeRecordMAC(
+diff --git a/mozilla/security/nss/lib/ssl/ssl3con.c b/mozilla/security/nss/lib/ssl/ssl3con.c
+index c3706fe..4b79321 100644
+--- a/mozilla/security/nss/lib/ssl/ssl3con.c
++++ b/mozilla/security/nss/lib/ssl/ssl3con.c
+@@ -1844,7 +1844,6 @@ static const unsigned char mac_pad_2 [60] = {
+ };
+ 
+ /* Called from: ssl3_SendRecord()
+-**		ssl3_HandleRecord()
+ ** Caller must already hold the SpecReadLock. (wish we could assert that!)
+ */
+ static SECStatus
+@@ -2026,6 +2025,136 @@ ssl3_ComputeRecordMAC(
      return rv;
  }
  
@@ -19,63 +28,492 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
 +} CK_NSS_MAC_CONSTANT_TIME_PARAMS;
 +#endif
 +
- /* Called from: ssl3_HandleRecord()
-  * Caller must already hold the SpecReadLock. (wish we could assert that!)
-  *
-@@ -2050,7 +2064,8 @@ ssl3_ComputeRecordMACConstantTime(
- {
-     CK_MECHANISM_TYPE            macType;
-     CK_NSS_MAC_CONSTANT_TIME_PARAMS params;
--    SECItem                      param, inputItem, outputItem;
++/* Called from: ssl3_HandleRecord()
++ * Caller must already hold the SpecReadLock. (wish we could assert that!)
++ *
++ * On entry:
++ *   originalLen >= inputLen >= MAC size
++*/
++static SECStatus
++ssl3_ComputeRecordMACConstantTime(
++    ssl3CipherSpec *   spec,
++    PRBool             useServerMacKey,
++    PRBool             isDTLS,
++    SSL3ContentType    type,
++    SSL3ProtocolVersion version,
++    SSL3SequenceNumber seq_num,
++    const SSL3Opaque * input,
++    int                inputLen,
++    int                originalLen,
++    unsigned char *    outbuf,
++    unsigned int *     outLen)
++{
++    CK_MECHANISM_TYPE            macType;
++    CK_NSS_MAC_CONSTANT_TIME_PARAMS params;
 +    PK11Context *                mac_context;
 +    SECItem                      param;
-     SECStatus                    rv;
-     unsigned char                header[13];
-     PK11SymKey *                 key;
-@@ -2111,34 +2126,27 @@ ssl3_ComputeRecordMACConstantTime(
-     param.len = sizeof(params);
-     param.type = 0;
- 
--    inputItem.data = (unsigned char *) input;
--    inputItem.len = inputLen;
--    inputItem.type = 0;
--
--    outputItem.data = outbuf;
--    outputItem.len = *outLen;
--    outputItem.type = 0;
--
-     key = spec->server.write_mac_key;
-     if (!useServerMacKey) {
- 	key = spec->client.write_mac_key;
-     }
++    SECStatus                    rv;
++    unsigned char                header[13];
++    PK11SymKey *                 key;
++    int                          recordLength;
++
++    PORT_Assert(inputLen >= spec->mac_size);
++    PORT_Assert(originalLen >= inputLen);
++
++    if (spec->bypassCiphers) {
++	/* This function doesn't support PKCS#11 bypass. We fallback on the
++	 * non-constant time version. */
++	goto fallback;
++    }
++
++    if (spec->mac_def->mac == mac_null) {
++	*outLen = 0;
++	return SECSuccess;
++    }
++
++    header[0] = (unsigned char)(seq_num.high >> 24);
++    header[1] = (unsigned char)(seq_num.high >> 16);
++    header[2] = (unsigned char)(seq_num.high >>  8);
++    header[3] = (unsigned char)(seq_num.high >>  0);
++    header[4] = (unsigned char)(seq_num.low  >> 24);
++    header[5] = (unsigned char)(seq_num.low  >> 16);
++    header[6] = (unsigned char)(seq_num.low  >>  8);
++    header[7] = (unsigned char)(seq_num.low  >>  0);
++    header[8] = type;
++
++    macType = CKM_NSS_HMAC_CONSTANT_TIME;
++    recordLength = inputLen - spec->mac_size;
++    if (spec->version <= SSL_LIBRARY_VERSION_3_0) {
++	macType = CKM_NSS_SSL3_MAC_CONSTANT_TIME;
++	header[9] = recordLength >> 8;
++	header[10] = recordLength;
++	params.ulHeaderLen = 11;
++    } else {
++	if (isDTLS) {
++	    SSL3ProtocolVersion dtls_version;
++
++	    dtls_version = dtls_TLSVersionToDTLSVersion(version);
++	    header[9] = dtls_version >> 8;
++	    header[10] = dtls_version;
++	} else {
++	    header[9] = version >> 8;
++	    header[10] = version;
++	}
++	header[11] = recordLength >> 8;
++	header[12] = recordLength;
++	params.ulHeaderLen = 13;
++    }
++
++    params.macAlg = spec->mac_def->mmech;
++    params.ulBodyTotalLen = originalLen;
++    params.pHeader = header;
++
++    param.data = (unsigned char*) &params;
++    param.len = sizeof(params);
++    param.type = 0;
++
++    key = spec->server.write_mac_key;
++    if (!useServerMacKey) {
++	key = spec->client.write_mac_key;
++    }
 +    mac_context = PK11_CreateContextBySymKey(macType, CKA_SIGN, key, &param);
 +    if (mac_context == NULL) {
 +	/* Older versions of NSS may not support constant-time MAC. */
 +	goto fallback;
 +    }
- 
--    rv = PK11_SignWithSymKey(key, macType, &param, &outputItem, &inputItem);
--    if (rv != SECSuccess) {
--	if (PORT_GetError() == SEC_ERROR_INVALID_ALGORITHM) {
--	    goto fallback;
--	}
++
 +    rv  = PK11_DigestBegin(mac_context);
 +    rv |= PK11_DigestOp(mac_context, input, inputLen);
 +    rv |= PK11_DigestFinal(mac_context, outbuf, outLen, spec->mac_size);
 +    PK11_DestroyContext(mac_context, PR_TRUE);
- 
--	*outLen = 0;
++
 +    PORT_Assert(rv != SECSuccess || *outLen == (unsigned)spec->mac_size);
 +
 +    if (rv != SECSuccess) {
- 	rv = SECFailure;
- 	ssl_MapLowLevelError(SSL_ERROR_MAC_COMPUTATION_FAILURE);
--	return rv;
++	rv = SECFailure;
++	ssl_MapLowLevelError(SSL_ERROR_MAC_COMPUTATION_FAILURE);
++    }
++    return rv;
++
++fallback:
++    /* ssl3_ComputeRecordMAC expects the MAC to have been removed from the
++     * length already. */
++    inputLen -= spec->mac_size;
++    return ssl3_ComputeRecordMAC(spec, useServerMacKey, isDTLS, type,
++				 version, seq_num, input, inputLen,
++				 outbuf, outLen);
++}
++
+ static PRBool
+ ssl3_ClientAuthTokenPresent(sslSessionID *sid) {
+     PK11SlotInfo *slot = NULL;
+@@ -9530,6 +9659,177 @@ ssl3_HandleHandshake(sslSocket *ss, sslBuffer *origBuf)
+     return SECSuccess;
+ }
+ 
++/* These macros return the given value with the MSB copied to all the other
++ * bits. They use the fact that arithmetic shift shifts-in the sign bit.
++ * However, this is not ensured by the C standard so you may need to replace
++ * them with something else for odd compilers. */
++#define DUPLICATE_MSB_TO_ALL(x) ( (unsigned)( (int)(x) >> (sizeof(int)*8-1) ) )
++#define DUPLICATE_MSB_TO_ALL_8(x) ((unsigned char)(DUPLICATE_MSB_TO_ALL(x)))
++
++/* SECStatusToMask returns, in constant time, a mask value of all ones if rv ==
++ * SECSuccess.  Otherwise it returns zero. */
++static unsigned SECStatusToMask(SECStatus rv)
++{
++    unsigned int good;
++    /* rv ^ SECSuccess is zero iff rv == SECSuccess. Subtracting one results in
++     * the MSB being set to one iff it was zero before. */
++    good = rv ^ SECSuccess;
++    good--;
++    return DUPLICATE_MSB_TO_ALL(good);
++}
++
++/* ssl_ConstantTimeGE returns 0xff if a>=b and 0x00 otherwise. */
++static unsigned char ssl_ConstantTimeGE(unsigned a, unsigned b)
++{
++    a -= b;
++    return DUPLICATE_MSB_TO_ALL(~a);
++}
++
++/* ssl_ConstantTimeEQ8 returns 0xff if a==b and 0x00 otherwise. */
++static unsigned char ssl_ConstantTimeEQ8(unsigned char a, unsigned char b)
++{
++    unsigned c = a ^ b;
++    c--;
++    return DUPLICATE_MSB_TO_ALL_8(c);
++}
++
++static SECStatus ssl_RemoveSSLv3CBCPadding(sslBuffer *plaintext,
++					   unsigned blockSize,
++					   unsigned macSize) {
++    unsigned int paddingLength, good, t;
++    const unsigned int overhead = 1 /* padding length byte */ + macSize;
++
++    /* These lengths are all public so we can test them in non-constant
++     * time. */
++    if (overhead > plaintext->len) {
++	return SECFailure;
++    }
++
++    paddingLength = plaintext->buf[plaintext->len-1];
++    /* SSLv3 padding bytes are random and cannot be checked. */
++    t = plaintext->len;
++    t -= paddingLength+overhead;
++    /* If len >= padding_length+overhead then the MSB of t is zero. */
++    good = DUPLICATE_MSB_TO_ALL(~t);
++    /* SSLv3 requires that the padding is minimal. */
++    t = blockSize - (paddingLength+1);
++    good &= DUPLICATE_MSB_TO_ALL(~t);
++    plaintext->len -= good & (paddingLength+1);
++    return (good & SECSuccess) | (~good & SECFailure);
++}
++
++
++static SECStatus ssl_RemoveTLSCBCPadding(sslBuffer *plaintext,
++					 unsigned macSize) {
++    unsigned int paddingLength, good, t, toCheck, i;
++    const unsigned int overhead = 1 /* padding length byte */ + macSize;
++
++    /* These lengths are all public so we can test them in non-constant
++     * time. */
++    if (overhead > plaintext->len) {
++	return SECFailure;
++    }
++
++    paddingLength = plaintext->buf[plaintext->len-1];
++    t = plaintext->len;
++    t -= paddingLength+overhead;
++    /* If len >= paddingLength+overhead then the MSB of t is zero. */
++    good = DUPLICATE_MSB_TO_ALL(~t);
++
++    /* The padding consists of a length byte at the end of the record and then
++     * that many bytes of padding, all with the same value as the length byte.
++     * Thus, with the length byte included, there are paddingLength+1 bytes of
++     * padding.
++     *
++     * We can't check just |paddingLength+1| bytes because that leaks
++     * decrypted information. Therefore we always have to check the maximum
++     * amount of padding possible. (Again, the length of the record is
++     * public information so we can use it.) */
++    toCheck = 255; /* maximum amount of padding. */
++    if (toCheck > plaintext->len-1) {
++	toCheck = plaintext->len-1;
++    }
++
++    for (i = 0; i < toCheck; i++) {
++	unsigned int t = paddingLength - i;
++	/* If i <= paddingLength then the MSB of t is zero and mask is
++	 * 0xff.  Otherwise, mask is 0. */
++	unsigned char mask = DUPLICATE_MSB_TO_ALL(~t);
++	unsigned char b = plaintext->buf[plaintext->len-1-i];
++	/* The final |paddingLength+1| bytes should all have the value
++	 * |paddingLength|. Therefore the XOR should be zero. */
++	good &= ~(mask&(paddingLength ^ b));
++    }
++
++    /* If any of the final |paddingLength+1| bytes had the wrong value,
++     * one or more of the lower eight bits of |good| will be cleared. We
++     * AND the bottom 8 bits together and duplicate the result to all the
++     * bits. */
++    good &= good >> 4;
++    good &= good >> 2;
++    good &= good >> 1;
++    good <<= sizeof(good)*8-1;
++    good = DUPLICATE_MSB_TO_ALL(good);
++
++    plaintext->len -= good & (paddingLength+1);
++    return (good & SECSuccess) | (~good & SECFailure);
++}
++
++/* On entry:
++ *   originalLength >= macSize
++ *   macSize <= MAX_MAC_LENGTH
++ *   plaintext->len >= macSize
++ */
++static void ssl_CBCExtractMAC(sslBuffer *plaintext,
++			      unsigned int originalLength,
++			      SSL3Opaque* out,
++			      unsigned int macSize) {
++    unsigned char rotatedMac[MAX_MAC_LENGTH];
++    /* macEnd is the index of |plaintext->buf| just after the end of the MAC. */
++    unsigned macEnd = plaintext->len;
++    unsigned macStart = macEnd - macSize;
++    /* scanStart contains the number of bytes that we can ignore because
++     * the MAC's position can only vary by 255 bytes. */
++    unsigned scanStart = 0;
++    unsigned i, j, divSpoiler;
++    unsigned char rotateOffset;
++
++    if (originalLength > macSize + 255 + 1)
++	scanStart = originalLength - (macSize + 255 + 1);
++
++    /* divSpoiler contains a multiple of macSize that is used to cause the
++     * modulo operation to be constant time. Without this, the time varies
++     * based on the amount of padding when running on Intel chips at least.
++     *
++     * The aim of right-shifting macSize is so that the compiler doesn't
++     * figure out that it can remove divSpoiler as that would require it
++     * to prove that macSize is always even, which I hope is beyond it. */
++    divSpoiler = macSize >> 1;
++    divSpoiler <<= (sizeof(divSpoiler)-1)*8;
++    rotateOffset = (divSpoiler + macStart - scanStart) % macSize;
++
++    memset(rotatedMac, 0, macSize);
++    for (i = scanStart; i < originalLength;) {
++	for (j = 0; j < macSize && i < originalLength; i++, j++) {
++	    unsigned char macStarted = ssl_ConstantTimeGE(i, macStart);
++	    unsigned char macEnded = ssl_ConstantTimeGE(i, macEnd);
++	    unsigned char b = 0;
++	    b = plaintext->buf[i];
++	    rotatedMac[j] |= b & macStarted & ~macEnded;
++	}
++    }
++
++    /* Now rotate the MAC. If we knew that the MAC fit into a CPU cache line we
++     * could line-align |rotatedMac| and rotate in place. */
++    memset(out, 0, macSize);
++    for (i = 0; i < macSize; i++) {
++	unsigned char offset = (divSpoiler + macSize - rotateOffset + i) % macSize;
++	for (j = 0; j < macSize; j++) {
++	    out[j] |= rotatedMac[i] & ssl_ConstantTimeEQ8(j, offset);
++	}
++    }
++}
++
+ /* if cText is non-null, then decipher, check MAC, and decompress the
+  * SSL record from cText->buf (typically gs->inbuf)
+  * into databuf (typically gs->buf), and any previous contents of databuf
+@@ -9559,15 +9859,18 @@ ssl3_HandleRecord(sslSocket *ss, SSL3Ciphertext *cText, sslBuffer *databuf)
+     ssl3CipherSpec *     crSpec;
+     SECStatus            rv;
+     unsigned int         hashBytes = MAX_MAC_LENGTH + 1;
+-    unsigned int         padding_length;
+     PRBool               isTLS;
+-    PRBool               padIsBad = PR_FALSE;
+     SSL3ContentType      rType;
+     SSL3Opaque           hash[MAX_MAC_LENGTH];
++    SSL3Opaque           givenHashBuf[MAX_MAC_LENGTH];
++    SSL3Opaque          *givenHash;
+     sslBuffer           *plaintext;
+     sslBuffer            temp_buf;
+     PRUint64             dtls_seq_num;
+     unsigned int         ivLen = 0;
++    unsigned int         originalLen = 0;
++    unsigned int         good;
++    unsigned int         minLength;
+ 
+     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
+ 
+@@ -9635,6 +9938,30 @@ ssl3_HandleRecord(sslSocket *ss, SSL3Ciphertext *cText, sslBuffer *databuf)
+ 	}
      }
--
--    PORT_Assert(outputItem.len == (unsigned)spec->mac_size);
--    *outLen = outputItem.len;
--
-     return rv;
  
- fallback:
++    good = (unsigned)-1;
++    minLength = crSpec->mac_size;
++    if (cipher_def->type == type_block) {
++	/* CBC records have a padding length byte at the end. */
++	minLength++;
++	if (crSpec->version >= SSL_LIBRARY_VERSION_TLS_1_1) {
++	    /* With >= TLS 1.1, CBC records have an explicit IV. */
++	    minLength += cipher_def->iv_size;
++	}
++    }
++
++    /* We can perform this test in variable time because the record's total
++     * length and the ciphersuite are both public knowledge. */
++    if (cText->buf->len < minLength) {
++	SSL_DBG(("%d: SSL3[%d]: HandleRecord, record too small.",
++		 SSL_GETPID(), ss->fd));
++	/* must not hold spec lock when calling SSL3_SendAlert. */
++	ssl_ReleaseSpecReadLock(ss);
++	SSL3_SendAlert(ss, alert_fatal, bad_record_mac);
++	/* always log mac error, in case attacker can read server logs. */
++	PORT_SetError(SSL_ERROR_BAD_MAC_READ);
++	return SECFailure;
++    }
++
+     if (cipher_def->type == type_block &&
+ 	crSpec->version >= SSL_LIBRARY_VERSION_TLS_1_1) {
+ 	/* Consume the per-record explicit IV. RFC 4346 Section 6.2.3.2 states
+@@ -9652,16 +9979,6 @@ ssl3_HandleRecord(sslSocket *ss, SSL3Ciphertext *cText, sslBuffer *databuf)
+ 	    PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
+ 	    return SECFailure;
+ 	}
+-	if (ivLen > cText->buf->len) {
+-	    SSL_DBG(("%d: SSL3[%d]: HandleRecord, IV length check failed",
+-		     SSL_GETPID(), ss->fd));
+-	    /* must not hold spec lock when calling SSL3_SendAlert. */
+-	    ssl_ReleaseSpecReadLock(ss);
+-	    SSL3_SendAlert(ss, alert_fatal, bad_record_mac);
+-	    /* always log mac error, in case attacker can read server logs. */
+-	    PORT_SetError(SSL_ERROR_BAD_MAC_READ);
+-	    return SECFailure;
+-	}
+ 
+ 	PRINT_BUF(80, (ss, "IV (ciphertext):", cText->buf->buf, ivLen));
+ 
+@@ -9672,12 +9989,7 @@ ssl3_HandleRecord(sslSocket *ss, SSL3Ciphertext *cText, sslBuffer *databuf)
+ 	rv = crSpec->decode(crSpec->decodeContext, iv, &decoded,
+ 			    sizeof(iv), cText->buf->buf, ivLen);
+ 
+-	if (rv != SECSuccess) {
+-	    /* All decryption failures must be treated like a bad record
+-	     * MAC; see RFC 5246 (TLS 1.2). 
+-	     */
+-	    padIsBad = PR_TRUE;
+-	}
++	good &= SECStatusToMask(rv);
+     }
+ 
+     /* If we will be decompressing the buffer we need to decrypt somewhere
+@@ -9719,54 +10031,70 @@ ssl3_HandleRecord(sslSocket *ss, SSL3Ciphertext *cText, sslBuffer *databuf)
+     rv = crSpec->decode(
+ 	crSpec->decodeContext, plaintext->buf, (int *)&plaintext->len,
+ 	plaintext->space, cText->buf->buf + ivLen, cText->buf->len - ivLen);
++    good &= SECStatusToMask(rv);
+ 
+     PRINT_BUF(80, (ss, "cleartext:", plaintext->buf, plaintext->len));
+-    if (rv != SECSuccess) {
+-        /* All decryption failures must be treated like a bad record
+-         * MAC; see RFC 5246 (TLS 1.2). 
+-         */
+-        padIsBad = PR_TRUE;
+-    }
++
++    originalLen = plaintext->len;
+ 
+     /* If it's a block cipher, check and strip the padding. */
+-    if (cipher_def->type == type_block && !padIsBad) {
+-        PRUint8 * pPaddingLen = plaintext->buf + plaintext->len - 1;
+-	padding_length = *pPaddingLen;
+-	/* TLS permits padding to exceed the block size, up to 255 bytes. */
+-	if (padding_length + 1 + crSpec->mac_size > plaintext->len)
+-	    padIsBad = PR_TRUE;
+-	else {
+-            plaintext->len -= padding_length + 1;
+-            /* In TLS all padding bytes must be equal to the padding length. */
+-            if (isTLS) {
+-                PRUint8 *p;
+-                for (p = pPaddingLen - padding_length; p < pPaddingLen; ++p) {
+-                    padIsBad |= *p ^ padding_length;
+-                }
+-            }
+-        }
+-    }
++    if (cipher_def->type == type_block) {
++	const unsigned int blockSize = cipher_def->iv_size;
++	const unsigned int macSize = crSpec->mac_size;
+ 
+-    /* Remove the MAC. */
+-    if (plaintext->len >= crSpec->mac_size)
+-	plaintext->len -= crSpec->mac_size;
+-    else
+-    	padIsBad = PR_TRUE;	/* really macIsBad */
++	if (crSpec->version <= SSL_LIBRARY_VERSION_3_0) {
++	    good &= SECStatusToMask(ssl_RemoveSSLv3CBCPadding(
++			plaintext, blockSize, macSize));
++	} else {
++	    good &= SECStatusToMask(ssl_RemoveTLSCBCPadding(
++			plaintext, macSize));
++	}
++    }
+ 
+     /* compute the MAC */
+     rType = cText->type;
+-    rv = ssl3_ComputeRecordMAC( crSpec, (PRBool)(!ss->sec.isServer),
+-        IS_DTLS(ss), rType, cText->version,
+-        IS_DTLS(ss) ? cText->seq_num : crSpec->read_seq_num,
+-	plaintext->buf, plaintext->len, hash, &hashBytes);
+-    if (rv != SECSuccess) {
+-        padIsBad = PR_TRUE;     /* really macIsBad */
++    if (cipher_def->type == type_block) {
++	rv = ssl3_ComputeRecordMACConstantTime(
++	    crSpec, (PRBool)(!ss->sec.isServer),
++	    IS_DTLS(ss), rType, cText->version,
++	    IS_DTLS(ss) ? cText->seq_num : crSpec->read_seq_num,
++	    plaintext->buf, plaintext->len, originalLen,
++	    hash, &hashBytes);
++
++	ssl_CBCExtractMAC(plaintext, originalLen, givenHashBuf,
++			  crSpec->mac_size);
++	givenHash = givenHashBuf;
++
++	/* plaintext->len will always have enough space to remove the MAC
++	 * because in ssl_Remove{SSLv3|TLS}CBCPadding we only adjust
++	 * plaintext->len if the result has enough space for the MAC and we
++	 * tested the unadjusted size against minLength, above. */
++	plaintext->len -= crSpec->mac_size;
++    } else {
++	/* This is safe because we checked the minLength above. */
++	plaintext->len -= crSpec->mac_size;
++
++	rv = ssl3_ComputeRecordMAC(
++	    crSpec, (PRBool)(!ss->sec.isServer),
++	    IS_DTLS(ss), rType, cText->version,
++	    IS_DTLS(ss) ? cText->seq_num : crSpec->read_seq_num,
++	    plaintext->buf, plaintext->len,
++	    hash, &hashBytes);
++
++	/* We can read the MAC directly from the record because its location is
++	 * public when a stream cipher is used. */
++	givenHash = plaintext->buf + plaintext->len;
++    }
++
++    good &= SECStatusToMask(rv);
++
++    if (hashBytes != (unsigned)crSpec->mac_size ||
++	NSS_SecureMemcmp(givenHash, hash, crSpec->mac_size) != 0) {
++	/* We're allowed to leak whether or not the MAC check was correct */
++	good = 0;
+     }
+ 
+-    /* Check the MAC */
+-    if (hashBytes != (unsigned)crSpec->mac_size || padIsBad || 
+-	NSS_SecureMemcmp(plaintext->buf + plaintext->len, hash,
+-	                 crSpec->mac_size) != 0) {
++    if (good == 0) {
+ 	/* must not hold spec lock when calling SSL3_SendAlert. */
+ 	ssl_ReleaseSpecReadLock(ss);
+ 
diff --git a/src/net/third_party/nss/patches/channelid.patch b/src/net/third_party/nss/patches/channelid.patch
index a8418a5..ea7fd29 100644
--- a/src/net/third_party/nss/patches/channelid.patch
+++ b/src/net/third_party/nss/patches/channelid.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:23:52.361985404 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:24:01.302111964 -0700
-@@ -54,6 +54,7 @@ static SECStatus ssl3_SendCertificateSta
+diff -pu -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:57:12.838336618 -0800
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 16:11:46.721027895 -0800
+@@ -53,6 +53,7 @@ static SECStatus ssl3_SendCertificate(  
  static SECStatus ssl3_SendEmptyCertificate(  sslSocket *ss);
  static SECStatus ssl3_SendCertificateRequest(sslSocket *ss);
  static SECStatus ssl3_SendNextProto(         sslSocket *ss);
@@ -9,7 +9,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  static SECStatus ssl3_SendFinished(          sslSocket *ss, PRInt32 flags);
  static SECStatus ssl3_SendServerHello(       sslSocket *ss);
  static SECStatus ssl3_SendServerHelloDone(   sslSocket *ss);
-@@ -5454,6 +5455,15 @@ ssl3_HandleServerHello(sslSocket *ss, SS
+@@ -5330,6 +5331,15 @@ ssl3_HandleServerHello(sslSocket *ss, SS
      }
  #endif  /* NSS_PLATFORM_CLIENT_AUTH */
  
@@ -25,7 +25,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      temp = ssl3_ConsumeHandshakeNumber(ss, 2, &b, &length);
      if (temp < 0) {
      	goto loser; 	/* alert has been sent */
-@@ -5726,7 +5736,7 @@ ssl3_HandleServerHello(sslSocket *ss, SS
+@@ -5603,7 +5613,7 @@ ssl3_HandleServerHello(sslSocket *ss, SS
  	if (rv != SECSuccess) {
  	    goto alert_loser;	/* err code was set */
  	}
@@ -34,7 +34,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      } while (0);
  
      if (sid_match)
-@@ -5752,6 +5762,27 @@ ssl3_HandleServerHello(sslSocket *ss, SS
+@@ -5629,6 +5639,27 @@ ssl3_HandleServerHello(sslSocket *ss, SS
  
      ss->ssl3.hs.isResuming = PR_FALSE;
      ss->ssl3.hs.ws         = wait_server_cert;
@@ -62,7 +62,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      return SECSuccess;
  
  alert_loser:
-@@ -6506,6 +6537,10 @@ ssl3_SendClientSecondRound(sslSocket *ss
+@@ -6385,6 +6416,10 @@ ssl3_SendClientSecondRound(sslSocket *ss
  	    goto loser;	/* err code was set. */
  	}
      }
@@ -73,7 +73,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      rv = ssl3_SendFinished(ss, 0);
      if (rv != SECSuccess) {
-@@ -9286,6 +9321,164 @@ ssl3_RecordKeyLog(sslSocket *ss)
+@@ -9102,6 +9137,164 @@ ssl3_RecordKeyLog(sslSocket *ss)
      return;
  }
  
@@ -238,7 +238,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  /* called from ssl3_HandleServerHelloDone
   *             ssl3_HandleClientHello
   *             ssl3_HandleFinished
-@@ -9539,11 +9732,16 @@ ssl3_HandleFinished(sslSocket *ss, SSL3O
+@@ -9355,11 +9548,16 @@ ssl3_HandleFinished(sslSocket *ss, SSL3O
  	    flags = ssl_SEND_FLAG_FORCE_INTO_BUFFER;
  	}
  
@@ -259,7 +259,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  	}
  
  	if (IS_DTLS(ss)) {
-@@ -10985,6 +11183,11 @@ ssl3_DestroySSL3Info(sslSocket *ss)
+@@ -10623,6 +10821,11 @@ ssl3_DestroySSL3Info(sslSocket *ss)
  	ssl_FreePlatformKey(ss->ssl3.platformClientKey);
  #endif /* NSS_PLATFORM_CLIENT_AUTH */
  
@@ -271,9 +271,9 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      if (ss->ssl3.peerCertArena != NULL)
  	ssl3_CleanupPeerCerts(ss);
  
-diff -pu a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
---- a/nss/lib/ssl/ssl3ext.c	2013-04-27 09:21:28.339946428 -0700
-+++ b/nss/lib/ssl/ssl3ext.c	2013-04-27 09:36:58.433109462 -0700
+diff -pu -r a/net/third_party/nss/ssl/ssl3ext.c b/net/third_party/nss/ssl/ssl3ext.c
+--- a/net/third_party/nss/ssl/ssl3ext.c	2012-11-09 15:57:12.838336618 -0800
++++ b/net/third_party/nss/ssl/ssl3ext.c	2012-11-09 16:04:14.414475097 -0800
 @@ -61,6 +61,10 @@ static PRInt32 ssl3_SendUseSRTPXtn(sslSo
      PRUint32 maxBytes);
  static SECStatus ssl3_HandleUseSRTPXtn(sslSocket * ss, PRUint16 ex_type,
@@ -282,10 +282,10 @@ diff -pu a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
 +    PRUint16 ex_type, SECItem *data);
 +static PRInt32 ssl3_ClientSendChannelIDXtn(sslSocket *ss, PRBool append,
 +    PRUint32 maxBytes);
- static SECStatus ssl3_ServerSendStatusRequestXtn(sslSocket * ss,
-     PRBool      append, PRUint32    maxBytes);
- static SECStatus ssl3_ServerHandleStatusRequestXtn(sslSocket *ss,
-@@ -244,6 +248,7 @@ static const ssl3HelloExtensionHandler s
+ 
+ /*
+  * Write bytes.  Using this function means the SECItem structure
+@@ -234,6 +238,7 @@ static const ssl3HelloExtensionHandler s
      { ssl_renegotiation_info_xtn, &ssl3_HandleRenegotiationInfoXtn },
      { ssl_next_proto_nego_xtn,    &ssl3_ClientHandleNextProtoNegoXtn },
      { ssl_use_srtp_xtn,           &ssl3_HandleUseSRTPXtn },
@@ -293,7 +293,7 @@ diff -pu a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
      { ssl_cert_status_xtn,        &ssl3_ClientHandleStatusRequestXtn },
      { -1, NULL }
  };
-@@ -270,6 +275,7 @@ ssl3HelloExtensionSender clientHelloSend
+@@ -260,6 +265,7 @@ ssl3HelloExtensionSender clientHelloSend
      { ssl_session_ticket_xtn,     &ssl3_SendSessionTicketXtn },
      { ssl_next_proto_nego_xtn,    &ssl3_ClientSendNextProtoNegoXtn },
      { ssl_use_srtp_xtn,           &ssl3_SendUseSRTPXtn },
@@ -301,15 +301,10 @@ diff -pu a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
      { ssl_cert_status_xtn,        &ssl3_ClientSendStatusRequestXtn }
      /* any extra entries will appear as { 0, NULL }    */
  };
-@@ -655,6 +661,52 @@ ssl3_ClientSendNextProtoNegoXtn(sslSocke
-     }
+@@ -650,6 +656,52 @@ loser:
+     return -1;
+ }
  
-     return extension_length;
-+
-+loser:
-+    return -1;
-+}
-+
 +static SECStatus
 +ssl3_ClientHandleChannelIDXtn(sslSocket *ss, PRUint16 ex_type,
 +			     SECItem *data)
@@ -351,26 +346,31 @@ diff -pu a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
 +    }
 +
 +    return extension_length;
- 
- loser:
-     return -1;
-diff -pu a/nss/lib/ssl/ssl3prot.h b/nss/lib/ssl/ssl3prot.h
---- a/nss/lib/ssl/ssl3prot.h	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/ssl3prot.h	2013-04-27 09:24:01.302111964 -0700
++
++loser:
++    return -1;
++}
++
+ SECStatus
+ ssl3_ClientHandleStatusRequestXtn(sslSocket *ss, PRUint16 ex_type,
+ 				  SECItem *data)
+diff -pu -r a/net/third_party/nss/ssl/ssl3prot.h b/net/third_party/nss/ssl/ssl3prot.h
+--- a/net/third_party/nss/ssl/ssl3prot.h	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/ssl3prot.h	2012-11-09 15:58:06.979126989 -0800
 @@ -130,7 +130,8 @@ typedef enum {
      client_key_exchange	= 16, 
      finished		= 20,
-     certificate_status  = 22,
+     certificate_status	= 22,
 -    next_proto		= 67
 +    next_proto		= 67,
 +    encrypted_extensions= 203
  } SSL3HandshakeType;
  
  typedef struct {
-diff -pu a/nss/lib/ssl/sslauth.c b/nss/lib/ssl/sslauth.c
---- a/nss/lib/ssl/sslauth.c	2013-04-27 09:21:28.339946428 -0700
-+++ b/nss/lib/ssl/sslauth.c	2013-04-27 09:24:01.302111964 -0700
-@@ -220,6 +220,24 @@ SSL_GetClientAuthDataHook(PRFileDesc *s,
+diff -pu -r a/net/third_party/nss/ssl/sslauth.c b/net/third_party/nss/ssl/sslauth.c
+--- a/net/third_party/nss/ssl/sslauth.c	2012-11-09 15:39:36.892892416 -0800
++++ b/net/third_party/nss/ssl/sslauth.c	2012-11-09 15:58:06.979126989 -0800
+@@ -219,6 +219,24 @@ SSL_GetClientAuthDataHook(PRFileDesc *s,
      return SECSuccess;
  }
  
@@ -395,9 +395,9 @@ diff -pu a/nss/lib/ssl/sslauth.c b/nss/lib/ssl/sslauth.c
  #ifdef NSS_PLATFORM_CLIENT_AUTH
  /* NEED LOCKS IN HERE.  */
  SECStatus 
-diff -pu a/nss/lib/ssl/sslerr.h b/nss/lib/ssl/sslerr.h
---- a/nss/lib/ssl/sslerr.h	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslerr.h	2013-04-27 09:24:01.302111964 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslerr.h b/net/third_party/nss/ssl/sslerr.h
+--- a/net/third_party/nss/ssl/sslerr.h	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/sslerr.h	2012-11-09 16:00:57.921621448 -0800
 @@ -190,6 +190,10 @@ SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_VERS
  
  SSL_ERROR_RX_UNEXPECTED_CERT_STATUS     = (SSL_ERROR_BASE + 125),
@@ -409,9 +409,9 @@ diff -pu a/nss/lib/ssl/sslerr.h b/nss/lib/ssl/sslerr.h
  SSL_ERROR_END_OF_LIST	/* let the c compiler determine the value of this. */
  } SSLErrorCodes;
  #endif /* NO_SECURITY_ERROR_ENUM */
-diff -pu a/nss/lib/ssl/SSLerrs.h b/nss/lib/ssl/SSLerrs.h
---- a/nss/lib/ssl/SSLerrs.h	2013-04-27 09:16:26.795676403 -0700
-+++ b/nss/lib/ssl/SSLerrs.h	2013-04-27 09:24:01.302111964 -0700
+diff -pu -r a/net/third_party/nss/ssl/SSLerrs.h b/net/third_party/nss/ssl/SSLerrs.h
+--- a/net/third_party/nss/ssl/SSLerrs.h	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/SSLerrs.h	2012-11-09 16:00:11.540944794 -0800
 @@ -403,3 +403,12 @@ ER3(SSL_ERROR_FEATURE_NOT_SUPPORTED_FOR_
  
  ER3(SSL_ERROR_RX_UNEXPECTED_CERT_STATUS,       (SSL_ERROR_BASE + 125),
@@ -425,10 +425,10 @@ diff -pu a/nss/lib/ssl/SSLerrs.h b/nss/lib/ssl/SSLerrs.h
 +
 +ER3(SSL_ERROR_GET_CHANNEL_ID_FAILED, (SSL_ERROR_BASE + 128),
 +"The application could not get a TLS Channel ID.")
-diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:23:52.361985404 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:24:01.302111964 -0700
-@@ -960,6 +960,34 @@ SSL_IMPORT SECStatus SSL_HandshakeNegoti
+diff -pu -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-11-09 15:53:13.884846338 -0800
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 15:58:06.969126842 -0800
+@@ -935,6 +935,34 @@ SSL_IMPORT SECStatus SSL_HandshakeNegoti
  SSL_IMPORT SECStatus SSL_HandshakeResumedSession(PRFileDesc *fd,
                                                   PRBool *last_handshake_resumed);
  
@@ -463,10 +463,10 @@ diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
  /*
  ** How long should we wait before retransmitting the next flight of
  ** the DTLS handshake? Returns SECFailure if not DTLS or not in a
-diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-04-27 09:23:52.361985404 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-04-27 09:24:01.302111964 -0700
-@@ -887,6 +887,9 @@ struct ssl3StateStr {
+diff -pu -r a/net/third_party/nss/ssl/sslimpl.h b/net/third_party/nss/ssl/sslimpl.h
+--- a/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:53:13.884846338 -0800
++++ b/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:58:06.979126989 -0800
+@@ -894,6 +894,9 @@ struct ssl3StateStr {
      CERTCertificateList *clientCertChain;    /* used by client */
      PRBool               sendEmptyCert;      /* used by client */
  
@@ -476,7 +476,7 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
      int                  policy;
  			/* This says what cipher suites we can do, and should 
  			 * be either SSL_ALLOWED or SSL_RESTRICTED 
-@@ -1158,6 +1161,8 @@ const unsigned char *  preferredCipher;
+@@ -1165,6 +1168,8 @@ const unsigned char *  preferredCipher;
      void                     *pkcs11PinArg;
      SSLNextProtoCallback      nextProtoCallback;
      void                     *nextProtoArg;
@@ -485,7 +485,7 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  
      PRIntervalTime            rTimeout; /* timeout for NSPR I/O */
      PRIntervalTime            wTimeout; /* timeout for NSPR I/O */
-@@ -1489,6 +1494,11 @@ extern SECStatus ssl3_RestartHandshakeAf
+@@ -1495,6 +1500,11 @@ extern SECStatus ssl3_RestartHandshakeAf
  					     SECKEYPrivateKey *   key,
  					     CERTCertificateList *certChain);
  
@@ -497,9 +497,9 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  extern SECStatus ssl3_AuthCertificateComplete(sslSocket *ss, PRErrorCode error);
  
  /*
-diff -pu a/nss/lib/ssl/sslsecur.c b/nss/lib/ssl/sslsecur.c
---- a/nss/lib/ssl/sslsecur.c	2013-04-27 09:23:52.371985544 -0700
-+++ b/nss/lib/ssl/sslsecur.c	2013-04-27 09:24:01.302111964 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslsecur.c b/net/third_party/nss/ssl/sslsecur.c
+--- a/net/third_party/nss/ssl/sslsecur.c	2012-11-09 15:53:13.884846338 -0800
++++ b/net/third_party/nss/ssl/sslsecur.c	2012-11-09 15:58:06.979126989 -0800
 @@ -1503,6 +1503,42 @@ SSL_RestartHandshakeAfterCertReq(PRFileD
      return ret;
  }
@@ -543,10 +543,10 @@ diff -pu a/nss/lib/ssl/sslsecur.c b/nss/lib/ssl/sslsecur.c
  /* DO NOT USE. This function was exported in ssl.def with the wrong signature;
   * this implementation exists to maintain link-time compatibility.
   */
-diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
---- a/nss/lib/ssl/sslsock.c	2013-04-27 09:23:12.121415729 -0700
-+++ b/nss/lib/ssl/sslsock.c	2013-04-27 09:24:01.312112105 -0700
-@@ -348,6 +348,8 @@ ssl_DupSocket(sslSocket *os)
+diff -pu -r a/net/third_party/nss/ssl/sslsock.c b/net/third_party/nss/ssl/sslsock.c
+--- a/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:48:41.260860199 -0800
++++ b/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:58:06.979126989 -0800
+@@ -346,6 +346,8 @@ ssl_DupSocket(sslSocket *os)
  	    ss->handshakeCallback     = os->handshakeCallback;
  	    ss->handshakeCallbackData = os->handshakeCallbackData;
  	    ss->pkcs11PinArg          = os->pkcs11PinArg;
@@ -555,7 +555,7 @@ diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
      
  	    /* Create security data */
  	    rv = ssl_CopySecurityInfo(ss, os);
-@@ -1749,6 +1751,10 @@ SSL_ReconfigFD(PRFileDesc *model, PRFile
+@@ -1736,6 +1738,10 @@ SSL_ReconfigFD(PRFileDesc *model, PRFile
          ss->handshakeCallbackData = sm->handshakeCallbackData;
      if (sm->pkcs11PinArg)
          ss->pkcs11PinArg          = sm->pkcs11PinArg;
@@ -566,18 +566,18 @@ diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
      return fd;
  loser:
      return NULL;
-@@ -3024,6 +3030,8 @@ ssl_NewSocket(PRBool makeLocks, SSLProto
+@@ -2988,6 +2994,8 @@ ssl_NewSocket(PRBool makeLocks, SSLProto
+ 	ss->handleBadCert      = NULL;
  	ss->badCertArg         = NULL;
  	ss->pkcs11PinArg       = NULL;
- 	ss->ephemeralECDHKeyPair = NULL;
 +	ss->getChannelID       = NULL;
 +	ss->getChannelIDArg    = NULL;
  
  	ssl_ChooseOps(ss);
  	ssl2_InitSocketPolicy(ss);
-diff -pu a/nss/lib/ssl/sslt.h b/nss/lib/ssl/sslt.h
---- a/nss/lib/ssl/sslt.h	2013-04-27 09:17:17.226390616 -0700
-+++ b/nss/lib/ssl/sslt.h	2013-04-27 09:24:01.312112105 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslt.h b/net/third_party/nss/ssl/sslt.h
+--- a/net/third_party/nss/ssl/sslt.h	2012-11-09 15:34:12.268133912 -0800
++++ b/net/third_party/nss/ssl/sslt.h	2012-11-09 15:58:55.569836197 -0800
 @@ -183,9 +183,10 @@ typedef enum {
      ssl_use_srtp_xtn                 = 14,
      ssl_session_ticket_xtn           = 35,
diff --git a/src/net/third_party/nss/patches/clientauth.patch b/src/net/third_party/nss/patches/clientauth.patch
index 4833c75..33335f6 100644
--- a/src/net/third_party/nss/patches/clientauth.patch
+++ b/src/net/third_party/nss/patches/clientauth.patch
@@ -1,7 +1,7 @@
-diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:20:13.658889025 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:20:50.169405985 -0700
-@@ -2155,6 +2155,9 @@ ssl3_ClientAuthTokenPresent(sslSessionID
+diff -puN -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:35:08.488958561 -0800
+@@ -2033,6 +2033,9 @@ ssl3_ClientAuthTokenPresent(sslSessionID
      PRBool isPresent = PR_TRUE;
  
      /* we only care if we are doing client auth */
@@ -11,7 +11,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      if (!sid || !sid->u.ssl3.clAuthValid) {
  	return PR_TRUE;
      }
-@@ -5348,24 +5351,35 @@ ssl3_SendCertificateVerify(sslSocket *ss
+@@ -5226,24 +5229,33 @@ ssl3_SendCertificateVerify(sslSocket *ss
      }
  
      isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
@@ -21,10 +21,8 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
 -	sslSessionID * sid   = ss->sec.ci.sid;
 +    if (ss->ssl3.platformClientKey) {
 +#ifdef NSS_PLATFORM_CLIENT_AUTH
-+	rv = ssl3_PlatformSignHashes(
-+	    &hashes, ss->ssl3.platformClientKey, &buf, isTLS,
-+	    CERT_GetCertKeyType(
-+		&ss->ssl3.clientCertificate->subjectPublicKeyInfo));
++	rv = ssl3_PlatformSignHashes(&hashes, ss->ssl3.platformClientKey,
++				     &buf, isTLS);
 +	ssl_FreePlatformKey(ss->ssl3.platformClientKey);
 +	ss->ssl3.platformClientKey = (PlatformKey)NULL;
 +#endif /* NSS_PLATFORM_CLIENT_AUTH */
@@ -63,7 +61,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      if (rv != SECSuccess) {
  	goto done;	/* err code was set by ssl3_SignHashes */
      }
-@@ -5433,6 +5447,12 @@ ssl3_HandleServerHello(sslSocket *ss, SS
+@@ -5311,6 +5323,12 @@ ssl3_HandleServerHello(sslSocket *ss, SS
         SECKEY_DestroyPrivateKey(ss->ssl3.clientPrivateKey);
         ss->ssl3.clientPrivateKey = NULL;
      }
@@ -76,7 +74,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      temp = ssl3_ConsumeHandshakeNumber(ss, 2, &b, &length);
      if (temp < 0) {
-@@ -6022,6 +6042,10 @@ ssl3_HandleCertificateRequest(sslSocket
+@@ -5901,6 +5919,10 @@ ssl3_HandleCertificateRequest(sslSocket 
      SSL3AlertDescription desc        = illegal_parameter;
      SECItem              cert_types  = {siBuffer, NULL, 0};
      CERTDistNames        ca_list;
@@ -87,7 +85,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      SSL_TRC(3, ("%d: SSL3[%d]: handle certificate_request handshake",
  		SSL_GETPID(), ss->fd));
-@@ -6038,6 +6062,7 @@ ssl3_HandleCertificateRequest(sslSocket
+@@ -5917,6 +5939,7 @@ ssl3_HandleCertificateRequest(sslSocket 
      PORT_Assert(ss->ssl3.clientCertChain == NULL);
      PORT_Assert(ss->ssl3.clientCertificate == NULL);
      PORT_Assert(ss->ssl3.clientPrivateKey == NULL);
@@ -95,7 +93,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
      rv = ssl3_ConsumeHandshakeVariable(ss, &cert_types, 1, &b, &length);
-@@ -6104,6 +6129,18 @@ ssl3_HandleCertificateRequest(sslSocket
+@@ -5983,6 +6006,18 @@ ssl3_HandleCertificateRequest(sslSocket 
      desc = no_certificate;
      ss->ssl3.hs.ws = wait_hello_done;
  
@@ -111,12 +109,12 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
 +                                        &ss->ssl3.clientPrivateKey);
 +    } else
 +#endif
-     if (ss->getClientAuthData != NULL) {
- 	/* XXX Should pass cert_types in this call!! */
- 	rv = (SECStatus)(*ss->getClientAuthData)(ss->getClientAuthDataArg,
-@@ -6113,12 +6150,52 @@ ssl3_HandleCertificateRequest(sslSocket
-     } else {
+     if (ss->getClientAuthData == NULL) {
  	rv = SECFailure; /* force it to send a no_certificate alert */
+     } else {
+@@ -5992,12 +6029,52 @@ ssl3_HandleCertificateRequest(sslSocket 
+ 						 &ss->ssl3.clientCertificate,
+ 						 &ss->ssl3.clientPrivateKey);
      }
 +
      switch (rv) {
@@ -167,7 +165,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
          /* check what the callback function returned */
          if ((!ss->ssl3.clientCertificate) || (!ss->ssl3.clientPrivateKey)) {
              /* we are missing either the key or cert */
-@@ -6181,6 +6258,10 @@ loser:
+@@ -6060,6 +6137,10 @@ loser:
  done:
      if (arena != NULL)
      	PORT_FreeArena(arena, PR_FALSE);
@@ -178,7 +176,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      return rv;
  }
  
-@@ -6262,7 +6343,8 @@ ssl3_SendClientSecondRound(sslSocket *ss
+@@ -6134,7 +6215,8 @@ ssl3_SendClientSecondRound(sslSocket *ss
  
      sendClientCert = !ss->ssl3.sendEmptyCert &&
  		     ss->ssl3.clientCertChain  != NULL &&
@@ -188,7 +186,7 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      /* We must wait for the server's certificate to be authenticated before
       * sending the client certificate in order to disclosing the client
-@@ -10815,6 +10897,10 @@ ssl3_DestroySSL3Info(sslSocket *ss)
+@@ -10446,6 +10528,10 @@ ssl3_DestroySSL3Info(sslSocket *ss)
  
      if (ss->ssl3.clientPrivateKey != NULL)
  	SECKEY_DestroyPrivateKey(ss->ssl3.clientPrivateKey);
@@ -199,9 +197,9 @@ diff -puN a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  
      if (ss->ssl3.peerCertArena != NULL)
  	ssl3_CleanupPeerCerts(ss);
-diff -puN a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
---- a/nss/lib/ssl/ssl3ext.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/ssl3ext.c	2013-04-27 09:20:50.169405985 -0700
+diff -puN -r a/net/third_party/nss/ssl/ssl3ext.c b/net/third_party/nss/ssl/ssl3ext.c
+--- a/net/third_party/nss/ssl/ssl3ext.c	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/ssl3ext.c	2012-11-09 15:35:08.488958561 -0800
 @@ -11,8 +11,8 @@
  #include "nssrenam.h"
  #include "nss.h"
@@ -212,10 +210,10 @@ diff -puN a/nss/lib/ssl/ssl3ext.c b/nss/lib/ssl/ssl3ext.c
  #include "pk11pub.h"
  #ifdef NO_PKCS11_BYPASS
  #include "blapit.h"
-diff -puN a/nss/lib/ssl/sslauth.c b/nss/lib/ssl/sslauth.c
---- a/nss/lib/ssl/sslauth.c	2013-04-27 09:20:36.319209880 -0700
-+++ b/nss/lib/ssl/sslauth.c	2013-04-27 09:20:50.359408673 -0700
-@@ -220,6 +220,28 @@ SSL_GetClientAuthDataHook(PRFileDesc *s,
+diff -puN -r a/net/third_party/nss/ssl/sslauth.c b/net/third_party/nss/ssl/sslauth.c
+--- a/net/third_party/nss/ssl/sslauth.c	2012-11-09 15:27:15.952019947 -0800
++++ b/net/third_party/nss/ssl/sslauth.c	2012-11-09 15:35:08.488958561 -0800
+@@ -219,6 +219,28 @@ SSL_GetClientAuthDataHook(PRFileDesc *s,
      return SECSuccess;
  }
  
@@ -244,10 +242,10 @@ diff -puN a/nss/lib/ssl/sslauth.c b/nss/lib/ssl/sslauth.c
  /* NEED LOCKS IN HERE.  */
  SECStatus 
  SSL_SetPKCS11PinArg(PRFileDesc *s, void *arg)
-diff -puN a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:20:36.319209880 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:20:50.409409383 -0700
-@@ -505,6 +505,48 @@ typedef SECStatus (PR_CALLBACK *SSLGetCl
+diff -puN -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 15:35:08.488958561 -0800
+@@ -483,6 +483,48 @@ typedef SECStatus (PR_CALLBACK *SSLGetCl
  SSL_IMPORT SECStatus SSL_GetClientAuthDataHook(PRFileDesc *fd, 
  			                       SSLGetClientAuthData f, void *a);
  
@@ -296,18 +294,10 @@ diff -puN a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
  
  /*
  ** SNI extension processing callback function.
-diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-04-27 09:20:13.658889025 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-04-27 09:20:50.409409383 -0700
-@@ -21,6 +21,7 @@
- #include "sslerr.h"
- #include "ssl3prot.h"
- #include "hasht.h"
-+#include "keythi.h"
- #include "nssilock.h"
- #include "pkcs11t.h"
- #if defined(XP_UNIX) || defined(XP_BEOS)
-@@ -32,6 +33,15 @@
+diff -puN -r a/net/third_party/nss/ssl/sslimpl.h b/net/third_party/nss/ssl/sslimpl.h
+--- a/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:34:12.258133766 -0800
++++ b/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:36:42.600338478 -0800
+@@ -32,6 +32,15 @@
  
  #include "sslt.h" /* for some formerly private types, now public */
  
@@ -323,7 +313,7 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  /* to make some of these old enums public without namespace pollution,
  ** it was necessary to prepend ssl_ to the names.
  ** These #defines preserve compatibility with the old code here in libssl.
-@@ -444,6 +454,14 @@ typedef SECStatus (*SSLCompressor)(void
+@@ -446,6 +455,14 @@ typedef SECStatus (*SSLCompressor)(void 
                                     int                  inlen);
  typedef SECStatus (*SSLDestroy)(void *context, PRBool freeit);
  
@@ -338,7 +328,7 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  
  
  /*
-@@ -862,6 +880,10 @@ struct ssl3StateStr {
+@@ -870,6 +887,10 @@ struct ssl3StateStr {
  
      CERTCertificate *    clientCertificate;  /* used by client */
      SECKEYPrivateKey *   clientPrivateKey;   /* used by client */
@@ -349,7 +339,7 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
      CERTCertificateList *clientCertChain;    /* used by client */
      PRBool               sendEmptyCert;      /* used by client */
  
-@@ -1119,6 +1141,10 @@ const unsigned char *  preferredCipher;
+@@ -1127,6 +1148,10 @@ const unsigned char *  preferredCipher;
      void                     *authCertificateArg;
      SSLGetClientAuthData      getClientAuthData;
      void                     *getClientAuthDataArg;
@@ -360,7 +350,7 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
      SSLSNISocketConfig        sniSocketConfig;
      void                     *sniSocketConfigArg;
      SSLBadCertHandler         handleBadCert;
-@@ -1691,7 +1717,6 @@ extern void ssl_FreePRSocket(PRFileDesc
+@@ -1700,7 +1725,6 @@ extern void ssl_FreePRSocket(PRFileDesc 
   * various ciphers */
  extern int ssl3_config_match_init(sslSocket *);
  
@@ -368,7 +358,7 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  /* Create a new ref counted key pair object from two keys. */
  extern ssl3KeyPair * ssl3_NewKeyPair( SECKEYPrivateKey * privKey, 
                                        SECKEYPublicKey * pubKey);
-@@ -1731,6 +1756,26 @@ extern SECStatus ssl_InitSessionCacheLoc
+@@ -1740,6 +1764,26 @@ extern SECStatus ssl_InitSessionCacheLoc
  
  extern SECStatus ssl_FreeSessionCacheLocks(void);
  
@@ -381,7 +371,7 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
 +// Implement the client CertificateVerify message for SSL3/TLS1.0
 +extern SECStatus ssl3_PlatformSignHashes(SSL3Hashes *hash,
 +                                         PlatformKey key, SECItem *buf,
-+                                         PRBool isTLS, KeyType keyType);
++                                         PRBool isTLS);
 +
 +// Converts a CERTCertList* (A collection of CERTCertificates) into a
 +// CERTCertificateList* (A collection of SECItems), or returns NULL if
@@ -395,10 +385,10 @@ diff -puN a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  
  /**************** DTLS-specific functions **************/
  extern void dtls_FreeQueuedMessage(DTLSQueuedMessage *msg);
-diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
---- a/nss/lib/ssl/sslplatf.c	1969-12-31 16:00:00.000000000 -0800
-+++ b/nss/lib/ssl/sslplatf.c	2013-04-27 09:20:50.409409383 -0700
-@@ -0,0 +1,583 @@
+diff -puN -r a/net/third_party/nss/ssl/sslplatf.c b/net/third_party/nss/ssl/sslplatf.c
+--- a/net/third_party/nss/ssl/sslplatf.c	1969-12-31 16:00:00.000000000 -0800
++++ b/net/third_party/nss/ssl/sslplatf.c	2012-11-09 15:35:08.498958708 -0800
+@@ -0,0 +1,399 @@
 +/*
 + * Platform specific crypto wrappers
 + *
@@ -439,21 +429,12 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 + *
 + * ***** END LICENSE BLOCK ***** */
 +/* $Id$ */
++#include "ssl.h"
 +#include "certt.h"
-+#include "cryptohi.h"
 +#include "keythi.h"
-+#include "nss.h"
-+#include "secitem.h"
-+#include "ssl.h"
 +#include "sslimpl.h"
-+#include "prerror.h"
-+#include "prinit.h"
-+
-+#ifdef NSS_PLATFORM_CLIENT_AUTH
-+#ifdef XP_WIN32
-+#include <NCrypt.h>
-+#endif
-+#endif
++#include "cryptohi.h"
++#include "secitem.h"
 +
 +#ifdef NSS_PLATFORM_CLIENT_AUTH
 +CERTCertificateList*
@@ -508,206 +489,27 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +}
 +
 +#if defined(XP_WIN32)
-+typedef SECURITY_STATUS (WINAPI *NCryptFreeObjectFunc)(NCRYPT_HANDLE);
-+typedef SECURITY_STATUS (WINAPI *NCryptSignHashFunc)(
-+    NCRYPT_KEY_HANDLE /* hKey */,
-+    VOID* /* pPaddingInfo */,
-+    PBYTE /* pbHashValue */,
-+    DWORD /* cbHashValue */,
-+    PBYTE /* pbSignature */,
-+    DWORD /* cbSignature */,
-+    DWORD* /* pcbResult */,
-+    DWORD /* dwFlags */);
-+
-+static PRCallOnceType cngFunctionsInitOnce;
-+static const PRCallOnceType pristineCallOnce;
-+
-+static PRLibrary *ncrypt_library = NULL;
-+static NCryptFreeObjectFunc pNCryptFreeObject = NULL;
-+static NCryptSignHashFunc pNCryptSignHash = NULL;
-+
-+static SECStatus
-+ssl_ShutdownCngFunctions(void *appData, void *nssData)
-+{
-+    pNCryptSignHash = NULL;
-+    pNCryptFreeObject = NULL;
-+    if (ncrypt_library) {
-+        PR_UnloadLibrary(ncrypt_library);
-+        ncrypt_library = NULL;
-+    }
-+
-+    cngFunctionsInitOnce = pristineCallOnce;
-+
-+    return SECSuccess;
-+}
-+
-+static PRStatus
-+ssl_InitCngFunctions(void)
-+{
-+    SECStatus rv;
-+
-+    ncrypt_library = PR_LoadLibrary("ncrypt.dll");
-+    if (ncrypt_library == NULL)
-+        goto loser;
-+
-+    pNCryptFreeObject = (NCryptFreeObjectFunc)PR_FindFunctionSymbol(
-+        ncrypt_library, "NCryptFreeObject");
-+    if (pNCryptFreeObject == NULL)
-+        goto loser;
-+
-+    pNCryptSignHash = (NCryptSignHashFunc)PR_FindFunctionSymbol(
-+        ncrypt_library, "NCryptSignHash");
-+    if (pNCryptSignHash == NULL)
-+        goto loser;
-+
-+    rv = NSS_RegisterShutdown(ssl_ShutdownCngFunctions, NULL);
-+    if (rv != SECSuccess)
-+        goto loser;
-+
-+    return PR_SUCCESS;
-+
-+loser:
-+    pNCryptSignHash = NULL;
-+    pNCryptFreeObject = NULL;
-+    if (ncrypt_library) {
-+        PR_UnloadLibrary(ncrypt_library);
-+        ncrypt_library = NULL;
-+    }
-+
-+    return PR_FAILURE;
-+}
-+
-+static SECStatus
-+ssl_InitCng(void)
-+{
-+    if (PR_CallOnce(&cngFunctionsInitOnce, ssl_InitCngFunctions) != PR_SUCCESS)
-+        return SECFailure;
-+    return SECSuccess;
-+}
-+
 +void
 +ssl_FreePlatformKey(PlatformKey key)
 +{
-+    if (!key)
-+        return;
-+
-+    if (key->dwKeySpec == CERT_NCRYPT_KEY_SPEC) {
-+        if (ssl_InitCng() == SECSuccess) {
-+            (*pNCryptFreeObject)(key->hNCryptKey);
-+        }
-+    } else {
-+        CryptReleaseContext(key->hCryptProv, 0);
++    if (key) {
++        if (key->dwKeySpec != CERT_NCRYPT_KEY_SPEC)
++            CryptReleaseContext(key->hCryptProv, 0);
++        /* FIXME(rsleevi): Close CNG keys. */
++        PORT_Free(key);
 +    }
-+    PORT_Free(key);
 +}
 +
-+static SECStatus
-+ssl3_CngPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-+                           PRBool isTLS, KeyType keyType)
-+{
-+    SECStatus       rv                = SECFailure;
-+    SECURITY_STATUS ncrypt_status;
-+    PRBool          doDerEncode       = PR_FALSE;
-+    SECItem         hashItem;
-+    DWORD           signatureLen      = 0;
-+    DWORD           dwFlags           = 0;
-+    VOID           *pPaddingInfo      = NULL;
-+
-+    /* Always encode using PKCS#1 block type, with no OID/encoded DigestInfo */
-+    BCRYPT_PKCS1_PADDING_INFO rsaPaddingInfo;
-+    rsaPaddingInfo.pszAlgId = NULL;
-+
-+    if (key->dwKeySpec != CERT_NCRYPT_KEY_SPEC) {
-+        PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
-+        return SECFailure;
-+    }
-+    if (ssl_InitCng() != SECSuccess) {
-+        PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
-+        return SECFailure;
-+    }
-+
-+    switch (keyType) {
-+        case rsaKey:
-+            hashItem.data = hash->md5;
-+            hashItem.len  = sizeof(SSL3Hashes);
-+            dwFlags       = BCRYPT_PAD_PKCS1;
-+            pPaddingInfo  = &rsaPaddingInfo;
-+            break;
-+        case dsaKey:
-+        case ecKey:
-+            if (keyType == ecKey) {
-+                doDerEncode = PR_TRUE;
-+            } else {
-+                doDerEncode = isTLS;
-+            }
-+            hashItem.data = hash->sha;
-+            hashItem.len  = sizeof(hash->sha);
-+            break;
-+        default:
-+            PORT_SetError(SEC_ERROR_INVALID_KEY);
-+            goto done;
-+    }
-+    PRINT_BUF(60, (NULL, "hash(es) to be signed", hashItem.data, hashItem.len));
-+
-+    ncrypt_status = (*pNCryptSignHash)(key->hNCryptKey, pPaddingInfo,
-+                                       (PBYTE)hashItem.data, hashItem.len,
-+                                       NULL, 0, &signatureLen, dwFlags);
-+    if (FAILED(ncrypt_status) || signatureLen == 0) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, ncrypt_status);
-+        goto done;
-+    }
-+
-+    buf->data = (unsigned char *)PORT_Alloc(signatureLen);
-+    if (!buf->data) {
-+        goto done;    /* error code was set. */
-+    }
-+
-+    ncrypt_status = (*pNCryptSignHash)(key->hNCryptKey, pPaddingInfo,
-+                                       (PBYTE)hashItem.data, hashItem.len,
-+                                       (PBYTE)buf->data, signatureLen,
-+                                       &signatureLen, dwFlags);
-+    if (FAILED(ncrypt_status) || signatureLen == 0) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, ncrypt_status);
-+        goto done;
-+    }
-+
-+    buf->len = signatureLen;
-+
-+    if (doDerEncode) {
-+        SECItem   derSig = {siBuffer, NULL, 0};
-+
-+        /* This also works for an ECDSA signature */
-+        rv = DSAU_EncodeDerSigWithLen(&derSig, buf, buf->len);
-+        if (rv == SECSuccess) {
-+            PORT_Free(buf->data);     /* discard unencoded signature. */
-+            *buf = derSig;            /* give caller encoded signature. */
-+        } else if (derSig.data) {
-+            PORT_Free(derSig.data);
-+        }
-+    } else {
-+        rv = SECSuccess;
-+    }
-+
-+    PRINT_BUF(60, (NULL, "signed hashes", buf->data, buf->len));
-+
-+done:
-+    if (rv != SECSuccess && buf->data) {
-+        PORT_Free(buf->data);
-+        buf->data = NULL;
-+        buf->len = 0;
-+    }
-+
-+    return rv;
-+}
-+
-+static SECStatus
-+ssl3_CAPIPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-+                            PRBool isTLS, KeyType keyType)
++SECStatus
++ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf, 
++                        PRBool isTLS)
 +{
 +    SECStatus    rv             = SECFailure;
 +    PRBool       doDerEncode    = PR_FALSE;
 +    SECItem      hashItem;
++    HCRYPTKEY    hKey           = 0;
 +    DWORD        argLen         = 0;
++    ALG_ID       keyAlg         = 0;
 +    DWORD        signatureLen   = 0;
 +    ALG_ID       hashAlg        = 0;
 +    HCRYPTHASH   hHash          = 0;
@@ -715,16 +517,31 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +    unsigned int i              = 0;
 +
 +    buf->data = NULL;
++    if (!CryptGetUserKey(key->hCryptProv, key->dwKeySpec, &hKey)) {
++        if (GetLastError() == NTE_NO_KEY) {
++            PORT_SetError(SEC_ERROR_NO_KEY);
++        } else {
++            PORT_SetError(SEC_ERROR_INVALID_KEY);
++        }
++        goto done;
++    }
++
++    argLen = sizeof(keyAlg);
++    if (!CryptGetKeyParam(hKey, KP_ALGID, (BYTE*)&keyAlg, &argLen, 0)) {
++        PORT_SetError(SEC_ERROR_INVALID_KEY);
++        goto done;
++    }
 +
-+    switch (keyType) {
-+        case rsaKey:
++    switch (keyAlg) {
++        case CALG_RSA_KEYX:
++        case CALG_RSA_SIGN:
 +            hashAlg       = CALG_SSL3_SHAMD5;
 +            hashItem.data = hash->md5;
 +            hashItem.len  = sizeof(SSL3Hashes);
 +            break;
-+        case dsaKey:
-+        case ecKey:
-+            if (keyType == ecKey) {
++        case CALG_DSS_SIGN:
++        case CALG_ECDSA:
++            if (keyAlg == CALG_ECDSA) {
 +                doDerEncode = PR_TRUE;
 +            } else {
 +                doDerEncode = isTLS;
@@ -740,25 +557,25 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +    PRINT_BUF(60, (NULL, "hash(es) to be signed", hashItem.data, hashItem.len));
 +
 +    if (!CryptCreateHash(key->hCryptProv, hashAlg, 0, 0, &hHash)) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
-+        goto done;
++        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
++        goto done;    
 +    }
 +    argLen = sizeof(hashLen);
 +    if (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&hashLen, &argLen, 0)) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
++        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
 +        goto done;
 +    }
 +    if (hashLen != hashItem.len) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, 0);
++        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
 +        goto done;
 +    }
 +    if (!CryptSetHashParam(hHash, HP_HASHVAL, (BYTE*)hashItem.data, 0)) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
++        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
 +        goto done;
 +    }
 +    if (!CryptSignHash(hHash, key->dwKeySpec, NULL, 0,
 +                       NULL, &signatureLen) || signatureLen == 0) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
++        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
 +        goto done;
 +    }
 +    buf->data = (unsigned char *)PORT_Alloc(signatureLen);
@@ -767,7 +584,7 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +
 +    if (!CryptSignHash(hHash, key->dwKeySpec, NULL, 0,
 +                       (BYTE*)buf->data, &signatureLen)) {
-+        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
++        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
 +        goto done;
 +    }
 +    buf->len = signatureLen;
@@ -797,6 +614,8 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +done:
 +    if (hHash)
 +        CryptDestroyHash(hHash);
++    if (hKey)
++        CryptDestroyKey(hKey);
 +    if (rv != SECSuccess && buf->data) {
 +        PORT_Free(buf->data);
 +        buf->data = NULL;
@@ -804,16 +623,6 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +    return rv;
 +}
 +
-+SECStatus
-+ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-+                        PRBool isTLS, KeyType keyType)
-+{
-+    if (key->dwKeySpec == CERT_NCRYPT_KEY_SPEC) {
-+        return ssl3_CngPlatformSignHashes(hash, key, buf, isTLS, keyType);
-+    }
-+    return ssl3_CAPIPlatformSignHashes(hash, key, buf, isTLS, keyType);
-+}
-+
 +#elif defined(XP_MACOSX)
 +#include <Security/cssm.h>
 +
@@ -824,8 +633,8 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +}
 +
 +SECStatus
-+ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-+                        PRBool isTLS, KeyType keyType)
++ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf, 
++                        PRBool isTLS)
 +{
 +    SECStatus       rv                  = SECFailure;
 +    PRBool          doDerEncode         = PR_FALSE;
@@ -858,7 +667,7 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +     * needed information is readily available on the key itself.
 +     */
 +    signatureLen = (cssmKey->KeyHeader.LogicalKeySizeInBits + 7) / 8;
-+
++    
 +    if (signatureLen == 0) {
 +        PORT_SetError(SEC_ERROR_INVALID_KEY);
 +        goto done;
@@ -869,19 +678,16 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +        goto done;    /* error code was set. */
 +
 +    sigAlg = cssmKey->KeyHeader.AlgorithmId;
-+    switch (keyType) {
-+        case rsaKey:
-+            PORT_Assert(sigAlg == CSSM_ALGID_RSA);
++    switch (sigAlg) {
++        case CSSM_ALGID_RSA:
 +            hashData.Data   = hash->md5;
 +            hashData.Length = sizeof(SSL3Hashes);
 +            break;
-+        case dsaKey:
-+        case ecKey:
-+            if (keyType == ecKey) {
-+                PORT_Assert(sigAlg == CSSM_ALGID_ECDSA);
++        case CSSM_ALGID_ECDSA:
++        case CSSM_ALGID_DSA:
++            if (sigAlg == CSSM_ALGID_ECDSA) {
 +                doDerEncode = PR_TRUE;
 +            } else {
-+                PORT_Assert(sigAlg == CSSM_ALGID_DSA);
 +                doDerEncode = isTLS;
 +            }
 +            hashData.Data   = hash->sha;
@@ -906,7 +712,7 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +
 +    signatureData.Length = signatureLen;
 +    signatureData.Data   = (uint8*)buf->data;
-+
++    
 +    cssmRv = CSSM_CSP_CreateSignatureContext(cspHandle, sigAlg, cssmCreds,
 +                                             cssmKey, &cssmSignature);
 +    if (cssmRv) {
@@ -974,7 +780,7 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +
 +SECStatus
 +ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-+                        PRBool isTLS, KeyType keyType)
++                        PRBool isTLS)
 +{
 +    PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
 +    return SECFailure;
@@ -982,10 +788,10 @@ diff -puN a/nss/lib/ssl/sslplatf.c b/nss/lib/ssl/sslplatf.c
 +#endif
 +
 +#endif /* NSS_PLATFORM_CLIENT_AUTH */
-diff -puN a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
---- a/nss/lib/ssl/sslsock.c	2013-04-27 09:19:05.777927838 -0700
-+++ b/nss/lib/ssl/sslsock.c	2013-04-27 09:20:50.419409524 -0700
-@@ -337,6 +337,10 @@ ssl_DupSocket(sslSocket *os)
+diff -puN -r a/net/third_party/nss/ssl/sslsock.c b/net/third_party/nss/ssl/sslsock.c
+--- a/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:34:12.268133912 -0800
++++ b/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:35:08.498958708 -0800
+@@ -335,6 +335,10 @@ ssl_DupSocket(sslSocket *os)
  	    ss->authCertificateArg    = os->authCertificateArg;
  	    ss->getClientAuthData     = os->getClientAuthData;
  	    ss->getClientAuthDataArg  = os->getClientAuthDataArg;
@@ -996,7 +802,7 @@ diff -puN a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
              ss->sniSocketConfig       = os->sniSocketConfig;
              ss->sniSocketConfigArg    = os->sniSocketConfigArg;
  	    ss->handleBadCert         = os->handleBadCert;
-@@ -1725,6 +1729,12 @@ SSL_ReconfigFD(PRFileDesc *model, PRFile
+@@ -1712,6 +1716,12 @@ SSL_ReconfigFD(PRFileDesc *model, PRFile
          ss->getClientAuthData     = sm->getClientAuthData;
      if (sm->getClientAuthDataArg)
          ss->getClientAuthDataArg  = sm->getClientAuthDataArg;
@@ -1009,7 +815,7 @@ diff -puN a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
      if (sm->sniSocketConfig)
          ss->sniSocketConfig       = sm->sniSocketConfig;
      if (sm->sniSocketConfigArg)
-@@ -2977,6 +2987,10 @@ ssl_NewSocket(PRBool makeLocks, SSLProto
+@@ -2942,6 +2952,10 @@ ssl_NewSocket(PRBool makeLocks, SSLProto
          ss->sniSocketConfig    = NULL;
          ss->sniSocketConfigArg = NULL;
  	ss->getClientAuthData  = NULL;
diff --git a/src/net/third_party/nss/patches/didhandshakeresume.patch b/src/net/third_party/nss/patches/didhandshakeresume.patch
index 2b3b9aa..3523cb7 100644
--- a/src/net/third_party/nss/patches/didhandshakeresume.patch
+++ b/src/net/third_party/nss/patches/didhandshakeresume.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:21:28.339946428 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:21:50.660262443 -0700
-@@ -942,6 +942,9 @@ SSL_IMPORT SECStatus SSL_HandshakeNegoti
+diff -pu -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-11-09 15:44:22.247069358 -0800
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 15:43:25.766243027 -0800
+@@ -917,6 +917,9 @@ SSL_IMPORT SECStatus SSL_HandshakeNegoti
                                                        SSLExtensionType extId,
                                                        PRBool *yes);
  
@@ -11,11 +11,11 @@ diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
  /*
  ** How long should we wait before retransmitting the next flight of
  ** the DTLS handshake? Returns SECFailure if not DTLS or not in a
-diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
---- a/nss/lib/ssl/sslsock.c	2013-04-27 09:21:28.339946428 -0700
-+++ b/nss/lib/ssl/sslsock.c	2013-04-27 09:21:50.660262443 -0700
-@@ -1914,6 +1914,20 @@ SSL_PeerStapledOCSPResponses(PRFileDesc
-     return &ss->sec.ci.sid->peerCertStatus;
+diff -pu -r a/net/third_party/nss/ssl/sslsock.c b/net/third_party/nss/ssl/sslsock.c
+--- a/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:44:22.247069358 -0800
++++ b/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:40:33.053714908 -0800
+@@ -1912,6 +1912,20 @@ SSL_GetStapledOCSPResponse(PRFileDesc *f
+     return SECSuccess;
  }
  
 +SECStatus
diff --git a/src/net/third_party/nss/patches/ecpointform.patch b/src/net/third_party/nss/patches/ecpointform.patch
index 68d1ea5..cfe2930 100644
--- a/src/net/third_party/nss/patches/ecpointform.patch
+++ b/src/net/third_party/nss/patches/ecpointform.patch
@@ -1,6 +1,6 @@
-diff -pu a/nss/lib/ssl/ssl3ecc.c b/nss/lib/ssl/ssl3ecc.c
---- a/nss/lib/ssl/ssl3ecc.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/ssl3ecc.c	2013-04-27 09:40:07.665786293 -0700
+diff -pu -r a/net/third_party/nss/ssl/ssl3ecc.c b/net/third_party/nss/ssl/ssl3ecc.c
+--- a/net/third_party/nss/ssl/ssl3ecc.c	2012-06-10 19:38:30.000000000 -0700
++++ b/net/third_party/nss/ssl/ssl3ecc.c	2012-11-12 15:57:59.222697369 -0800
 @@ -33,6 +33,15 @@
  
  #ifdef NSS_ENABLE_ECC
diff --git a/src/net/third_party/nss/patches/getrequestedclientcerttypes.patch b/src/net/third_party/nss/patches/getrequestedclientcerttypes.patch
index 8677caa..050568e 100644
--- a/src/net/third_party/nss/patches/getrequestedclientcerttypes.patch
+++ b/src/net/third_party/nss/patches/getrequestedclientcerttypes.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:21:28.339946428 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:22:57.051202381 -0700
-@@ -6069,6 +6069,9 @@ ssl3_HandleCertificateRequest(sslSocket
+diff -pu -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:39:36.842891686 -0800
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:47:24.309734248 -0800
+@@ -5946,6 +5946,9 @@ ssl3_HandleCertificateRequest(sslSocket 
      if (rv != SECSuccess)
      	goto loser;		/* malformed, alert has been sent */
  
@@ -11,7 +11,7 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      arena = ca_list.arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
      if (arena == NULL)
      	goto no_mem;
-@@ -6256,6 +6259,7 @@ loser:
+@@ -6135,6 +6138,7 @@ loser:
      PORT_SetError(errCode);
      rv = SECFailure;
  done:
@@ -19,10 +19,10 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
      if (arena != NULL)
      	PORT_FreeArena(arena, PR_FALSE);
  #ifdef NSS_PLATFORM_CLIENT_AUTH
-diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:22:15.960620644 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:22:57.051202381 -0700
-@@ -734,6 +734,16 @@ SSL_IMPORT SECStatus SSL_ReHandshakeWith
+diff -pu -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-11-09 15:44:43.337377864 -0800
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 15:47:24.309734248 -0800
+@@ -709,6 +709,16 @@ SSL_IMPORT SECStatus SSL_ReHandshakeWith
                                                  PRBool flushCache,
                                                  PRIntervalTime timeout);
  
@@ -39,10 +39,10 @@ diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
  
  #ifdef SSL_DEPRECATED_FUNCTION 
  /* deprecated!
-diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-04-27 09:21:28.339946428 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-04-27 09:22:57.051202381 -0700
-@@ -1134,6 +1134,10 @@ struct sslSocketStr {
+diff -pu -r a/net/third_party/nss/ssl/sslimpl.h b/net/third_party/nss/ssl/sslimpl.h
+--- a/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:39:36.942893150 -0800
++++ b/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:47:24.309734248 -0800
+@@ -1141,6 +1141,10 @@ struct sslSocketStr {
      unsigned int     sizeCipherSpecs;
  const unsigned char *  preferredCipher;
  
@@ -53,10 +53,10 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
      ssl3KeyPair *         stepDownKeyPair;	/* RSA step down keys */
  
      /* Callbacks */
-diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
---- a/nss/lib/ssl/sslsock.c	2013-04-27 09:22:15.960620644 -0700
-+++ b/nss/lib/ssl/sslsock.c	2013-04-27 09:22:57.051202381 -0700
-@@ -1928,6 +1928,20 @@ SSL_HandshakeResumedSession(PRFileDesc *
+diff -pu -r a/net/third_party/nss/ssl/sslsock.c b/net/third_party/nss/ssl/sslsock.c
+--- a/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:44:43.337377864 -0800
++++ b/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:47:24.309734248 -0800
+@@ -1926,6 +1926,20 @@ SSL_HandshakeResumedSession(PRFileDesc *
      return SECSuccess;
  }
  
@@ -77,11 +77,11 @@ diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
  /************************************************************************/
  /* The following functions are the TOP LEVEL SSL functions.
  ** They all get called through the NSPRIOMethods table below.
-@@ -2991,6 +3005,7 @@ ssl_NewSocket(PRBool makeLocks, SSLProto
+@@ -2957,6 +2971,7 @@ ssl_NewSocket(PRBool makeLocks, SSLProto
  	    sc->serverKeyPair   = NULL;
  	    sc->serverKeyBits   = 0;
  	}
 +	ss->requestedCertTypes = NULL;
  	ss->stepDownKeyPair    = NULL;
  	ss->dbHandle           = CERT_GetDefaultCertDB();
- 	ss->certStatusArray    = NULL;
+ 
diff --git a/src/net/third_party/nss/patches/handlecertstatus.patch b/src/net/third_party/nss/patches/handlecertstatus.patch
deleted file mode 100644
index 48ddfdb..0000000
--- a/src/net/third_party/nss/patches/handlecertstatus.patch
+++ /dev/null
@@ -1,64 +0,0 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-05-04 11:26:17.636818185 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-05-04 11:24:00.074886386 -0700
-@@ -9952,21 +9952,31 @@ ssl3_HandleHandshakeMessage(sslSocket *s
-      * get one when it is allowed, but otherwise we just carry on.
-      */
-     if (ss->ssl3.hs.ws == wait_certificate_status) {
--       /* We must process any CertificateStatus message before we call
--        * ssl3_AuthCertificate, as ssl3_AuthCertificate needs any stapled OCSP
--        * response we get.
--        */
--       if (ss->ssl3.hs.msg_type == certificate_status) {
--           rv = ssl3_HandleCertificateStatus(ss, b, length);
--           if (rv != SECSuccess)
--               return rv;
--       }
-+        /* We must process any CertificateStatus message before we call
-+         * ssl3_AuthCertificate, as ssl3_AuthCertificate needs any stapled
-+         * OCSP response we get.
-+         */
-+        if (ss->ssl3.hs.msg_type == certificate_status) {
-+            rv = ssl3_HandleCertificateStatus(ss, b, length);
-+            if (rv != SECSuccess)
-+                return rv;
-+            if (IS_DTLS(ss)) {
-+                /* Increment the expected sequence number */
-+                ss->ssl3.hs.recvMessageSeq++;
-+            }
-+        }
- 
--       /* Regardless of whether we got a CertificateStatus message, we must
--        * authenticate the cert before we handle any more handshake messages.
--        */
--       rv = ssl3_AuthCertificate(ss); /* sets ss->ssl3.hs.ws */
--    } else switch (ss->ssl3.hs.msg_type) {
-+        /* Regardless of whether we got a CertificateStatus message, we must
-+         * authenticate the cert before we handle any more handshake messages.
-+         */
-+        rv = ssl3_AuthCertificate(ss); /* sets ss->ssl3.hs.ws */
-+        PORT_Assert(rv != SECWouldBlock);
-+        if (rv != SECSuccess || ss->ssl3.hs.msg_type == certificate_status) {
-+            return rv;
-+        }
-+    }
-+
-+    switch (ss->ssl3.hs.msg_type) {
-     case hello_request:
- 	if (length != 0) {
- 	    (void)ssl3_DecodeError(ss);
-@@ -10008,10 +10018,10 @@ ssl3_HandleHandshakeMessage(sslSocket *s
- 	rv = ssl3_HandleCertificate(ss, b, length);
- 	break;
-     case certificate_status:
--       /* The good case is handled above */
--       PORT_SetError(SSL_ERROR_RX_UNEXPECTED_CERT_STATUS);
--       rv = SECFailure;
--       break;
-+	/* The good case is handled above */
-+	(void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
-+	PORT_SetError(SSL_ERROR_RX_UNEXPECTED_CERT_STATUS);
-+	return SECFailure;
-     case server_key_exchange:
- 	if (ss->sec.isServer) {
- 	    (void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
diff --git a/src/net/third_party/nss/patches/negotiatedextension.patch b/src/net/third_party/nss/patches/negotiatedextension.patch
index ce342da..b2b12de 100644
--- a/src/net/third_party/nss/patches/negotiatedextension.patch
+++ b/src/net/third_party/nss/patches/negotiatedextension.patch
@@ -1,6 +1,6 @@
-diff -pu a/nss/lib/ssl/sslreveal.c b/nss/lib/ssl/sslreveal.c
---- a/nss/lib/ssl/sslreveal.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslreveal.c	2013-04-27 09:22:26.910775670 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslreveal.c b/net/third_party/nss/ssl/sslreveal.c
+--- a/net/third_party/nss/ssl/sslreveal.c	2012-04-25 07:50:12.000000000 -0700
++++ b/net/third_party/nss/ssl/sslreveal.c	2012-11-09 15:45:44.118267683 -0800
 @@ -79,7 +79,6 @@ SSL_HandshakeNegotiatedExtension(PRFileD
    /* some decisions derived from SSL_GetChannelInfo */
    sslSocket * sslsocket = NULL;
diff --git a/src/net/third_party/nss/patches/peercertchain.patch b/src/net/third_party/nss/patches/peercertchain.patch
index 4453e84..b54bce7 100644
--- a/src/net/third_party/nss/patches/peercertchain.patch
+++ b/src/net/third_party/nss/patches/peercertchain.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/sslauth.c b/nss/lib/ssl/sslauth.c
---- a/nss/lib/ssl/sslauth.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslauth.c	2013-04-27 09:20:21.318997488 -0700
-@@ -29,6 +29,41 @@ SSL_PeerCertificate(PRFileDesc *fd)
+diff -pu -r a/net/third_party/nss/ssl/sslauth.c b/net/third_party/nss/ssl/sslauth.c
+--- a/net/third_party/nss/ssl/sslauth.c	2012-04-25 07:50:12.000000000 -0700
++++ b/net/third_party/nss/ssl/sslauth.c	2012-11-09 15:22:49.448098805 -0800
+@@ -28,6 +28,41 @@ SSL_PeerCertificate(PRFileDesc *fd)
  }
  
  /* NEED LOCKS IN HERE.  */
@@ -43,11 +43,11 @@ diff -pu a/nss/lib/ssl/sslauth.c b/nss/lib/ssl/sslauth.c
  CERTCertificate *
  SSL_LocalCertificate(PRFileDesc *fd)
  {
-diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:20:21.318997488 -0700
-@@ -428,6 +428,18 @@ SSL_SetStapledOCSPResponses(PRFileDesc *
- 			    PRBool takeOwnership);
+diff -pu -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-09-21 14:58:43.000000000 -0700
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 15:22:49.448098805 -0800
+@@ -398,6 +398,18 @@ SSL_IMPORT SECStatus SSL_SecurityStatus(
+ SSL_IMPORT CERTCertificate *SSL_PeerCertificate(PRFileDesc *fd);
  
  /*
 +** Return references to the certificates presented by the SSL peer.
diff --git a/src/net/third_party/nss/patches/renegoscsv.patch b/src/net/third_party/nss/patches/renegoscsv.patch
index 570dd4b..14822a1 100644
--- a/src/net/third_party/nss/patches/renegoscsv.patch
+++ b/src/net/third_party/nss/patches/renegoscsv.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:19:20.388134720 -0700
-@@ -4358,9 +4358,9 @@ ssl3_SendClientHello(sslSocket *ss, PRBo
+diff -pu -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-09-27 22:10:25.000000000 -0700
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:18:00.923858639 -0800
+@@ -4236,9 +4236,9 @@ ssl3_SendClientHello(sslSocket *ss, PRBo
      	return SECFailure;	/* ssl3_config_match_init has set error code. */
  
      /* HACK for SCSV in SSL 3.0.  On initial handshake, prepend SCSV,
diff --git a/src/net/third_party/nss/patches/restartclientauth.patch b/src/net/third_party/nss/patches/restartclientauth.patch
index b0a41c1..b92b24e 100644
--- a/src/net/third_party/nss/patches/restartclientauth.patch
+++ b/src/net/third_party/nss/patches/restartclientauth.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:23:12.111415589 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:23:33.121713028 -0700
-@@ -6269,6 +6269,85 @@ done:
+diff -pu -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:48:41.260860199 -0800
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 15:49:25.751511020 -0800
+@@ -6148,6 +6148,85 @@ done:
      return rv;
  }
  
@@ -87,9 +87,9 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  PRBool
  ssl3_CanFalseStart(sslSocket *ss) {
      PRBool rv;
-diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:23:12.111415589 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:23:33.121713028 -0700
+diff -pu -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-11-09 15:48:41.260860199 -0800
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 15:49:25.751511020 -0800
 @@ -367,6 +367,11 @@ SSL_IMPORT SECStatus SSL_ForceHandshake(
  SSL_IMPORT SECStatus SSL_ForceHandshakeWithTimeout(PRFileDesc *fd,
                                                     PRIntervalTime timeout);
@@ -102,10 +102,10 @@ diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
  /*
  ** Query security status of socket. *on is set to one if security is
  ** enabled. *keySize will contain the stream key size used. *issuer will
-diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-04-27 09:23:12.121415729 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-04-27 09:23:33.121713028 -0700
-@@ -1478,16 +1478,17 @@ extern  SECStatus ssl3_MasterKeyDeriveBy
+diff -pu -r a/net/third_party/nss/ssl/sslimpl.h b/net/third_party/nss/ssl/sslimpl.h
+--- a/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:48:41.260860199 -0800
++++ b/net/third_party/nss/ssl/sslimpl.h	2012-11-09 15:51:26.623278555 -0800
+@@ -1484,16 +1484,17 @@ extern  SECStatus ssl3_MasterKeyDeriveBy
  /* These functions are called from secnav, even though they're "private". */
  
  extern int ssl2_SendErrorMessage(struct sslSocketStr *ss, int error);
@@ -127,9 +127,9 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  extern SECStatus ssl3_AuthCertificateComplete(sslSocket *ss, PRErrorCode error);
  
  /*
-diff -pu a/nss/lib/ssl/sslsecur.c b/nss/lib/ssl/sslsecur.c
---- a/nss/lib/ssl/sslsecur.c	2013-04-27 09:19:05.777927838 -0700
-+++ b/nss/lib/ssl/sslsecur.c	2013-04-27 09:23:33.121713028 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslsecur.c b/net/third_party/nss/ssl/sslsecur.c
+--- a/net/third_party/nss/ssl/sslsecur.c	2012-11-09 15:17:00.432983977 -0800
++++ b/net/third_party/nss/ssl/sslsecur.c	2012-11-09 15:49:25.751511020 -0800
 @@ -1437,17 +1437,70 @@ SSL_CertDBHandleSet(PRFileDesc *fd, CERT
      return SECSuccess;
  }
diff --git a/src/net/third_party/nss/patches/secitemarray.patch b/src/net/third_party/nss/patches/secitemarray.patch
deleted file mode 100644
index fd8a773..0000000
--- a/src/net/third_party/nss/patches/secitemarray.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-05-01 14:37:42.983095831 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-05-01 14:43:06.447667082 -0700
-@@ -1258,6 +1258,15 @@ extern sslSessionIDUncacheFunc ssl_sid_u
- 
- SEC_BEGIN_PROTOS
- 
-+/* Functions for handling SECItemArrays, added in NSS 3.15 */
-+extern SECItemArray *SECITEM_AllocArray(PLArenaPool *arena,
-+                                        SECItemArray *array,
-+                                        unsigned int len);
-+extern SECItemArray *SECITEM_DupArray(PLArenaPool *arena,
-+                                      const SECItemArray *from);
-+extern void SECITEM_FreeArray(SECItemArray *array, PRBool freeit);
-+extern void SECITEM_ZfreeArray(SECItemArray *array, PRBool freeit);
-+
- /* Internal initialization and installation of the SSL error tables */
- extern SECStatus ssl_Init(void);
- extern SECStatus ssl_InitializePRErrorTable(void);
-diff -pu a/nss/lib/ssl/sslt.h b/nss/lib/ssl/sslt.h
---- a/nss/lib/ssl/sslt.h	2013-05-01 14:37:42.983095831 -0700
-+++ b/nss/lib/ssl/sslt.h	2013-05-01 14:43:06.447667082 -0700
-@@ -11,6 +11,19 @@
- 
- #include "prtypes.h"
- 
-+/* SECItemArray is added in NSS 3.15.  Define the type if compiling
-+** against an older version of NSS.
-+*/
-+#include "nssutil.h"
-+#if NSSUTIL_VMAJOR == 3 && NSSUTIL_VMINOR < 15
-+typedef struct SECItemArrayStr SECItemArray;
-+
-+struct SECItemArrayStr {
-+    SECItem *items;
-+    unsigned int len;
-+};
-+#endif  /* NSSUTIL_VMAJOR == 3 && NSSUTIL_VMINOR < 15 */
-+
- typedef struct SSL3StatisticsStr {
-     /* statistics from ssl3_SendClientHello (sch) */
-     long sch_sid_cache_hits;
diff --git a/src/net/third_party/nss/patches/secretexporterlocks.patch b/src/net/third_party/nss/patches/secretexporterlocks.patch
index 1722a07..a7fe305 100644
--- a/src/net/third_party/nss/patches/secretexporterlocks.patch
+++ b/src/net/third_party/nss/patches/secretexporterlocks.patch
@@ -1,6 +1,6 @@
-diff -pu a/nss/lib/ssl/sslinfo.c b/nss/lib/ssl/sslinfo.c
---- a/nss/lib/ssl/sslinfo.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslinfo.c	2013-04-27 09:40:33.236147965 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslinfo.c b/net/third_party/nss/ssl/sslinfo.c
+--- a/net/third_party/nss/ssl/sslinfo.c	2012-08-03 16:54:31.000000000 -0700
++++ b/net/third_party/nss/ssl/sslinfo.c	2012-11-12 16:14:30.596704310 -0800
 @@ -342,8 +342,13 @@ SSL_ExportKeyingMaterial(PRFileDesc *fd,
  	return SECFailure;
      }
diff --git a/src/net/third_party/nss/patches/suitebonly.patch b/src/net/third_party/nss/patches/suitebonly.patch
deleted file mode 100644
index 32926cb..0000000
--- a/src/net/third_party/nss/patches/suitebonly.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-diff -pu a/nss/lib/ssl/ssl3ecc.c b/nss/lib/ssl/ssl3ecc.c
---- a/nss/lib/ssl/ssl3ecc.c	2013-04-27 09:40:21.645984036 -0700
-+++ b/nss/lib/ssl/ssl3ecc.c	2013-04-27 09:42:14.977586966 -0700
-@@ -1031,6 +1031,7 @@ static const PRUint8 ECPtFmt[6] = {
- static PRBool
- ssl3_SuiteBOnly(sslSocket *ss)
- {
-+#if 0
-     /* look to see if we can handle certs less than 163 bits */
-     PK11SlotInfo *slot =
- 	PK11_GetBestSlotWithAttributes(CKM_ECDH1_DERIVE, 0, 163,
-@@ -1043,6 +1044,9 @@ ssl3_SuiteBOnly(sslSocket *ss)
-     /* we can, presume we can do all curves */
-     PK11_FreeSlot(slot);
-     return PR_FALSE;
-+#else
-+    return PR_TRUE;
-+#endif
- }
- 
- /* Send our "canned" (precompiled) Supported Elliptic Curves extension,
diff --git a/src/net/third_party/nss/patches/tls12.patch b/src/net/third_party/nss/patches/tls12.patch
deleted file mode 100644
index c385c00..0000000
--- a/src/net/third_party/nss/patches/tls12.patch
+++ /dev/null
@@ -1,1942 +0,0 @@
-Index: net/third_party/nss/ssl/sslt.h
-===================================================================
---- net/third_party/nss/ssl/sslt.h	(revision 202696)
-+++ net/third_party/nss/ssl/sslt.h	(working copy)
-@@ -193,6 +193,7 @@
-     ssl_elliptic_curves_xtn          = 10,
-     ssl_ec_point_formats_xtn         = 11,
- #endif
-+    ssl_signature_algorithms_xtn     = 13,
-     ssl_use_srtp_xtn                 = 14,
-     ssl_session_ticket_xtn           = 35,
-     ssl_next_proto_nego_xtn          = 13172,
-@@ -200,6 +201,6 @@
-     ssl_renegotiation_info_xtn       = 0xff01	/* experimental number */
- } SSLExtensionType;
- 
--#define SSL_MAX_EXTENSIONS             9
-+#define SSL_MAX_EXTENSIONS             10
- 
- #endif /* __sslt_h_ */
-Index: net/third_party/nss/ssl/sslproto.h
-===================================================================
---- net/third_party/nss/ssl/sslproto.h	(revision 202696)
-+++ net/third_party/nss/ssl/sslproto.h	(working copy)
-@@ -16,6 +16,7 @@
- #define SSL_LIBRARY_VERSION_3_0			0x0300
- #define SSL_LIBRARY_VERSION_TLS_1_0		0x0301
- #define SSL_LIBRARY_VERSION_TLS_1_1		0x0302
-+#define SSL_LIBRARY_VERSION_TLS_1_2		0x0303
- /* Note: this is the internal format, not the wire format */
- #define SSL_LIBRARY_VERSION_DTLS_1_0		0x0302
- 
-Index: net/third_party/nss/ssl/SSLerrs.h
-===================================================================
---- net/third_party/nss/ssl/SSLerrs.h	(revision 202696)
-+++ net/third_party/nss/ssl/SSLerrs.h	(working copy)
-@@ -412,3 +412,12 @@
- 
- ER3(SSL_ERROR_GET_CHANNEL_ID_FAILED, (SSL_ERROR_BASE + 128),
- "The application could not get a TLS Channel ID.")
-+
-+ER3(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM, (SSL_ERROR_BASE + 129),
-+"Unsupported hash algorithm used by TLS peer.")
-+
-+ER3(SSL_ERROR_DIGEST_FAILURE, (SSL_ERROR_BASE + 130),
-+"Digest function failed.")
-+
-+ER3(SSL_ERROR_INCORRECT_SIGNATURE_ALGORITHM, (SSL_ERROR_BASE + 131),
-+"Incorrect signature algorithm specified in a digitally-signed element.")
-Index: net/third_party/nss/ssl/sslerr.h
-===================================================================
---- net/third_party/nss/ssl/sslerr.h	(revision 202696)
-+++ net/third_party/nss/ssl/sslerr.h	(working copy)
-@@ -194,6 +194,10 @@
- SSL_ERROR_INVALID_CHANNEL_ID_KEY = (SSL_ERROR_BASE + 127),
- SSL_ERROR_GET_CHANNEL_ID_FAILED = (SSL_ERROR_BASE + 128),
- 
-+SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM = (SSL_ERROR_BASE + 129),
-+SSL_ERROR_DIGEST_FAILURE = (SSL_ERROR_BASE + 130),
-+SSL_ERROR_INCORRECT_SIGNATURE_ALGORITHM = (SSL_ERROR_BASE + 131),
-+
- SSL_ERROR_END_OF_LIST	/* let the c compiler determine the value of this. */
- } SSLErrorCodes;
- #endif /* NO_SECURITY_ERROR_ENUM */
-Index: net/third_party/nss/ssl/sslimpl.h
-===================================================================
---- net/third_party/nss/ssl/sslimpl.h	(revision 202696)
-+++ net/third_party/nss/ssl/sslimpl.h	(working copy)
-@@ -799,6 +799,7 @@
-     PRUint64              sha_cx[MAX_MAC_CONTEXT_LLONGS];
-     PK11Context *         md5;            /* handshake running hashes */
-     PK11Context *         sha;
-+    PK11Context *         tls12_handshake_hash;
- const ssl3KEADef *        kea_def;
-     ssl3CipherSuite       cipher_suite;
- const ssl3CipherSuiteDef *suite_def;
-@@ -820,7 +821,7 @@
-     PRUint16              finishedBytes; /* size of single finished below */
-     union {
- 	TLSFinished       tFinished[2]; /* client, then server */
--	SSL3Hashes        sFinished[2];
-+	SSL3Finished      sFinished[2];
- 	SSL3Opaque        data[72];
-     }                     finishedMsgs;
- #ifdef NSS_ENABLE_ECC
-@@ -835,6 +836,12 @@
-     /* Shared state between ssl3_HandleFinished and ssl3_FinishHandshake */
-     PRBool                cacheSID;
- 
-+    /* clientSigAndHash contains the contents of the signature_algorithms
-+     * extension (if any) from the client. This is only valid for TLS 1.2
-+     * or later. */
-+    SSL3SignatureAndHashAlgorithm *clientSigAndHash;
-+    unsigned int          numClientSigAndHash;
-+
-     /* This group of values is used for DTLS */
-     PRUint16              sendMessageSeq;  /* The sending message sequence
- 					    * number */
-@@ -1473,7 +1480,7 @@
-  * runtime to determine which versions are supported by the version of libssl
-  * in use.
-  */
--#define SSL_LIBRARY_VERSION_MAX_SUPPORTED SSL_LIBRARY_VERSION_TLS_1_1
-+#define SSL_LIBRARY_VERSION_MAX_SUPPORTED SSL_LIBRARY_VERSION_TLS_1_2
- 
- /* Rename this macro SSL_ALL_VERSIONS_DISABLED when SSL 2.0 is removed. */
- #define SSL3_ALL_VERSIONS_DISABLED(vrange) \
-@@ -1639,10 +1646,12 @@
- 				     SSL3Opaque *b, PRUint32 length,
-                                      SECKEYPublicKey *srvrPubKey,
-                                      SECKEYPrivateKey *srvrPrivKey);
--extern SECStatus ssl3_SendECDHServerKeyExchange(sslSocket *ss);
-+extern SECStatus ssl3_SendECDHServerKeyExchange(sslSocket *ss,
-+			const SSL3SignatureAndHashAlgorithm *sigAndHash);
- #endif
- 
--extern SECStatus ssl3_ComputeCommonKeyHash(PRUint8 * hashBuf, 
-+extern SECStatus ssl3_ComputeCommonKeyHash(SECOidTag hashAlg,
-+				PRUint8 * hashBuf,
- 				unsigned int bufLen, SSL3Hashes *hashes, 
- 				PRBool bypassPKCS11);
- extern void ssl3_DestroyCipherSpec(ssl3CipherSpec *spec, PRBool freeSrvName);
-@@ -1655,12 +1664,21 @@
- 			PRInt32 lenSize);
- extern SECStatus ssl3_AppendHandshakeVariable( sslSocket *ss, 
- 			const SSL3Opaque *src, PRInt32 bytes, PRInt32 lenSize);
-+extern SECStatus ssl3_AppendSignatureAndHashAlgorithm(sslSocket *ss,
-+			const SSL3SignatureAndHashAlgorithm* sigAndHash);
- extern SECStatus ssl3_ConsumeHandshake(sslSocket *ss, void *v, PRInt32 bytes, 
- 			SSL3Opaque **b, PRUint32 *length);
- extern PRInt32   ssl3_ConsumeHandshakeNumber(sslSocket *ss, PRInt32 bytes, 
- 			SSL3Opaque **b, PRUint32 *length);
- extern SECStatus ssl3_ConsumeHandshakeVariable(sslSocket *ss, SECItem *i, 
- 			PRInt32 bytes, SSL3Opaque **b, PRUint32 *length);
-+extern SECOidTag ssl3_TLSHashAlgorithmToOID(int hashFunc);
-+extern SECStatus ssl3_CheckSignatureAndHashAlgorithmConsistency(
-+			const SSL3SignatureAndHashAlgorithm *sigAndHash,
-+			CERTCertificate* cert);
-+extern SECStatus ssl3_ConsumeSignatureAndHashAlgorithm(sslSocket *ss,
-+			SSL3Opaque **b, PRUint32 *length,
-+			SSL3SignatureAndHashAlgorithm *out);
- extern SECStatus ssl3_SignHashes(SSL3Hashes *hash, SECKEYPrivateKey *key, 
- 			SECItem *buf, PRBool isTLS);
- extern SECStatus ssl3_VerifySignedHashes(SSL3Hashes *hash, 
-Index: net/third_party/nss/ssl/ssl3prot.h
-===================================================================
---- net/third_party/nss/ssl/ssl3prot.h	(revision 202696)
-+++ net/third_party/nss/ssl/ssl3prot.h	(working copy)
-@@ -212,11 +212,51 @@
-     } u;
- } SSL3ServerParams;
- 
-+/* This enum reflects HashAlgorithm enum from
-+ * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
-+ *
-+ * When updating, be sure to also update ssl3_TLSHashAlgorithmToOID. */
-+enum {
-+    tls_hash_md5 = 1,
-+    tls_hash_sha1 = 2,
-+    tls_hash_sha224 = 3,
-+    tls_hash_sha256 = 4,
-+    tls_hash_sha384 = 5,
-+    tls_hash_sha512 = 6
-+};
-+
-+/* This enum reflects SignatureAlgorithm enum from
-+ * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+typedef enum {
-+    tls_sig_rsa = 1,
-+    tls_sig_dsa = 2,
-+    tls_sig_ecdsa = 3
-+} TLSSignatureAlgorithm;
-+
- typedef struct {
-+    SECOidTag hashAlg;
-+    TLSSignatureAlgorithm sigAlg;
-+} SSL3SignatureAndHashAlgorithm;
-+
-+/* SSL3HashesIndividually contains a combination MD5/SHA1 hash, as used in TLS
-+ * prior to 1.2. */
-+typedef struct {
-     uint8 md5[16];
-     uint8 sha[20];
-+} SSL3HashesIndividually;
-+
-+/* SSL3Hashes contains an SSL hash value. The digest is contained in |u.raw|
-+ * which, if |hashAlg==SEC_OID_UNKNOWN| is also a SSL3HashesIndividually
-+ * struct. */
-+typedef struct {
-+    unsigned int len;
-+    SECOidTag hashAlg;
-+    union {
-+	PRUint8 raw[64];
-+	SSL3HashesIndividually s;
-+    } u;
- } SSL3Hashes;
--     
-+
- typedef struct {
-     union {
- 	SSL3Opaque anonymous;
-@@ -274,7 +314,7 @@
-     sender_server = 0x53525652
- } SSL3Sender;
- 
--typedef SSL3Hashes SSL3Finished;   
-+typedef SSL3HashesIndividually SSL3Finished;   
- 
- typedef struct {
-     SSL3Opaque verify_data[12];
-Index: net/third_party/nss/ssl/ssl3ecc.c
-===================================================================
---- net/third_party/nss/ssl/ssl3ecc.c	(revision 202696)
-+++ net/third_party/nss/ssl/ssl3ecc.c	(working copy)
-@@ -217,9 +223,10 @@
- 
- /* Caller must set hiLevel error code. */
- static SECStatus
--ssl3_ComputeECDHKeyHash(SECItem ec_params, SECItem server_ecpoint,
--			     SSL3Random *client_rand, SSL3Random *server_rand,
--			     SSL3Hashes *hashes, PRBool bypassPKCS11)
-+ssl3_ComputeECDHKeyHash(SECOidTag hashAlg,
-+			SECItem ec_params, SECItem server_ecpoint,
-+			SSL3Random *client_rand, SSL3Random *server_rand,
-+			SSL3Hashes *hashes, PRBool bypassPKCS11)
- {
-     PRUint8     * hashBuf;
-     PRUint8     * pBuf;
-@@ -255,11 +262,14 @@
-     	pBuf += server_ecpoint.len;
-     PORT_Assert((unsigned int)(pBuf - hashBuf) == bufLen);
- 
--    rv = ssl3_ComputeCommonKeyHash(hashBuf, bufLen, hashes, bypassPKCS11);
-+    rv = ssl3_ComputeCommonKeyHash(hashAlg, hashBuf, bufLen, hashes,
-+				   bypassPKCS11);
- 
-     PRINT_BUF(95, (NULL, "ECDHkey hash: ", hashBuf, bufLen));
--    PRINT_BUF(95, (NULL, "ECDHkey hash: MD5 result", hashes->md5, MD5_LENGTH));
--    PRINT_BUF(95, (NULL, "ECDHkey hash: SHA1 result", hashes->sha, SHA1_LENGTH));
-+    PRINT_BUF(95, (NULL, "ECDHkey hash: MD5 result",
-+	      hashes->u.s.md5, MD5_LENGTH));
-+    PRINT_BUF(95, (NULL, "ECDHkey hash: SHA1 result",
-+	      hashes->u.s.sha, SHA1_LENGTH));
- 
-     if (hashBuf != buf)
-     	PORT_Free(hashBuf);
-@@ -273,7 +283,7 @@
- {
-     PK11SymKey *	pms 		= NULL;
-     SECStatus           rv    		= SECFailure;
--    PRBool              isTLS;
-+    PRBool              isTLS, isTLS12;
-     CK_MECHANISM_TYPE	target;
-     SECKEYPublicKey	*pubKey = NULL;		/* Ephemeral ECDH key */
-     SECKEYPrivateKey	*privKey = NULL;	/* Ephemeral ECDH key */
-@@ -282,6 +292,7 @@
-     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
- 
-     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
- 
-     /* Generate ephemeral EC keypair */
-     if (svrPubKey->keyType != ecKey) {
-@@ -300,8 +311,13 @@
- 					pubKey->u.ec.publicValue.data,
- 					pubKey->u.ec.publicValue.len));
- 
--    if (isTLS) target = CKM_TLS_MASTER_KEY_DERIVE_DH;
--    else target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
-+    if (isTLS12) {
-+	target = CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256;
-+    } else if (isTLS) {
-+	target = CKM_TLS_MASTER_KEY_DERIVE_DH;
-+    } else {
-+	target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
-+    }
- 
-     /*  Determine the PMS */
-     pms = PK11_PubDeriveWithKDF(privKey, svrPubKey, PR_FALSE, NULL, NULL,
-@@ -365,7 +381,7 @@
-     SECStatus         rv;
-     SECKEYPublicKey   clntPubKey;
-     CK_MECHANISM_TYPE	target;
--    PRBool isTLS;
-+    PRBool isTLS, isTLS12;
- 
-     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-@@ -384,9 +400,15 @@
-     }
- 
-     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
- 
--    if (isTLS) target = CKM_TLS_MASTER_KEY_DERIVE_DH;
--    else target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
-+    if (isTLS12) {
-+	target = CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256;
-+    } else if (isTLS) {
-+	target = CKM_TLS_MASTER_KEY_DERIVE_DH;
-+    } else {
-+	target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
-+    }
- 
-     /*  Determine the PMS */
-     pms = PK11_PubDeriveWithKDF(srvrPrivKey, &clntPubKey, PR_FALSE, NULL, NULL,
-@@ -582,7 +604,7 @@
- {
-     PRArenaPool *    arena     = NULL;
-     SECKEYPublicKey *peerKey   = NULL;
--    PRBool           isTLS;
-+    PRBool           isTLS, isTLS12;
-     SECStatus        rv;
-     int              errCode   = SSL_ERROR_RX_MALFORMED_SERVER_KEY_EXCH;
-     SSL3AlertDescription desc  = illegal_parameter;
-@@ -592,8 +614,12 @@
-     SECItem          ec_params = {siBuffer, NULL, 0};
-     SECItem          ec_point  = {siBuffer, NULL, 0};
-     unsigned char    paramBuf[3]; /* only for curve_type == named_curve */
-+    SSL3SignatureAndHashAlgorithm sigAndHash;
- 
-+    sigAndHash.hashAlg = SEC_OID_UNKNOWN;
-+
-     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
- 
-     /* XXX This works only for named curves, revisit this when
-      * we support generic curves.
-@@ -625,6 +651,19 @@
- 	    goto alert_loser;
-     }
- 
-+    if (isTLS12) {
-+	rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-+						   &sigAndHash);
-+	if (rv != SECSuccess) {
-+	    goto loser;		/* malformed or unsupported. */
-+	}
-+	rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-+		&sigAndHash, ss->sec.peerCert);
-+	if (rv != SECSuccess) {
-+	    goto loser;
-+	}
-+    }
-+
-     rv = ssl3_ConsumeHandshakeVariable(ss, &signature, 2, &b, &length);
-     if (rv != SECSuccess) {
- 	goto loser;		/* malformed. */
-@@ -647,10 +686,10 @@
-     /*
-      *  check to make sure the hash is signed by right guy
-      */
--    rv = ssl3_ComputeECDHKeyHash(ec_params, ec_point,
--				      &ss->ssl3.hs.client_random,
--				      &ss->ssl3.hs.server_random, 
--				      &hashes, ss->opt.bypassPKCS11);
-+    rv = ssl3_ComputeECDHKeyHash(sigAndHash.hashAlg, ec_params, ec_point,
-+				 &ss->ssl3.hs.client_random,
-+				 &ss->ssl3.hs.server_random, 
-+				 &hashes, ss->opt.bypassPKCS11);
- 
-     if (rv != SECSuccess) {
- 	errCode =
-@@ -714,12 +753,14 @@
- }
- 
- SECStatus
--ssl3_SendECDHServerKeyExchange(sslSocket *ss)
-+ssl3_SendECDHServerKeyExchange(
-+    sslSocket *ss,
-+    const SSL3SignatureAndHashAlgorithm *sigAndHash)
- {
--const ssl3KEADef *     kea_def     = ss->ssl3.hs.kea_def;
-+    const ssl3KEADef * kea_def     = ss->ssl3.hs.kea_def;
-     SECStatus          rv          = SECFailure;
-     int                length;
--    PRBool             isTLS;
-+    PRBool             isTLS, isTLS12;
-     SECItem            signed_hash = {siBuffer, NULL, 0};
-     SSL3Hashes         hashes;
- 
-@@ -729,7 +770,6 @@
-     ECName             curve;
-     SSL3KEAType        certIndex;
- 
--
-     /* Generate ephemeral ECDH key pair and send the public key */
-     curve = ssl3_GetCurveNameForServerSocket(ss);
-     if (curve == ec_noName) {
-@@ -758,16 +798,19 @@
- 	goto loser;
-     }		
- 
--    rv = ssl3_ComputeECDHKeyHash(ec_params, ecdhePub->u.ec.publicValue,
--				      &ss->ssl3.hs.client_random,
--				      &ss->ssl3.hs.server_random,
--				      &hashes, ss->opt.bypassPKCS11);
-+    rv = ssl3_ComputeECDHKeyHash(sigAndHash->hashAlg,
-+				 ec_params,
-+				 ecdhePub->u.ec.publicValue,
-+				 &ss->ssl3.hs.client_random,
-+				 &ss->ssl3.hs.server_random,
-+				 &hashes, ss->opt.bypassPKCS11);
-     if (rv != SECSuccess) {
- 	ssl_MapLowLevelError(SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE);
- 	goto loser;
-     }
- 
-     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
- 
-     /* XXX SSLKEAType isn't really a good choice for 
-      * indexing certificates but that's all we have
-@@ -791,7 +834,7 @@
- 
-     length = ec_params.len + 
- 	     1 + ecdhePub->u.ec.publicValue.len + 
--	     2 + signed_hash.len;
-+	     (isTLS12 ? 2 : 0) + 2 + signed_hash.len;
- 
-     rv = ssl3_AppendHandshakeHeader(ss, server_key_exchange, length);
-     if (rv != SECSuccess) {
-@@ -809,6 +852,13 @@
- 	goto loser; 	/* err set by AppendHandshake. */
-     }
- 
-+    if (isTLS12) {
-+	rv = ssl3_AppendSignatureAndHashAlgorithm(ss, sigAndHash);
-+	if (rv != SECSuccess) {
-+	    goto loser; 	/* err set by AppendHandshake. */
-+	}
-+    }
-+
-     rv = ssl3_AppendHandshakeVariable(ss, signed_hash.data,
- 				      signed_hash.len, 2);
-     if (rv != SECSuccess) {
-Index: net/third_party/nss/ssl/ssl3ext.c
-===================================================================
---- net/third_party/nss/ssl/ssl3ext.c	(revision 202696)
-+++ net/third_party/nss/ssl/ssl3ext.c	(working copy)
-@@ -74,6 +74,10 @@
-                                                   SECItem *data);
- static PRInt32 ssl3_ClientSendStatusRequestXtn(sslSocket * ss, PRBool append,
-                                               PRUint32 maxBytes);
-+static PRInt32 ssl3_ClientSendSigAlgsXtn(sslSocket *ss, PRBool append,
-+                                         PRUint32 maxBytes);
-+static SECStatus ssl3_ServerHandleSigAlgsXtn(sslSocket *ss, PRUint16 ex_type,
-+                                             SECItem *data);
- 
- /*
-  * Write bytes.  Using this function means the SECItem structure
-@@ -236,6 +240,7 @@
-     { ssl_next_proto_nego_xtn,    &ssl3_ServerHandleNextProtoNegoXtn },
-     { ssl_use_srtp_xtn,           &ssl3_HandleUseSRTPXtn },
-     { ssl_cert_status_xtn,        &ssl3_ServerHandleStatusRequestXtn },
-+    { ssl_signature_algorithms_xtn, &ssl3_ServerHandleSigAlgsXtn },
-     { -1, NULL }
- };
- 
-@@ -276,7 +281,8 @@
-     { ssl_next_proto_nego_xtn,    &ssl3_ClientSendNextProtoNegoXtn },
-     { ssl_use_srtp_xtn,           &ssl3_SendUseSRTPXtn },
-     { ssl_channel_id_xtn,         &ssl3_ClientSendChannelIDXtn },
--    { ssl_cert_status_xtn,        &ssl3_ClientSendStatusRequestXtn }
-+    { ssl_cert_status_xtn,        &ssl3_ClientSendStatusRequestXtn },
-+    { ssl_signature_algorithms_xtn, &ssl3_ClientSendSigAlgsXtn }
-     /* any extra entries will appear as { 0, NULL }    */
- };
- 
-@@ -2039,3 +2045,134 @@
-     return ssl3_RegisterServerHelloExtensionSender(ss, ssl_use_srtp_xtn,
- 						   ssl3_SendUseSRTPXtn);
- }
-+
-+/* ssl3_ServerHandleSigAlgsXtn handles the signature_algorithms extension
-+ * from a client.
-+ * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+static SECStatus
-+ssl3_ServerHandleSigAlgsXtn(sslSocket * ss, PRUint16 ex_type, SECItem *data)
-+{
-+    SECStatus rv;
-+    SECItem algorithms;
-+    const unsigned char *b;
-+    unsigned int numAlgorithms, i;
-+
-+    /* Ignore this extension if we aren't doing TLS 1.2 or greater. */
-+    if (ss->version < SSL_LIBRARY_VERSION_TLS_1_2) {
-+	return SECSuccess;
-+    }
-+
-+    /* Keep track of negotiated extensions. */
-+    ss->xtnData.negotiated[ss->xtnData.numNegotiated++] = ex_type;
-+
-+    rv = ssl3_ConsumeHandshakeVariable(ss, &algorithms, 2, &data->data,
-+				       &data->len);
-+    if (rv != SECSuccess) {
-+	return SECFailure;
-+    }
-+    /* Trailing data or odd-length parameters is invalid. */
-+    if (data->len != 0 || (algorithms.len & 1) != 0) {
-+	PORT_SetError(SSL_ERROR_RX_MALFORMED_CLIENT_HELLO);
-+	return SECFailure;
-+    }
-+
-+    numAlgorithms = algorithms.len/2;
-+
-+    if (numAlgorithms == 0) {
-+	return SECSuccess;
-+    }
-+    /* We don't care to process excessive numbers of algorithms. */
-+    if (numAlgorithms > 512) {
-+	numAlgorithms = 512;
-+    }
-+
-+    ss->ssl3.hs.clientSigAndHash =
-+	    PORT_NewArray(SSL3SignatureAndHashAlgorithm, numAlgorithms);
-+    if (!ss->ssl3.hs.clientSigAndHash) {
-+	return SECFailure;
-+    }
-+    ss->ssl3.hs.numClientSigAndHash = 0;
-+
-+    b = algorithms.data;
-+    for (i = 0; i < numAlgorithms; i++) {
-+	unsigned char tls_hash = *(b++);
-+	unsigned char tls_sig = *(b++);
-+	SECOidTag hash = ssl3_TLSHashAlgorithmToOID(tls_hash);
-+
-+	if (hash == SEC_OID_UNKNOWN) {
-+	    /* We ignore formats that we don't understand. */
-+	    continue;
-+	}
-+	/* tls_sig support will be checked later in
-+	 * ssl3_PickSignatureHashAlgorithm. */
-+	ss->ssl3.hs.clientSigAndHash[i].hashAlg = hash;
-+	ss->ssl3.hs.clientSigAndHash[i].sigAlg = tls_sig;
-+	ss->ssl3.hs.numClientSigAndHash++;
-+    }
-+
-+    if (!ss->ssl3.hs.numClientSigAndHash) {
-+	/* We didn't understand any of the client's requested signature
-+	 * formats. We'll use the defaults. */
-+	PORT_Free(ss->ssl3.hs.clientSigAndHash);
-+	ss->ssl3.hs.clientSigAndHash = NULL;
-+    }
-+
-+    return SECSuccess;
-+}
-+
-+/* ssl3_ClientSendSigAlgsXtn sends the signature_algorithm extension for TLS
-+ * 1.2 ClientHellos. */
-+static PRInt32
-+ssl3_ClientSendSigAlgsXtn(sslSocket * ss, PRBool append, PRUint32 maxBytes)
-+{
-+    static const unsigned char signatureAlgorithms[] = {
-+	/* This block is the contents of our signature_algorithms extension, in
-+	 * wire format. See
-+	 * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+	tls_hash_sha256, tls_sig_rsa,
-+	tls_hash_sha384, tls_sig_rsa,
-+	tls_hash_sha1,   tls_sig_rsa,
-+#ifdef NSS_ENABLE_ECC
-+	tls_hash_sha256, tls_sig_ecdsa,
-+	tls_hash_sha384, tls_sig_ecdsa,
-+	tls_hash_sha1,   tls_sig_ecdsa,
-+#endif
-+	tls_hash_sha256, tls_sig_dsa,
-+	tls_hash_sha1,   tls_sig_dsa,
-+    };
-+    PRInt32 extension_length;
-+
-+    if (ss->version < SSL_LIBRARY_VERSION_TLS_1_2) {
-+	return 0;
-+    }
-+
-+    extension_length =
-+	2 /* extension type */ +
-+	2 /* extension length */ +
-+	2 /* supported_signature_algorithms length */ +
-+	sizeof(signatureAlgorithms);
-+
-+    if (append && maxBytes >= extension_length) {
-+	SECStatus rv;
-+	rv = ssl3_AppendHandshakeNumber(ss, ssl_signature_algorithms_xtn, 2);
-+	if (rv != SECSuccess)
-+	    goto loser;
-+	rv = ssl3_AppendHandshakeNumber(ss, extension_length - 4, 2);
-+	if (rv != SECSuccess)
-+	    goto loser;
-+	rv = ssl3_AppendHandshakeVariable(ss, signatureAlgorithms,
-+					  sizeof(signatureAlgorithms), 2);
-+	if (rv != SECSuccess)
-+	    goto loser;
-+	ss->xtnData.advertised[ss->xtnData.numAdvertised++] =
-+		ssl_signature_algorithms_xtn;
-+    } else if (maxBytes < extension_length) {
-+	PORT_Assert(0);
-+	return 0;
-+    }
-+
-+    return extension_length;
-+
-+loser:
-+    return -1;
-+}
-Index: net/third_party/nss/ssl/sslsock.c
-===================================================================
---- net/third_party/nss/ssl/sslsock.c	(revision 202696)
-+++ net/third_party/nss/ssl/sslsock.c	(working copy)
-@@ -782,6 +789,17 @@
- 	    rv = SECFailure;
- 	} else {
-             if (PR_FALSE != on) {
-+		/* TLS 1.2 isn't supported in bypass mode. */
-+		if (ss->vrange.min >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+		    /* If the user requested a minimum version of TLS 1.2 then
-+		     * we don't silently downgrade. */
-+		    PORT_SetError(SSL_ERROR_INVALID_VERSION_RANGE);
-+		    rv = SECFailure;
-+		    break;
-+		}
-+		if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+		    ss->vrange.max = SSL_LIBRARY_VERSION_TLS_1_1;
-+		}
-                 if (PR_SUCCESS == SSL_BypassSetup() ) {
- #ifdef NO_PKCS11_BYPASS
-                     ss->opt.bypassPKCS11   = PR_FALSE;
-Index: net/third_party/nss/ssl/ssl3con.c
-===================================================================
---- net/third_party/nss/ssl/ssl3con.c	(revision 202696)
-+++ net/third_party/nss/ssl/ssl3con.c	(working copy)
-@@ -15,6 +15,7 @@
- #include "keyhi.h"
- #include "secder.h"
- #include "secitem.h"
-+#include "sechash.h"
- 
- #include "sslimpl.h"
- #include "sslproto.h"
-@@ -64,6 +74,7 @@
-                                              const unsigned char *b,
-                                              unsigned int l);
- static SECStatus ssl3_FlushHandshakeMessages(sslSocket *ss, PRInt32 flags);
-+static int       ssl3_OIDToTLSHashAlgorithm(SECOidTag oid);
- 
- static SECStatus Null_Cipher(void *ctx, unsigned char *output, int *outputLen,
- 			     int maxOutputLen, const unsigned char *input,
-@@ -811,32 +822,36 @@
-     SECItem   hashItem;
- 
-     buf->data    = NULL;
--    signatureLen = PK11_SignatureLen(key);
--    if (signatureLen <= 0) {
--	PORT_SetError(SEC_ERROR_INVALID_KEY);
--        goto done;
--    }
- 
--    buf->len  = (unsigned)signatureLen;
--    buf->data = (unsigned char *)PORT_Alloc(signatureLen);
--    if (!buf->data)
--        goto done;	/* error code was set. */
--
-     switch (key->keyType) {
-     case rsaKey:
--    	hashItem.data = hash->md5;
--    	hashItem.len = sizeof(SSL3Hashes);
-+	hashItem.data = hash->u.raw;
-+	hashItem.len = hash->len;
- 	break;
-     case dsaKey:
- 	doDerEncode = isTLS;
--	hashItem.data = hash->sha;
--	hashItem.len = sizeof(hash->sha);
-+	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-+	 * In that case, we use just the SHA1 part. */
-+	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+	    hashItem.data = hash->u.s.sha;
-+	    hashItem.len = sizeof(hash->u.s.sha);
-+	} else {
-+	    hashItem.data = hash->u.raw;
-+	    hashItem.len = hash->len;
-+	}
- 	break;
- #ifdef NSS_ENABLE_ECC
-     case ecKey:
- 	doDerEncode = PR_TRUE;
--	hashItem.data = hash->sha;
--	hashItem.len = sizeof(hash->sha);
-+	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-+	 * In that case, we use just the SHA1 part. */
-+	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+	    hashItem.data = hash->u.s.sha;
-+	    hashItem.len = sizeof(hash->u.s.sha);
-+	} else {
-+	    hashItem.data = hash->u.raw;
-+	    hashItem.len = hash->len;
-+	}
- 	break;
- #endif /* NSS_ENABLE_ECC */
-     default:
-@@ -845,7 +860,22 @@
-     }
-     PRINT_BUF(60, (NULL, "hash(es) to be signed", hashItem.data, hashItem.len));
- 
--    rv = PK11_Sign(key, buf, &hashItem);
-+    if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+	signatureLen = PK11_SignatureLen(key);
-+	if (signatureLen <= 0) {
-+	    PORT_SetError(SEC_ERROR_INVALID_KEY);
-+	    goto done;
-+	}
-+
-+	buf->len  = (unsigned)signatureLen;
-+	buf->data = (unsigned char *)PORT_Alloc(signatureLen);
-+	if (!buf->data)
-+	    goto done;  /* error code was set. */
-+
-+	rv = PK11_Sign(key, buf, &hashItem);
-+    } else {
-+	rv = SGN_Digest(key, hash->hashAlg, buf, &hashItem);
-+    }
-     if (rv != SECSuccess) {
- 	ssl_MapLowLevelError(SSL_ERROR_SIGN_HASHES_FAILURE);
-     } else if (doDerEncode) {
-@@ -879,9 +909,8 @@
-     SECItem *         signature	= NULL;
-     SECStatus         rv;
-     SECItem           hashItem;
--#ifdef NSS_ENABLE_ECC
--    unsigned int      len;
--#endif /* NSS_ENABLE_ECC */
-+    SECOidTag         encAlg;
-+    SECOidTag         hashAlg;
- 
- 
-     PRINT_BUF(60, (NULL, "check signed hashes",
-@@ -893,14 +922,24 @@
-     	return SECFailure;
-     }
- 
-+    hashAlg = hash->hashAlg;
-     switch (key->keyType) {
-     case rsaKey:
--    	hashItem.data = hash->md5;
--    	hashItem.len = sizeof(SSL3Hashes);
-+	encAlg = SEC_OID_PKCS1_RSA_ENCRYPTION;
-+	hashItem.data = hash->u.raw;
-+	hashItem.len = hash->len;
- 	break;
-     case dsaKey:
--	hashItem.data = hash->sha;
--	hashItem.len = sizeof(hash->sha);
-+	encAlg = SEC_OID_ANSIX9_DSA_SIGNATURE;
-+	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-+	 * In that case, we use just the SHA1 part. */
-+	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+	    hashItem.data = hash->u.s.sha;
-+	    hashItem.len = sizeof(hash->u.s.sha);
-+	} else {
-+	    hashItem.data = hash->u.raw;
-+	    hashItem.len = hash->len;
-+	}
- 	/* Allow DER encoded DSA signatures in SSL 3.0 */
- 	if (isTLS || buf->len != SECKEY_SignatureLen(key)) {
- 	    signature = DSAU_DecodeDerSig(buf);
-@@ -914,25 +953,21 @@
- 
- #ifdef NSS_ENABLE_ECC
-     case ecKey:
--	hashItem.data = hash->sha;
--	hashItem.len = sizeof(hash->sha);
--	/*
--	 * ECDSA signatures always encode the integers r and s 
--	 * using ASN (unlike DSA where ASN encoding is used
--	 * with TLS but not with SSL3)
-+	encAlg = SEC_OID_ANSIX962_EC_PUBLIC_KEY;
-+	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-+	 * In that case, we use just the SHA1 part.
-+	 * ECDSA signatures always encode the integers r and s using ASN.1
-+	 * (unlike DSA where ASN.1 encoding is used with TLS but not with
-+	 * SSL3). So we can use VFY_VerifyDigestDirect for ECDSA.
- 	 */
--	len = SECKEY_SignatureLen(key);
--	if (len == 0) {
--	    SECKEY_DestroyPublicKey(key);
--	    PORT_SetError(SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE);
--	    return SECFailure;
-+	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+	    hashAlg = SEC_OID_SHA1;
-+	    hashItem.data = hash->u.s.sha;
-+	    hashItem.len = sizeof(hash->u.s.sha);
-+	} else {
-+	    hashItem.data = hash->u.raw;
-+	    hashItem.len = hash->len;
- 	}
--	signature = DSAU_DecodeDerSigToLen(buf, len);
--	if (!signature) {
--	    PORT_SetError(SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE);
--	    return SECFailure;
--	}
--	buf = signature;
- 	break;
- #endif /* NSS_ENABLE_ECC */
- 
-@@ -945,7 +980,17 @@
-     PRINT_BUF(60, (NULL, "hash(es) to be verified",
-                   hashItem.data, hashItem.len));
- 
--    rv = PK11_Verify(key, buf, &hashItem, pwArg);
-+    if (hashAlg == SEC_OID_UNKNOWN || key->keyType == dsaKey) {
-+	/* VFY_VerifyDigestDirect requires DSA signatures to be DER-encoded.
-+	 * DSA signatures are DER-encoded in TLS but not in SSL3 and the code
-+	 * above always removes the DER encoding of DSA signatures when
-+	 * present. Thus DSA signatures are always verified with PK11_Verify.
-+	 */
-+	rv = PK11_Verify(key, buf, &hashItem, pwArg);
-+    } else {
-+	rv = VFY_VerifyDigestDirect(&hashItem, key, buf, encAlg, hashAlg,
-+				    pwArg);
-+    }
-     SECKEY_DestroyPublicKey(key);
-     if (signature) {
-     	SECITEM_FreeItem(signature, PR_TRUE);
-@@ -961,33 +1006,69 @@
- /* Called from ssl3_ComputeExportRSAKeyHash
-  *             ssl3_ComputeDHKeyHash
-  * which are called from ssl3_HandleServerKeyExchange. 
-+ *
-+ * hashAlg: either the OID for a hash algorithm or SEC_OID_UNKNOWN to specify
-+ * the pre-1.2, MD5/SHA1 combination hash.
-  */
- SECStatus
--ssl3_ComputeCommonKeyHash(PRUint8 * hashBuf, unsigned int bufLen,
--			     SSL3Hashes *hashes, PRBool bypassPKCS11)
-+ssl3_ComputeCommonKeyHash(SECOidTag hashAlg,
-+			  PRUint8 * hashBuf, unsigned int bufLen,
-+			  SSL3Hashes *hashes, PRBool bypassPKCS11)
- {
-     SECStatus     rv 		= SECSuccess;
- 
- #ifndef NO_PKCS11_BYPASS
-     if (bypassPKCS11) {
--	MD5_HashBuf (hashes->md5, hashBuf, bufLen);
--	SHA1_HashBuf(hashes->sha, hashBuf, bufLen);
-+	if (hashAlg == SEC_OID_UNKNOWN) {
-+	    MD5_HashBuf (hashes->u.s.md5, hashBuf, bufLen);
-+	    SHA1_HashBuf(hashes->u.s.sha, hashBuf, bufLen);
-+	    hashes->len = MD5_LENGTH + SHA1_LENGTH;
-+	} else if (hashAlg == SEC_OID_SHA1) {
-+	    SHA1_HashBuf(hashes->u.raw, hashBuf, bufLen);
-+	    hashes->len = SHA1_LENGTH;
-+	} else if (hashAlg == SEC_OID_SHA256) {
-+	    SHA256_HashBuf(hashes->u.raw, hashBuf, bufLen);
-+	    hashes->len = SHA256_LENGTH;
-+	} else if (hashAlg == SEC_OID_SHA384) {
-+	    SHA384_HashBuf(hashes->u.raw, hashBuf, bufLen);
-+	    hashes->len = SHA384_LENGTH;
-+	} else {
-+	    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+	    return SECFailure;
-+	}
-     } else 
- #endif
-     {
--	rv = PK11_HashBuf(SEC_OID_MD5, hashes->md5, hashBuf, bufLen);
--	if (rv != SECSuccess) {
--	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
--	    rv = SECFailure;
--	    goto done;
--	}
-+	if (hashAlg == SEC_OID_UNKNOWN) {
-+	    rv = PK11_HashBuf(SEC_OID_MD5, hashes->u.s.md5, hashBuf, bufLen);
-+	    if (rv != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-+		rv = SECFailure;
-+		goto done;
-+	    }
- 
--	rv = PK11_HashBuf(SEC_OID_SHA1, hashes->sha, hashBuf, bufLen);
--	if (rv != SECSuccess) {
--	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
--	    rv = SECFailure;
-+	    rv = PK11_HashBuf(SEC_OID_SHA1, hashes->u.s.sha, hashBuf, bufLen);
-+	    if (rv != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-+		rv = SECFailure;
-+	    }
-+	    hashes->len = MD5_LENGTH + SHA1_LENGTH;
-+	} else {
-+	    hashes->len = HASH_ResultLenByOidTag(hashAlg);
-+	    if (hashes->len > sizeof(hashes->u.raw)) {
-+		ssl_MapLowLevelError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+		rv = SECFailure;
-+		goto done;
-+	    }
-+	    rv = PK11_HashBuf(hashAlg, hashes->u.raw, hashBuf, bufLen);
-+	    if (rv != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+		rv = SECFailure;
-+	    }
- 	}
-     }
-+    hashes->hashAlg = hashAlg;
-+
- done:
-     return rv;
- }
-@@ -997,7 +1078,8 @@
- **             ssl3_HandleServerKeyExchange.
- */
- static SECStatus
--ssl3_ComputeExportRSAKeyHash(SECItem modulus, SECItem publicExponent,
-+ssl3_ComputeExportRSAKeyHash(SECOidTag hashAlg,
-+			     SECItem modulus, SECItem publicExponent,
- 			     SSL3Random *client_rand, SSL3Random *server_rand,
- 			     SSL3Hashes *hashes, PRBool bypassPKCS11)
- {
-@@ -1033,11 +1115,19 @@
-     	pBuf += publicExponent.len;
-     PORT_Assert((unsigned int)(pBuf - hashBuf) == bufLen);
- 
--    rv = ssl3_ComputeCommonKeyHash(hashBuf, bufLen, hashes, bypassPKCS11);
-+    rv = ssl3_ComputeCommonKeyHash(hashAlg, hashBuf, bufLen, hashes,
-+				   bypassPKCS11);
- 
-     PRINT_BUF(95, (NULL, "RSAkey hash: ", hashBuf, bufLen));
--    PRINT_BUF(95, (NULL, "RSAkey hash: MD5 result", hashes->md5, MD5_LENGTH));
--    PRINT_BUF(95, (NULL, "RSAkey hash: SHA1 result", hashes->sha, SHA1_LENGTH));
-+    if (hashAlg == SEC_OID_UNKNOWN) {
-+	PRINT_BUF(95, (NULL, "RSAkey hash: MD5 result",
-+		  hashes->u.s.md5, MD5_LENGTH));
-+	PRINT_BUF(95, (NULL, "RSAkey hash: SHA1 result",
-+		  hashes->u.s.sha, SHA1_LENGTH));
-+    } else {
-+	PRINT_BUF(95, (NULL, "RSAkey hash: result",
-+		  hashes->u.raw, hashes->len));
-+    }
- 
-     if (hashBuf != buf && hashBuf != NULL)
-     	PORT_Free(hashBuf);
-@@ -1047,9 +1137,10 @@
- /* Caller must set hiLevel error code. */
- /* Called from ssl3_HandleServerKeyExchange. */
- static SECStatus
--ssl3_ComputeDHKeyHash(SECItem dh_p, SECItem dh_g, SECItem dh_Ys,
--			     SSL3Random *client_rand, SSL3Random *server_rand,
--			     SSL3Hashes *hashes, PRBool bypassPKCS11)
-+ssl3_ComputeDHKeyHash(SECOidTag hashAlg,
-+		      SECItem dh_p, SECItem dh_g, SECItem dh_Ys,
-+		      SSL3Random *client_rand, SSL3Random *server_rand,
-+		      SSL3Hashes *hashes, PRBool bypassPKCS11)
- {
-     PRUint8     * hashBuf;
-     PRUint8     * pBuf;
-@@ -1088,11 +1179,19 @@
-     	pBuf += dh_Ys.len;
-     PORT_Assert((unsigned int)(pBuf - hashBuf) == bufLen);
- 
--    rv = ssl3_ComputeCommonKeyHash(hashBuf, bufLen, hashes, bypassPKCS11);
-+    rv = ssl3_ComputeCommonKeyHash(hashAlg, hashBuf, bufLen, hashes,
-+				   bypassPKCS11);
- 
-     PRINT_BUF(95, (NULL, "DHkey hash: ", hashBuf, bufLen));
--    PRINT_BUF(95, (NULL, "DHkey hash: MD5 result", hashes->md5, MD5_LENGTH));
--    PRINT_BUF(95, (NULL, "DHkey hash: SHA1 result", hashes->sha, SHA1_LENGTH));
-+    if (hashAlg == SEC_OID_UNKNOWN) {
-+	PRINT_BUF(95, (NULL, "DHkey hash: MD5 result",
-+		  hashes->u.s.md5, MD5_LENGTH));
-+	PRINT_BUF(95, (NULL, "DHkey hash: SHA1 result",
-+		  hashes->u.s.sha, SHA1_LENGTH));
-+    } else {
-+	PRINT_BUF(95, (NULL, "DHkey hash: result",
-+		  hashes->u.raw, hashes->len));
-+    }
- 
-     if (hashBuf != buf && hashBuf != NULL)
-     	PORT_Free(hashBuf);
-@@ -3190,6 +3289,8 @@
-     unsigned char *   sr     = (unsigned char *)&ss->ssl3.hs.server_random;
-     PRBool            isTLS  = (PRBool)(kea_def->tls_keygen ||
-                                 (pwSpec->version > SSL_LIBRARY_VERSION_3_0));
-+    PRBool            isTLS12=
-+	    (PRBool)(isTLS && pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-     /* 
-      * Whenever isDH is true, we need to use CKM_TLS_MASTER_KEY_DERIVE_DH
-      * which, unlike CKM_TLS_MASTER_KEY_DERIVE, converts arbitrary size
-@@ -3208,7 +3309,12 @@
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSpecWriteLock(ss));
-     PORT_Assert(ss->ssl3.prSpec == ss->ssl3.pwSpec);
--    if (isTLS) {
-+    if (isTLS12) {
-+	if(isDH) master_derive = CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256;
-+	else master_derive = CKM_NSS_TLS_MASTER_KEY_DERIVE_SHA256;
-+	key_derive    = CKM_NSS_TLS_KEY_AND_MAC_DERIVE_SHA256;
-+	keyFlags      = CKF_SIGN | CKF_VERIFY;
-+    } else if (isTLS) {
- 	if(isDH) master_derive = CKM_TLS_MASTER_KEY_DERIVE_DH;
- 	else master_derive = CKM_TLS_MASTER_KEY_DERIVE;
- 	key_derive    = CKM_TLS_KEY_AND_MAC_DERIVE;
-@@ -3366,6 +3472,8 @@
-     unsigned char *   sr     = (unsigned char *)&ss->ssl3.hs.server_random;
-     PRBool            isTLS  = (PRBool)(kea_def->tls_keygen ||
-                                 (pwSpec->version > SSL_LIBRARY_VERSION_3_0));
-+    PRBool            isTLS12=
-+	    (PRBool)(isTLS && pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-     /* following variables used in PKCS11 path */
-     const ssl3BulkCipherDef *cipher_def = pwSpec->cipher_def;
-     PK11SlotInfo *         slot   = NULL;
-@@ -3423,7 +3531,9 @@
-     params.data    = (unsigned char *)&key_material_params;
-     params.len     = sizeof(key_material_params);
- 
--    if (isTLS) {
-+    if (isTLS12) {
-+	key_derive    = CKM_NSS_TLS_KEY_AND_MAC_DERIVE_SHA256;
-+    } else if (isTLS) {
- 	key_derive    = CKM_TLS_KEY_AND_MAC_DERIVE;
-     } else {
- 	key_derive    = CKM_SSL3_KEY_AND_MAC_DERIVE;
-@@ -3480,19 +3590,63 @@
-     return SECFailure;
- }
- 
-+/* ssl3_InitTLS12HandshakeHash creates a handshake hash context for TLS 1.2,
-+ * if needed, and hashes in any buffered messages in ss->ssl3.hs.messages. */
-+static SECStatus
-+ssl3_InitTLS12HandshakeHash(sslSocket *ss)
-+{
-+    if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_2 &&
-+	ss->ssl3.hs.tls12_handshake_hash == NULL) {
-+	/* If we ever support ciphersuites where the PRF hash isn't SHA-256
-+	 * then this will need to be updated. */
-+	ss->ssl3.hs.tls12_handshake_hash =
-+	    PK11_CreateDigestContext(SEC_OID_SHA256);
-+	if (!ss->ssl3.hs.tls12_handshake_hash ||
-+	    PK11_DigestBegin(ss->ssl3.hs.tls12_handshake_hash) != SECSuccess) {
-+	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+	    return SECFailure;
-+	}
-+    }
-+
-+    if (ss->ssl3.hs.tls12_handshake_hash && ss->ssl3.hs.messages.len > 0) {
-+	if (PK11_DigestOp(ss->ssl3.hs.tls12_handshake_hash,
-+			  ss->ssl3.hs.messages.buf,
-+			  ss->ssl3.hs.messages.len) != SECSuccess) {
-+	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+	    return SECFailure;
-+	}
-+    }
-+
-+    if (ss->ssl3.hs.messages.buf && !ss->opt.bypassPKCS11) {
-+	PORT_Free(ss->ssl3.hs.messages.buf);
-+	ss->ssl3.hs.messages.buf = NULL;
-+	ss->ssl3.hs.messages.len = 0;
-+	ss->ssl3.hs.messages.space = 0;
-+    }
-+
-+    return SECSuccess;
-+}
-+
- static SECStatus 
- ssl3_RestartHandshakeHashes(sslSocket *ss)
- {
-     SECStatus rv = SECSuccess;
- 
-+    ss->ssl3.hs.messages.len = 0;
- #ifndef NO_PKCS11_BYPASS
-     if (ss->opt.bypassPKCS11) {
--	ss->ssl3.hs.messages.len = 0;
- 	MD5_Begin((MD5Context *)ss->ssl3.hs.md5_cx);
- 	SHA1_Begin((SHA1Context *)ss->ssl3.hs.sha_cx);
-     } else 
- #endif
-     {
-+	if (ss->ssl3.hs.tls12_handshake_hash) {
-+	    rv = PK11_DigestBegin(ss->ssl3.hs.tls12_handshake_hash);
-+	    if (rv != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+		return rv;
-+	    }
-+	}
- 	rv = PK11_DigestBegin(ss->ssl3.hs.md5);
- 	if (rv != SECSuccess) {
- 	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-@@ -3519,25 +3673,21 @@
-      * that the master secret will wind up in ...
-      */
-     SSL_TRC(30,("%d: SSL3[%d]: start handshake hashes", SSL_GETPID(), ss->fd));
--#ifndef NO_PKCS11_BYPASS
--    if (ss->opt.bypassPKCS11) {
--	PORT_Assert(!ss->ssl3.hs.messages.buf && !ss->ssl3.hs.messages.space);
--	ss->ssl3.hs.messages.buf = NULL;
--	ss->ssl3.hs.messages.space = 0;
--    } else 
--#endif
--    {
--	ss->ssl3.hs.md5 = md5 = PK11_CreateDigestContext(SEC_OID_MD5);
--	ss->ssl3.hs.sha = sha = PK11_CreateDigestContext(SEC_OID_SHA1);
--	if (md5 == NULL) {
--	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
--	    goto loser;
--	}
--	if (sha == NULL) {
--	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
--	    goto loser;
--	}
-+    PORT_Assert(!ss->ssl3.hs.messages.buf && !ss->ssl3.hs.messages.space);
-+    ss->ssl3.hs.messages.buf = NULL;
-+    ss->ssl3.hs.messages.space = 0;
-+
-+    ss->ssl3.hs.md5 = md5 = PK11_CreateDigestContext(SEC_OID_MD5);
-+    ss->ssl3.hs.sha = sha = PK11_CreateDigestContext(SEC_OID_SHA1);
-+    ss->ssl3.hs.tls12_handshake_hash = NULL;
-+    if (md5 == NULL) {
-+	ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-+	goto loser;
-     }
-+    if (sha == NULL) {
-+	ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-+	goto loser;
-+    }
-     if (SECSuccess == ssl3_RestartHandshakeHashes(ss)) {
- 	return SECSuccess;
-     }
-@@ -3574,6 +3724,17 @@
- 
-     PRINT_BUF(90, (NULL, "MD5 & SHA handshake hash input:", b, l));
- 
-+    if ((ss->version == 0 || ss->version >= SSL_LIBRARY_VERSION_TLS_1_2) &&
-+	!ss->opt.bypassPKCS11 &&
-+	ss->ssl3.hs.tls12_handshake_hash == NULL) {
-+	/* For TLS 1.2 connections we need to buffer the handshake messages
-+	 * until we have established which PRF hash function to use. */
-+	rv = sslBuffer_Append(&ss->ssl3.hs.messages, b, l);
-+	if (rv != SECSuccess) {
-+	    return rv;
-+	}
-+    }
-+
- #ifndef NO_PKCS11_BYPASS
-     if (ss->opt.bypassPKCS11) {
- 	MD5_Update((MD5Context *)ss->ssl3.hs.md5_cx, b, l);
-@@ -3584,16 +3745,24 @@
- 	return rv;
-     }
- #endif
--    rv = PK11_DigestOp(ss->ssl3.hs.md5, b, l);
--    if (rv != SECSuccess) {
--	ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
--	return rv;
-+    if (ss->ssl3.hs.tls12_handshake_hash) {
-+	rv = PK11_DigestOp(ss->ssl3.hs.tls12_handshake_hash, b, l);
-+	if (rv != SECSuccess) {
-+	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+	    return rv;
-+	}
-+    } else {
-+	rv = PK11_DigestOp(ss->ssl3.hs.md5, b, l);
-+	if (rv != SECSuccess) {
-+	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-+	    return rv;
-+	}
-+	rv = PK11_DigestOp(ss->ssl3.hs.sha, b, l);
-+	if (rv != SECSuccess) {
-+	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-+	    return rv;
-+	}
-     }
--    rv = PK11_DigestOp(ss->ssl3.hs.sha, b, l);
--    if (rv != SECSuccess) {
--	ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
--	return rv;
--    }
-     return rv;
- }
- 
-@@ -3744,6 +3913,25 @@
-     return rv;		/* error code set by AppendHandshake, if applicable. */
- }
- 
-+/* ssl3_AppendSignatureAndHashAlgorithm appends the serialisation of
-+ * |sigAndHash| to the current handshake message. */
-+SECStatus
-+ssl3_AppendSignatureAndHashAlgorithm(
-+	sslSocket *ss, const SSL3SignatureAndHashAlgorithm* sigAndHash)
-+{
-+    unsigned char serialized[2];
-+
-+    serialized[0] = ssl3_OIDToTLSHashAlgorithm(sigAndHash->hashAlg);
-+    if (serialized[0] == 0) {
-+	PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+	return SECFailure;
-+    }
-+
-+    serialized[1] = sigAndHash->sigAlg;
-+
-+    return ssl3_AppendHandshake(ss, serialized, sizeof(serialized));
-+}
-+
- /**************************************************************************
-  * Consume Handshake functions.
-  *
-@@ -3850,6 +4038,147 @@
-     return SECSuccess;
- }
- 
-+/* tlsHashOIDMap contains the mapping between TLS hash identifiers and the
-+ * SECOidTag used internally by NSS. */
-+static const struct {
-+    int tlsHash;
-+    SECOidTag oid;
-+} tlsHashOIDMap[] = {
-+    { tls_hash_md5, SEC_OID_MD5 },
-+    { tls_hash_sha1, SEC_OID_SHA1 },
-+    { tls_hash_sha224, SEC_OID_SHA224 },
-+    { tls_hash_sha256, SEC_OID_SHA256 },
-+    { tls_hash_sha384, SEC_OID_SHA384 },
-+    { tls_hash_sha512, SEC_OID_SHA512 }
-+};
-+
-+/* ssl3_TLSHashAlgorithmToOID converts a TLS hash identifier into an OID value.
-+ * If the hash is not recognised, SEC_OID_UNKNOWN is returned.
-+ *
-+ * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+SECOidTag
-+ssl3_TLSHashAlgorithmToOID(int hashFunc)
-+{
-+    unsigned int i;
-+
-+    for (i = 0; i < PR_ARRAY_SIZE(tlsHashOIDMap); i++) {
-+	if (hashFunc == tlsHashOIDMap[i].tlsHash) {
-+	    return tlsHashOIDMap[i].oid;
-+	}
-+    }
-+    return SEC_OID_UNKNOWN;
-+}
-+
-+/* ssl3_OIDToTLSHashAlgorithm converts an OID to a TLS hash algorithm
-+ * identifier. If the hash is not recognised, zero is returned.
-+ *
-+ * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+static int
-+ssl3_OIDToTLSHashAlgorithm(SECOidTag oid)
-+{
-+    unsigned int i;
-+
-+    for (i = 0; i < PR_ARRAY_SIZE(tlsHashOIDMap); i++) {
-+	if (oid == tlsHashOIDMap[i].oid) {
-+	    return tlsHashOIDMap[i].tlsHash;
-+	}
-+    }
-+    return 0;
-+}
-+
-+/* ssl3_TLSSignatureAlgorithmForKeyType returns the TLS 1.2 signature algorithm
-+ * identifier for a given KeyType. */
-+static SECStatus
-+ssl3_TLSSignatureAlgorithmForKeyType(KeyType keyType,
-+				     TLSSignatureAlgorithm *out)
-+{
-+    switch (keyType) {
-+    case rsaKey:
-+	*out = tls_sig_rsa;
-+	return SECSuccess;
-+    case dsaKey:
-+	*out = tls_sig_dsa;
-+	return SECSuccess;
-+    case ecKey:
-+	*out = tls_sig_ecdsa;
-+	return SECSuccess;
-+    default:
-+	PORT_SetError(SEC_ERROR_INVALID_KEY);
-+	return SECFailure;
-+    }
-+}
-+
-+/* ssl3_TLSSignatureAlgorithmForCertificate returns the TLS 1.2 signature
-+ * algorithm identifier for the given certificate. */
-+static SECStatus
-+ssl3_TLSSignatureAlgorithmForCertificate(CERTCertificate *cert,
-+					 TLSSignatureAlgorithm *out)
-+{
-+    SECKEYPublicKey *key;
-+    KeyType keyType;
-+
-+    key = CERT_ExtractPublicKey(cert);
-+    if (key == NULL) {
-+	ssl_MapLowLevelError(SSL_ERROR_EXTRACT_PUBLIC_KEY_FAILURE);
-+    	return SECFailure;
-+    }
-+
-+    keyType = key->keyType;
-+    SECKEY_DestroyPublicKey(key);
-+    return ssl3_TLSSignatureAlgorithmForKeyType(keyType, out);
-+}
-+
-+/* ssl3_CheckSignatureAndHashAlgorithmConsistency checks that the signature
-+ * algorithm identifier in |sigAndHash| is consistent with the public key in
-+ * |cert|. If so, SECSuccess is returned. Otherwise, PORT_SetError is called
-+ * and SECFailure is returned. */
-+SECStatus
-+ssl3_CheckSignatureAndHashAlgorithmConsistency(
-+	const SSL3SignatureAndHashAlgorithm *sigAndHash, CERTCertificate* cert)
-+{
-+    SECStatus rv;
-+    TLSSignatureAlgorithm sigAlg;
-+
-+    rv = ssl3_TLSSignatureAlgorithmForCertificate(cert, &sigAlg);
-+    if (rv != SECSuccess) {
-+	return rv;
-+    }
-+    if (sigAlg != sigAndHash->sigAlg) {
-+	PORT_SetError(SSL_ERROR_INCORRECT_SIGNATURE_ALGORITHM);
-+	return SECFailure;
-+    }
-+    return SECSuccess;
-+}
-+
-+/* ssl3_ConsumeSignatureAndHashAlgorithm reads a SignatureAndHashAlgorithm
-+ * structure from |b| and puts the resulting value into |out|. |b| and |length|
-+ * are updated accordingly.
-+ *
-+ * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+SECStatus
-+ssl3_ConsumeSignatureAndHashAlgorithm(sslSocket *ss,
-+				      SSL3Opaque **b,
-+				      PRUint32 *length,
-+				      SSL3SignatureAndHashAlgorithm *out)
-+{
-+    unsigned char bytes[2];
-+    SECStatus rv;
-+
-+    rv = ssl3_ConsumeHandshake(ss, bytes, sizeof(bytes), b, length);
-+    if (rv != SECSuccess) {
-+	return rv;
-+    }
-+
-+    out->hashAlg = ssl3_TLSHashAlgorithmToOID(bytes[0]);
-+    if (out->hashAlg == SEC_OID_UNKNOWN) {
-+	PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+	return SECFailure;
-+    }
-+
-+    out->sigAlg = bytes[1];
-+    return SECSuccess;
-+}
-+
- /**************************************************************************
-  * end of Consume Handshake functions.
-  **************************************************************************/
-@@ -3876,6 +4205,7 @@
-     SSL3Opaque    sha_inner[MAX_MAC_LENGTH];
- 
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-+    hashes->hashAlg = SEC_OID_UNKNOWN;
- 
- #ifndef NO_PKCS11_BYPASS
-     if (ss->opt.bypassPKCS11) {
-@@ -3939,9 +4269,9 @@
- 	    MD5_Update(md5cx, mac_pad_2, mac_defs[mac_md5].pad_size);
- 	    MD5_Update(md5cx, md5_inner, MD5_LENGTH);
- 	}
--	MD5_End(md5cx, hashes->md5, &outLength, MD5_LENGTH);
-+	MD5_End(md5cx, hashes->u.s.md5, &outLength, MD5_LENGTH);
- 
--	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->md5, MD5_LENGTH));
-+	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->u.s.md5, MD5_LENGTH));
- 
- 	if (!isTLS) {
- 	    PRINT_BUF(95, (NULL, "SHA outer: MAC Pad 2", mac_pad_2, 
-@@ -3953,16 +4283,58 @@
- 	    SHA1_Update(shacx, mac_pad_2, mac_defs[mac_sha].pad_size);
- 	    SHA1_Update(shacx, sha_inner, SHA1_LENGTH);
- 	}
--	SHA1_End(shacx, hashes->sha, &outLength, SHA1_LENGTH);
-+	SHA1_End(shacx, hashes->u.s.sha, &outLength, SHA1_LENGTH);
- 
--	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->sha, SHA1_LENGTH));
-+	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->u.s.sha, SHA1_LENGTH));
- 
-+	hashes->len = MD5_LENGTH + SHA1_LENGTH;
- 	rv = SECSuccess;
- #undef md5cx
- #undef shacx
-     } else 
- #endif
--    {
-+    if (ss->ssl3.hs.tls12_handshake_hash) {
-+	PK11Context *h;
-+	unsigned int  stateLen;
-+	unsigned char stackBuf[1024];
-+	unsigned char *stateBuf = NULL;
-+
-+	if (!spec->master_secret) {
-+	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_HANDSHAKE);
-+	    return SECFailure;
-+	}
-+
-+	h = ss->ssl3.hs.tls12_handshake_hash;
-+	stateBuf = PK11_SaveContextAlloc(h, stackBuf,
-+					 sizeof(stackBuf), &stateLen);
-+	if (stateBuf == NULL) {
-+	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+	    goto tls12_loser;
-+	}
-+	rv |= PK11_DigestFinal(h, hashes->u.raw, &hashes->len,
-+			       sizeof(hashes->u.raw));
-+	if (rv != SECSuccess) {
-+	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+	    rv = SECFailure;
-+	    goto tls12_loser;
-+	}
-+	/* If we ever support ciphersuites where the PRF hash isn't SHA-256
-+	 * then this will need to be updated. */
-+	hashes->hashAlg = SEC_OID_SHA256;
-+	rv = SECSuccess;
-+
-+tls12_loser:
-+	if (stateBuf) {
-+	    if (PK11_RestoreContext(ss->ssl3.hs.tls12_handshake_hash, stateBuf,
-+				    stateLen) != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+		rv = SECFailure;
-+	    }
-+	    if (stateBuf != stackBuf) {
-+		PORT_ZFree(stateBuf, stateLen);
-+	    }
-+	}
-+    } else {
- 	/* compute hases with PKCS11 */
- 	PK11Context * md5;
- 	PK11Context * sha       = NULL;
-@@ -4051,7 +4423,7 @@
- 	    rv |= PK11_DigestOp(md5, mac_pad_2, mac_defs[mac_md5].pad_size);
- 	    rv |= PK11_DigestOp(md5, md5_inner, MD5_LENGTH);
- 	}
--	rv |= PK11_DigestFinal(md5, hashes->md5, &outLength, MD5_LENGTH);
-+	rv |= PK11_DigestFinal(md5, hashes->u.s.md5, &outLength, MD5_LENGTH);
- 	PORT_Assert(rv != SECSuccess || outLength == MD5_LENGTH);
- 	if (rv != SECSuccess) {
- 	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-@@ -4059,7 +4431,7 @@
- 	    goto loser;
- 	}
- 
--	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->md5, MD5_LENGTH));
-+	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->u.s.md5, MD5_LENGTH));
- 
- 	if (!isTLS) {
- 	    PRINT_BUF(95, (NULL, "SHA outer: MAC Pad 2", mac_pad_2, 
-@@ -4071,7 +4443,7 @@
- 	    rv |= PK11_DigestOp(sha, mac_pad_2, mac_defs[mac_sha].pad_size);
- 	    rv |= PK11_DigestOp(sha, sha_inner, SHA1_LENGTH);
- 	}
--	rv |= PK11_DigestFinal(sha, hashes->sha, &outLength, SHA1_LENGTH);
-+	rv |= PK11_DigestFinal(sha, hashes->u.s.sha, &outLength, SHA1_LENGTH);
- 	PORT_Assert(rv != SECSuccess || outLength == SHA1_LENGTH);
- 	if (rv != SECSuccess) {
- 	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-@@ -4079,8 +4451,9 @@
- 	    goto loser;
- 	}
- 
--	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->sha, SHA1_LENGTH));
-+	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->u.s.sha, SHA1_LENGTH));
- 
-+	hashes->len = MD5_LENGTH + SHA1_LENGTH;
- 	rv = SECSuccess;
- 
-     loser:
-@@ -5343,8 +5716,12 @@
- {
-     SECStatus     rv		= SECFailure;
-     PRBool        isTLS;
-+    PRBool        isTLS12;
-     SECItem       buf           = {siBuffer, NULL, 0};
-     SSL3Hashes    hashes;
-+    KeyType       keyType;
-+    unsigned int  len;
-+    SSL3SignatureAndHashAlgorithm sigAndHash;
- 
-     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
-@@ -5393,10 +5772,30 @@
- 	goto done;	/* err code was set by ssl3_SignHashes */
-     }
- 
--    rv = ssl3_AppendHandshakeHeader(ss, certificate_verify, buf.len + 2);
-+    len = buf.len + 2 + (isTLS12 ? 2 : 0);
-+
-+    rv = ssl3_AppendHandshakeHeader(ss, certificate_verify, len);
-     if (rv != SECSuccess) {
- 	goto done;	/* error code set by AppendHandshake */
-     }
-+    if (isTLS12) {
-+	rv = ssl3_TLSSignatureAlgorithmForKeyType(keyType,
-+						  &sigAndHash.sigAlg);
-+	if (rv != SECSuccess) {
-+	    goto done;
-+	}
-+	/* We always sign using the handshake hash function. It's possible that
-+	 * a server could support SHA-256 as the handshake hash but not as a
-+	 * signature hash. In that case we wouldn't be able to do client
-+	 * certificates with it. The alternative is to buffer all handshake
-+	 * messages. */
-+	sigAndHash.hashAlg = hashes.hashAlg;
-+
-+	rv = ssl3_AppendSignatureAndHashAlgorithm(ss, &sigAndHash);
-+	if (rv != SECSuccess) {
-+	    goto done; 	/* err set by AppendHandshake. */
-+	}
-+    }
-     rv = ssl3_AppendHandshakeVariable(ss, buf.data, buf.len, 2);
-     if (rv != SECSuccess) {
- 	goto done;	/* error code set by AppendHandshake */
-@@ -5504,6 +5903,13 @@
-     }
-     isTLS = (ss->version > SSL_LIBRARY_VERSION_3_0);
- 
-+    rv = ssl3_InitTLS12HandshakeHash(ss);
-+    if (rv != SECSuccess) {
-+	desc = internal_error;
-+	errCode = PORT_GetError();
-+	goto alert_loser;
-+    }
-+
-     rv = ssl3_ConsumeHandshake(
- 	ss, &ss->ssl3.hs.server_random, SSL3_RANDOM_LENGTH, &b, &length);
-     if (rv != SECSuccess) {
-@@ -5834,13 +6240,16 @@
- {
-     PRArenaPool *    arena     = NULL;
-     SECKEYPublicKey *peerKey   = NULL;
--    PRBool           isTLS;
-+    PRBool           isTLS, isTLS12;
-     SECStatus        rv;
-     int              errCode   = SSL_ERROR_RX_MALFORMED_SERVER_KEY_EXCH;
-     SSL3AlertDescription desc  = illegal_parameter;
-     SSL3Hashes       hashes;
-     SECItem          signature = {siBuffer, NULL, 0};
-+    SSL3SignatureAndHashAlgorithm sigAndHash;
- 
-+    sigAndHash.hashAlg = SEC_OID_UNKNOWN;
-+
-     SSL_TRC(3, ("%d: SSL3[%d]: handle server_key_exchange handshake",
- 		SSL_GETPID(), ss->fd));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
-@@ -5859,6 +6268,7 @@
-     }
- 
-     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
- 
-     switch (ss->ssl3.hs.kea_def->exchKeyType) {
- 
-@@ -5874,6 +6284,18 @@
-     	if (rv != SECSuccess) {
- 	    goto loser;		/* malformed. */
- 	}
-+	if (isTLS12) {
-+	    rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-+						       &sigAndHash);
-+	    if (rv != SECSuccess) {
-+		goto loser;	/* malformed or unsupported. */
-+	    }
-+	    rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-+		    &sigAndHash, ss->sec.peerCert);
-+	    if (rv != SECSuccess) {
-+		goto loser;
-+	    }
-+	}
-     	rv = ssl3_ConsumeHandshakeVariable(ss, &signature, 2, &b, &length);
-     	if (rv != SECSuccess) {
- 	    goto loser;		/* malformed. */
-@@ -5891,7 +6313,7 @@
-     	/*
-      	 *  check to make sure the hash is signed by right guy
-      	 */
--    	rv = ssl3_ComputeExportRSAKeyHash(modulus, exponent,
-+	rv = ssl3_ComputeExportRSAKeyHash(sigAndHash.hashAlg, modulus, exponent,
- 					  &ss->ssl3.hs.client_random,
- 					  &ss->ssl3.hs.server_random, 
- 					  &hashes, ss->opt.bypassPKCS11);
-@@ -5964,6 +6386,18 @@
- 	}
- 	if (dh_Ys.len > dh_p.len || !ssl3_BigIntGreaterThanOne(&dh_Ys))
- 	    goto alert_loser;
-+	if (isTLS12) {
-+	    rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-+						       &sigAndHash);
-+	    if (rv != SECSuccess) {
-+		goto loser;	/* malformed or unsupported. */
-+	    }
-+	    rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-+		    &sigAndHash, ss->sec.peerCert);
-+	    if (rv != SECSuccess) {
-+		goto loser;
-+	    }
-+	}
-     	rv = ssl3_ConsumeHandshakeVariable(ss, &signature, 2, &b, &length);
-     	if (rv != SECSuccess) {
- 	    goto loser;		/* malformed. */
-@@ -5985,7 +6419,7 @@
-     	/*
-      	 *  check to make sure the hash is signed by right guy
-      	 */
--    	rv = ssl3_ComputeDHKeyHash(dh_p, dh_g, dh_Ys,
-+	rv = ssl3_ComputeDHKeyHash(sigAndHash.hashAlg, dh_p, dh_g, dh_Ys,
- 					  &ss->ssl3.hs.client_random,
- 					  &ss->ssl3.hs.server_random, 
- 					  &hashes, ss->opt.bypassPKCS11);
-@@ -6862,6 +7296,13 @@
- 	goto alert_loser;
-     }
- 
-+    rv = ssl3_InitTLS12HandshakeHash(ss);
-+    if (rv != SECSuccess) {
-+	desc = internal_error;
-+	errCode = PORT_GetError();
-+	goto alert_loser;
-+    }
-+
-     /* grab the client random data. */
-     rv = ssl3_ConsumeHandshake(
- 	ss, &ss->ssl3.hs.client_random, SSL3_RANDOM_LENGTH, &b, &length);
-@@ -7604,6 +8045,13 @@
- 	goto alert_loser;
-     }
- 
-+    rv = ssl3_InitTLS12HandshakeHash(ss);
-+    if (rv != SECSuccess) {
-+	desc = internal_error;
-+	errCode = PORT_GetError();
-+	goto alert_loser;
-+    }
-+
-     /* if we get a non-zero SID, just ignore it. */
-     if (length !=
-         SSL_HL_CLIENT_HELLO_HBYTES + suite_length + sid_length + rand_length) {
-@@ -7851,7 +8299,86 @@
-     return SECSuccess;
- }
- 
-+/* ssl3_PickSignatureHashAlgorithm selects a hash algorithm to use when signing
-+ * elements of the handshake. (The negotiated cipher suite determines the
-+ * signature algorithm.) Prior to TLS 1.2, the MD5/SHA1 combination is always
-+ * used. With TLS 1.2, a client may advertise its support for signature and
-+ * hash combinations. */
-+static SECStatus
-+ssl3_PickSignatureHashAlgorithm(sslSocket *ss,
-+				SSL3SignatureAndHashAlgorithm* out)
-+{
-+    TLSSignatureAlgorithm sigAlg;
-+    unsigned int i, j;
-+    /* hashPreference expresses our preferences for hash algorithms, most
-+     * preferable first. */
-+    static const PRUint8 hashPreference[] = {
-+	tls_hash_sha256,
-+	tls_hash_sha384,
-+	tls_hash_sha512,
-+	tls_hash_sha1,
-+    };
- 
-+    switch (ss->ssl3.hs.kea_def->kea) {
-+    case kea_rsa:
-+    case kea_rsa_export:
-+    case kea_rsa_export_1024:
-+    case kea_dh_rsa:
-+    case kea_dh_rsa_export:
-+    case kea_dhe_rsa:
-+    case kea_dhe_rsa_export:
-+    case kea_rsa_fips:
-+    case kea_ecdh_rsa:
-+    case kea_ecdhe_rsa:
-+	sigAlg = tls_sig_rsa;
-+	break;
-+    case kea_dh_dss:
-+    case kea_dh_dss_export:
-+    case kea_dhe_dss:
-+    case kea_dhe_dss_export:
-+	sigAlg = tls_sig_dsa;
-+	break;
-+    case kea_ecdh_ecdsa:
-+    case kea_ecdhe_ecdsa:
-+	sigAlg = tls_sig_ecdsa;
-+	break;
-+    default:
-+	PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
-+	return SECFailure;
-+    }
-+    out->sigAlg = sigAlg;
-+
-+    if (ss->version <= SSL_LIBRARY_VERSION_TLS_1_1) {
-+	/* SEC_OID_UNKNOWN means the MD5/SHA1 combo hash used in TLS 1.1 and
-+	 * prior. */
-+	out->hashAlg = SEC_OID_UNKNOWN;
-+	return SECSuccess;
-+    }
-+
-+    if (ss->ssl3.hs.numClientSigAndHash == 0) {
-+	/* If the client didn't provide any signature_algorithms extension then
-+	 * we can assume that they support SHA-1:
-+	 * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+	out->hashAlg = SEC_OID_SHA1;
-+	return SECSuccess;
-+    }
-+
-+    for (i = 0; i < PR_ARRAY_SIZE(hashPreference); i++) {
-+	for (j = 0; j < ss->ssl3.hs.numClientSigAndHash; j++) {
-+	    const SSL3SignatureAndHashAlgorithm* sh =
-+		&ss->ssl3.hs.clientSigAndHash[j];
-+	    if (sh->sigAlg == sigAlg && sh->hashAlg == hashPreference[i]) {
-+		out->hashAlg = sh->hashAlg;
-+		return SECSuccess;
-+	    }
-+	}
-+    }
-+
-+    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+    return SECFailure;
-+}
-+
-+
- static SECStatus
- ssl3_SendServerKeyExchange(sslSocket *ss)
- {
-@@ -7862,6 +8389,7 @@
-     SECItem            signed_hash = {siBuffer, NULL, 0};
-     SSL3Hashes         hashes;
-     SECKEYPublicKey *  sdPub;	/* public key for step-down */
-+    SSL3SignatureAndHashAlgorithm sigAndHash;
- 
-     SSL_TRC(3, ("%d: SSL3[%d]: send server_key_exchange handshake",
- 		SSL_GETPID(), ss->fd));
-@@ -7869,6 +8397,10 @@
-     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
- 
-+    if (ssl3_PickSignatureHashAlgorithm(ss, &sigAndHash) != SECSuccess) {
-+	return SECFailure;
-+    }
-+
-     switch (kea_def->exchKeyType) {
-     case kt_rsa:
- 	/* Perform SSL Step-Down here. */
-@@ -7878,7 +8410,8 @@
- 	    PORT_SetError(SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE);
- 	    return SECFailure;
- 	}
--    	rv = ssl3_ComputeExportRSAKeyHash(sdPub->u.rsa.modulus,
-+	rv = ssl3_ComputeExportRSAKeyHash(sigAndHash.hashAlg,
-+					  sdPub->u.rsa.modulus,
- 					  sdPub->u.rsa.publicExponent,
- 	                                  &ss->ssl3.hs.client_random,
- 	                                  &ss->ssl3.hs.server_random,
-@@ -7921,6 +8454,13 @@
- 	    goto loser; 	/* err set by AppendHandshake. */
- 	}
- 
-+	if (ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	    rv = ssl3_AppendSignatureAndHashAlgorithm(ss, &sigAndHash);
-+	    if (rv != SECSuccess) {
-+		goto loser; 	/* err set by AppendHandshake. */
-+	    }
-+	}
-+
- 	rv = ssl3_AppendHandshakeVariable(ss, signed_hash.data,
- 	                                  signed_hash.len, 2);
- 	if (rv != SECSuccess) {
-@@ -7931,7 +8471,7 @@
- 
- #ifdef NSS_ENABLE_ECC
-     case kt_ecdh: {
--	rv = ssl3_SendECDHServerKeyExchange(ss);
-+	rv = ssl3_SendECDHServerKeyExchange(ss, &sigAndHash);
- 	return rv;
-     }
- #endif /* NSS_ENABLE_ECC */
-@@ -8045,26 +8585,51 @@
-     SECStatus            rv;
-     int                  errCode     = SSL_ERROR_RX_MALFORMED_CERT_VERIFY;
-     SSL3AlertDescription desc        = handshake_failure;
--    PRBool               isTLS;
-+    PRBool               isTLS, isTLS12;
-+    SSL3SignatureAndHashAlgorithm sigAndHash;
- 
-     SSL_TRC(3, ("%d: SSL3[%d]: handle certificate_verify handshake",
- 		SSL_GETPID(), ss->fd));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
- 
-+    isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-+
-     if (ss->ssl3.hs.ws != wait_cert_verify || ss->sec.peerCert == NULL) {
- 	desc    = unexpected_message;
- 	errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY;
- 	goto alert_loser;
-     }
- 
-+    if (isTLS12) {
-+	rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-+						   &sigAndHash);
-+	if (rv != SECSuccess) {
-+	    goto loser;	/* malformed or unsupported. */
-+	}
-+	rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-+		&sigAndHash, ss->sec.peerCert);
-+	if (rv != SECSuccess) {
-+	    errCode = PORT_GetError();
-+	    desc = decrypt_error;
-+	    goto alert_loser;
-+	}
-+
-+	/* We only support CertificateVerify messages that use the handshake
-+	 * hash. */
-+	if (sigAndHash.hashAlg != hashes->hashAlg) {
-+	    errCode = SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM;
-+	    desc = decrypt_error;
-+	    goto alert_loser;
-+	}
-+    }
-+
-     rv = ssl3_ConsumeHandshakeVariable(ss, &signed_hash, 2, &b, &length);
-     if (rv != SECSuccess) {
- 	goto loser;		/* malformed. */
-     }
- 
--    isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
--
-     /* XXX verify that the key & kea match */
-     rv = ssl3_VerifySignedHashes(hashes, ss->sec.peerCert, &signed_hash,
- 				 isTLS, ss->pkcs11PinArg);
-@@ -9163,7 +9728,7 @@
- static SECStatus
- ssl3_ComputeTLSFinished(ssl3CipherSpec *spec,
- 			PRBool          isServer,
--                const   SSL3Finished *  hashes,
-+                const   SSL3Hashes   *  hashes,
-                         TLSFinished  *  tlsFinished)
- {
-     const char * label;
-@@ -9173,8 +9738,8 @@
-     label = isServer ? "server finished" : "client finished";
-     len   = 15;
- 
--    rv = ssl3_TLSPRFWithMasterSecret(spec, label, len, hashes->md5,
--	sizeof *hashes, tlsFinished->verify_data,
-+    rv = ssl3_TLSPRFWithMasterSecret(spec, label, len, hashes->u.raw,
-+	hashes->len, tlsFinished->verify_data,
- 	sizeof tlsFinished->verify_data);
- 
-     return rv;
-@@ -9192,12 +9757,16 @@
-     SECStatus rv = SECSuccess;
- 
-     if (spec->master_secret && !spec->bypassCiphers) {
--	SECItem      param       = {siBuffer, NULL, 0};
--	PK11Context *prf_context =
--	    PK11_CreateContextBySymKey(CKM_TLS_PRF_GENERAL, CKA_SIGN, 
--				       spec->master_secret, &param);
-+	SECItem param = {siBuffer, NULL, 0};
-+	CK_MECHANISM_TYPE mech = CKM_TLS_PRF_GENERAL;
-+	PK11Context *prf_context;
- 	unsigned int retLen;
- 
-+	if (spec->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	    mech = CKM_NSS_TLS_PRF_GENERAL_SHA256;
-+	}
-+	prf_context = PK11_CreateContextBySymKey(mech, CKA_SIGN,
-+						 spec->master_secret, &param);
- 	if (!prf_context)
- 	    return SECFailure;
- 
-@@ -9496,7 +10066,7 @@
-     PRBool          isServer = ss->sec.isServer;
-     SECStatus       rv;
-     SSL3Sender      sender = isServer ? sender_server : sender_client;
--    SSL3Finished    hashes;
-+    SSL3Hashes      hashes;
-     TLSFinished     tlsFinished;
- 
-     SSL_TRC(3, ("%d: SSL3[%d]: send finished handshake", SSL_GETPID(), ss->fd));
-@@ -9530,14 +10100,15 @@
- 	    goto fail; 		/* err set by AppendHandshake. */
-     } else {
- 	if (isServer)
--	    ss->ssl3.hs.finishedMsgs.sFinished[1] = hashes;
-+	    ss->ssl3.hs.finishedMsgs.sFinished[1] = hashes.u.s;
- 	else
--	    ss->ssl3.hs.finishedMsgs.sFinished[0] = hashes;
--	ss->ssl3.hs.finishedBytes = sizeof hashes;
--	rv = ssl3_AppendHandshakeHeader(ss, finished, sizeof hashes);
-+	    ss->ssl3.hs.finishedMsgs.sFinished[0] = hashes.u.s;
-+	PORT_Assert(hashes.len == sizeof hashes.u.s);
-+	ss->ssl3.hs.finishedBytes = sizeof hashes.u.s;
-+	rv = ssl3_AppendHandshakeHeader(ss, finished, sizeof hashes.u.s);
- 	if (rv != SECSuccess) 
- 	    goto fail; 		/* err set by AppendHandshake. */
--	rv = ssl3_AppendHandshake(ss, &hashes, sizeof hashes);
-+	rv = ssl3_AppendHandshake(ss, &hashes.u.s, sizeof hashes.u.s);
- 	if (rv != SECSuccess) 
- 	    goto fail; 		/* err set by AppendHandshake. */
-     }
-@@ -9686,18 +10257,19 @@
- 	    return SECFailure;
- 	}
-     } else {
--	if (length != sizeof(SSL3Hashes)) {
-+	if (length != sizeof(SSL3Finished)) {
- 	    (void)ssl3_IllegalParameter(ss);
- 	    PORT_SetError(SSL_ERROR_RX_MALFORMED_FINISHED);
- 	    return SECFailure;
- 	}
- 
- 	if (!isServer)
--	    ss->ssl3.hs.finishedMsgs.sFinished[1] = *hashes;
-+	    ss->ssl3.hs.finishedMsgs.sFinished[1] = hashes->u.s;
- 	else
--	    ss->ssl3.hs.finishedMsgs.sFinished[0] = *hashes;
--	ss->ssl3.hs.finishedBytes = sizeof *hashes;
--	if (0 != NSS_SecureMemcmp(hashes, b, length)) {
-+	    ss->ssl3.hs.finishedMsgs.sFinished[0] = hashes->u.s;
-+	PORT_Assert(hashes->len == sizeof hashes->u.s);
-+	ss->ssl3.hs.finishedBytes = sizeof hashes->u.s;
-+	if (0 != NSS_SecureMemcmp(&hashes->u.s, b, length)) {
- 	    (void)ssl3_HandshakeFailure(ss);
- 	    PORT_SetError(SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE);
- 	    return SECFailure;
-@@ -11286,6 +11858,12 @@
-     if (ss->ssl3.hs.sha) {
- 	PK11_DestroyContext(ss->ssl3.hs.sha,PR_TRUE);
-     }
-+    if (ss->ssl3.hs.tls12_handshake_hash) {
-+	PK11_DestroyContext(ss->ssl3.hs.tls12_handshake_hash,PR_TRUE);
-+    }
-+    if (ss->ssl3.hs.clientSigAndHash) {
-+	PORT_Free(ss->ssl3.hs.clientSigAndHash);
-+    }
-     if (ss->ssl3.hs.messages.buf) {
-     	PORT_Free(ss->ssl3.hs.messages.buf);
- 	ss->ssl3.hs.messages.buf = NULL;
diff --git a/src/net/third_party/nss/patches/tls12certrequest.patch b/src/net/third_party/nss/patches/tls12certrequest.patch
deleted file mode 100644
index 6992097..0000000
--- a/src/net/third_party/nss/patches/tls12certrequest.patch
+++ /dev/null
@@ -1,235 +0,0 @@
-Index: net/third_party/nss/ssl/ssl3con.c
-===================================================================
---- net/third_party/nss/ssl/ssl3con.c	(revision 203164)
-+++ net/third_party/nss/ssl/ssl3con.c	(working copy)
-@@ -196,12 +196,27 @@
- 
- static const /*SSL3ClientCertificateType */ uint8 certificate_types [] = {
-     ct_RSA_sign,
--    ct_DSS_sign,
- #ifdef NSS_ENABLE_ECC
-     ct_ECDSA_sign,
- #endif /* NSS_ENABLE_ECC */
-+    ct_DSS_sign,
- };
- 
-+/* This block is our supported_signature_algorithms value, in wire format.
-+ * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-+static const PRUint8 supported_signature_algorithms[] = {
-+    tls_hash_sha256, tls_sig_rsa,
-+    tls_hash_sha384, tls_sig_rsa,
-+    tls_hash_sha1,   tls_sig_rsa,
-+#ifdef NSS_ENABLE_ECC
-+    tls_hash_sha256, tls_sig_ecdsa,
-+    tls_hash_sha384, tls_sig_ecdsa,
-+    tls_hash_sha1,   tls_sig_ecdsa,
-+#endif
-+    tls_hash_sha256, tls_sig_dsa,
-+    tls_hash_sha1,   tls_sig_dsa,
-+};
-+
- #define EXPORT_RSA_KEY_LENGTH 64	/* bytes */
- 
- 
-@@ -3932,6 +3947,23 @@
-     return ssl3_AppendHandshake(ss, serialized, sizeof(serialized));
- }
- 
-+/* Appends our supported_signature_algorithms value to the current handshake
-+ * message. */
-+SECStatus
-+ssl3_AppendSupportedSignatureAlgorithms(sslSocket *ss)
-+{
-+    return ssl3_AppendHandshakeVariable(ss, supported_signature_algorithms,
-+					sizeof supported_signature_algorithms,
-+					2);
-+}
-+
-+/* Returns the size in bytes of our supported_signature_algorithms value. */
-+unsigned int
-+ssl3_SizeOfSupportedSignatureAlgorithms(void)
-+{
-+    return sizeof supported_signature_algorithms;
-+}
-+
- /**************************************************************************
-  * Consume Handshake functions.
-  *
-@@ -6508,12 +6540,14 @@
-     dnameNode *          node;
-     PRInt32              remaining;
-     PRBool               isTLS       = PR_FALSE;
-+    PRBool               isTLS12     = PR_FALSE;
-     int                  i;
-     int                  errCode     = SSL_ERROR_RX_MALFORMED_CERT_REQUEST;
-     int                  nnames      = 0;
-     SECStatus            rv;
-     SSL3AlertDescription desc        = illegal_parameter;
-     SECItem              cert_types  = {siBuffer, NULL, 0};
-+    SECItem              algorithms  = {siBuffer, NULL, 0};
-     CERTDistNames        ca_list;
- #ifdef NSS_PLATFORM_CLIENT_AUTH
-     CERTCertList *       platform_cert_list = NULL;
-@@ -6538,6 +6572,7 @@
-     PORT_Assert(ss->ssl3.platformClientKey == (PlatformKey)NULL);
- 
-     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-     rv = ssl3_ConsumeHandshakeVariable(ss, &cert_types, 1, &b, &length);
-     if (rv != SECSuccess)
-     	goto loser;		/* malformed, alert has been sent */
-@@ -6545,6 +6580,18 @@
-     PORT_Assert(!ss->requestedCertTypes);
-     ss->requestedCertTypes = &cert_types;
- 
-+    if (isTLS12) {
-+	rv = ssl3_ConsumeHandshakeVariable(ss, &algorithms, 2, &b, &length);
-+	if (rv != SECSuccess)
-+	    goto loser;		/* malformed, alert has been sent */
-+	/* An empty or odd-length value is invalid.
-+	 *    SignatureAndHashAlgorithm
-+	 *      supported_signature_algorithms<2..2^16-2>;
-+	 */
-+	if (algorithms.len == 0 || (algorithms.len & 1) != 0)
-+	    goto alert_loser;
-+    }
-+
-     arena = ca_list.arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
-     if (arena == NULL)
-     	goto no_mem;
-@@ -6607,7 +6654,7 @@
- 
- #ifdef NSS_PLATFORM_CLIENT_AUTH
-     if (ss->getPlatformClientAuthData != NULL) {
--	/* XXX Should pass cert_types in this call!! */
-+	/* XXX Should pass cert_types and algorithms in this call!! */
-         rv = (SECStatus)(*ss->getPlatformClientAuthData)(
-                                         ss->getPlatformClientAuthDataArg,
-                                         ss->fd, &ca_list,
-@@ -6618,7 +6665,7 @@
-     } else
- #endif
-     if (ss->getClientAuthData != NULL) {
--	/* XXX Should pass cert_types in this call!! */
-+	/* XXX Should pass cert_types and algorithms in this call!! */
- 	rv = (SECStatus)(*ss->getClientAuthData)(ss->getClientAuthDataArg,
- 						 ss->fd, &ca_list,
- 						 &ss->ssl3.clientCertificate,
-@@ -8492,6 +8539,7 @@
- static SECStatus
- ssl3_SendCertificateRequest(sslSocket *ss)
- {
-+    PRBool         isTLS12;
-     SECItem *      name;
-     CERTDistNames *ca_list;
-     const uint8 *  certTypes;
-@@ -8509,6 +8557,8 @@
-     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
- 
-+    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-+
-     /* ssl3.ca_list is initialized to NULL, and never changed. */
-     ca_list = ss->ssl3.ca_list;
-     if (!ca_list) {
-@@ -8528,6 +8578,9 @@
-     certTypesLength = sizeof certificate_types;
- 
-     length = 1 + certTypesLength + 2 + calen;
-+    if (isTLS12) {
-+	length += 2 + ssl3_SizeOfSupportedSignatureAlgorithms();
-+    }
- 
-     rv = ssl3_AppendHandshakeHeader(ss, certificate_request, length);
-     if (rv != SECSuccess) {
-@@ -8537,6 +8590,12 @@
-     if (rv != SECSuccess) {
- 	return rv; 		/* err set by AppendHandshake. */
-     }
-+    if (isTLS12) {
-+	rv = ssl3_AppendSupportedSignatureAlgorithms(ss);
-+	if (rv != SECSuccess) {
-+	    return rv; 		/* err set by AppendHandshake. */
-+	}
-+    }
-     rv = ssl3_AppendHandshakeNumber(ss, calen, 2);
-     if (rv != SECSuccess) {
- 	return rv; 		/* err set by AppendHandshake. */
-Index: net/third_party/nss/ssl/sslimpl.h
-===================================================================
---- net/third_party/nss/ssl/sslimpl.h	(revision 203164)
-+++ net/third_party/nss/ssl/sslimpl.h	(working copy)
-@@ -1666,6 +1666,8 @@
- 			const SSL3Opaque *src, PRInt32 bytes, PRInt32 lenSize);
- extern SECStatus ssl3_AppendSignatureAndHashAlgorithm(sslSocket *ss,
- 			const SSL3SignatureAndHashAlgorithm* sigAndHash);
-+extern SECStatus ssl3_AppendSupportedSignatureAlgorithms(sslSocket *ss);
-+extern unsigned int ssl3_SizeOfSupportedSignatureAlgorithms(void);
- extern SECStatus ssl3_ConsumeHandshake(sslSocket *ss, void *v, PRInt32 bytes, 
- 			SSL3Opaque **b, PRUint32 *length);
- extern PRInt32   ssl3_ConsumeHandshakeNumber(sslSocket *ss, PRInt32 bytes, 
-Index: net/third_party/nss/ssl/ssl3ext.c
-===================================================================
---- net/third_party/nss/ssl/ssl3ext.c	(revision 203164)
-+++ net/third_party/nss/ssl/ssl3ext.c	(working copy)
-@@ -2070,17 +2070,14 @@
-     if (rv != SECSuccess) {
- 	return SECFailure;
-     }
--    /* Trailing data or odd-length parameters is invalid. */
--    if (data->len != 0 || (algorithms.len & 1) != 0) {
-+    /* Trailing data, empty value, or odd-length value is invalid. */
-+    if (data->len != 0 || algorithms.len == 0 || (algorithms.len & 1) != 0) {
- 	PORT_SetError(SSL_ERROR_RX_MALFORMED_CLIENT_HELLO);
- 	return SECFailure;
-     }
- 
-     numAlgorithms = algorithms.len/2;
- 
--    if (numAlgorithms == 0) {
--	return SECSuccess;
--    }
-     /* We don't care to process excessive numbers of algorithms. */
-     if (numAlgorithms > 512) {
- 	numAlgorithms = 512;
-@@ -2125,21 +2122,6 @@
- static PRInt32
- ssl3_ClientSendSigAlgsXtn(sslSocket * ss, PRBool append, PRUint32 maxBytes)
- {
--    static const unsigned char signatureAlgorithms[] = {
--	/* This block is the contents of our signature_algorithms extension, in
--	 * wire format. See
--	 * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
--	tls_hash_sha256, tls_sig_rsa,
--	tls_hash_sha384, tls_sig_rsa,
--	tls_hash_sha1,   tls_sig_rsa,
--#ifdef NSS_ENABLE_ECC
--	tls_hash_sha256, tls_sig_ecdsa,
--	tls_hash_sha384, tls_sig_ecdsa,
--	tls_hash_sha1,   tls_sig_ecdsa,
--#endif
--	tls_hash_sha256, tls_sig_dsa,
--	tls_hash_sha1,   tls_sig_dsa,
--    };
-     PRInt32 extension_length;
- 
-     if (ss->version < SSL_LIBRARY_VERSION_TLS_1_2) {
-@@ -2150,7 +2132,7 @@
- 	2 /* extension type */ +
- 	2 /* extension length */ +
- 	2 /* supported_signature_algorithms length */ +
--	sizeof(signatureAlgorithms);
-+	ssl3_SizeOfSupportedSignatureAlgorithms();
- 
-     if (append && maxBytes >= extension_length) {
- 	SECStatus rv;
-@@ -2160,8 +2142,7 @@
- 	rv = ssl3_AppendHandshakeNumber(ss, extension_length - 4, 2);
- 	if (rv != SECSuccess)
- 	    goto loser;
--	rv = ssl3_AppendHandshakeVariable(ss, signatureAlgorithms,
--					  sizeof(signatureAlgorithms), 2);
-+	rv = ssl3_AppendSupportedSignatureAlgorithms(ss);
- 	if (rv != SECSuccess)
- 	    goto loser;
- 	ss->xtnData.advertised[ss->xtnData.numAdvertised++] =
diff --git a/src/net/third_party/nss/patches/tls12chromium.patch b/src/net/third_party/nss/patches/tls12chromium.patch
deleted file mode 100644
index 217111b..0000000
--- a/src/net/third_party/nss/patches/tls12chromium.patch
+++ /dev/null
@@ -1,317 +0,0 @@
-Index: net/third_party/nss/ssl/sslplatf.c
-===================================================================
---- net/third_party/nss/ssl/sslplatf.c	(revision 202696)
-+++ net/third_party/nss/ssl/sslplatf.c	(working copy)
-@@ -212,9 +212,8 @@
-     DWORD           dwFlags           = 0;
-     VOID           *pPaddingInfo      = NULL;
- 
--    /* Always encode using PKCS#1 block type, with no OID/encoded DigestInfo */
-+    /* Always encode using PKCS#1 block type. */
-     BCRYPT_PKCS1_PADDING_INFO rsaPaddingInfo;
--    rsaPaddingInfo.pszAlgId = NULL;
- 
-     if (key->dwKeySpec != CERT_NCRYPT_KEY_SPEC) {
-         PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
-@@ -227,8 +226,29 @@
- 
-     switch (keyType) {
-         case rsaKey:
--            hashItem.data = hash->md5;
--            hashItem.len  = sizeof(SSL3Hashes);
-+            switch (hash->hashAlg) {
-+                case SEC_OID_UNKNOWN:
-+                    /* No OID/encoded DigestInfo. */
-+                    rsaPaddingInfo.pszAlgId = NULL;
-+                    break;
-+                case SEC_OID_SHA1:
-+                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA1_ALGORITHM;
-+                    break;
-+                case SEC_OID_SHA256:
-+                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA256_ALGORITHM;
-+                    break;
-+                case SEC_OID_SHA384:
-+                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA384_ALGORITHM;
-+                    break;
-+                case SEC_OID_SHA512:
-+                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA512_ALGORITHM;
-+                    break;
-+                default:
-+                    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+                    return SECFailure;
-+            }
-+            hashItem.data = hash->u.raw;
-+            hashItem.len  = hash->len;
-             dwFlags       = BCRYPT_PAD_PKCS1;
-             pPaddingInfo  = &rsaPaddingInfo;
-             break;
-@@ -239,8 +259,13 @@
-             } else {
-                 doDerEncode = isTLS;
-             }
--            hashItem.data = hash->sha;
--            hashItem.len  = sizeof(hash->sha);
-+            if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+                hashItem.data = hash->u.s.sha;
-+                hashItem.len  = sizeof(hash->u.s.sha);
-+            } else {
-+                hashItem.data = hash->u.raw;
-+                hashItem.len  = hash->len;
-+            }
-             break;
-         default:
-             PORT_SetError(SEC_ERROR_INVALID_KEY);
-@@ -315,11 +340,34 @@
- 
-     buf->data = NULL;
- 
-+    switch (hash->hashAlg) {
-+        case SEC_OID_UNKNOWN:
-+            hashAlg = 0;
-+            break;
-+        case SEC_OID_SHA1:
-+            hashAlg = CALG_SHA1;
-+            break;
-+        case SEC_OID_SHA256:
-+            hashAlg = CALG_SHA_256;
-+            break;
-+        case SEC_OID_SHA384:
-+            hashAlg = CALG_SHA_384;
-+            break;
-+        case SEC_OID_SHA512:
-+            hashAlg = CALG_SHA_512;
-+            break;
-+        default:
-+            PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+            return SECFailure;
-+    }
-+
-     switch (keyType) {
-         case rsaKey:
--            hashAlg       = CALG_SSL3_SHAMD5;
--            hashItem.data = hash->md5;
--            hashItem.len  = sizeof(SSL3Hashes);
-+            if (hashAlg == 0) {
-+                hashAlg = CALG_SSL3_SHAMD5;
-+            }
-+            hashItem.data = hash->u.raw;
-+            hashItem.len = hash->len;
-             break;
-         case dsaKey:
-         case ecKey:
-@@ -328,9 +376,14 @@
-             } else {
-                 doDerEncode = isTLS;
-             }
--            hashAlg       = CALG_SHA1;
--            hashItem.data = hash->sha;
--            hashItem.len  = sizeof(hash->sha);
-+            if (hashAlg == 0) {
-+                hashAlg = CALG_SHA1;
-+                hashItem.data = hash->u.s.sha;
-+                hashItem.len = sizeof(hash->u.s.sha);
-+            } else {
-+                hashItem.data = hash->u.raw;
-+                hashItem.len = hash->len;
-+            }
-             break;
-         default:
-             PORT_SetError(SEC_ERROR_INVALID_KEY);
-@@ -468,11 +521,36 @@
-         goto done;    /* error code was set. */
- 
-     sigAlg = cssmKey->KeyHeader.AlgorithmId;
-+    if (keyType == rsaKey) {
-+        PORT_Assert(sigAlg == CSSM_ALGID_RSA);
-+        switch (hash->hashAlg) {
-+            case SEC_OID_UNKNOWN:
-+                break;
-+            case SEC_OID_SHA1:
-+                sigAlg = CSSM_ALGID_SHA1WithRSA;
-+                break;
-+            case SEC_OID_SHA224:
-+                sigAlg = CSSM_ALGID_SHA224WithRSA;
-+                break;
-+            case SEC_OID_SHA256:
-+                sigAlg = CSSM_ALGID_SHA256WithRSA;
-+                break;
-+            case SEC_OID_SHA384:
-+                sigAlg = CSSM_ALGID_SHA384WithRSA;
-+                break;
-+            case SEC_OID_SHA512:
-+                sigAlg = CSSM_ALGID_SHA512WithRSA;
-+                break;
-+            default:
-+                PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-+                goto done;
-+        }
-+    }
-+
-     switch (keyType) {
-         case rsaKey:
--            PORT_Assert(sigAlg == CSSM_ALGID_RSA);
--            hashData.Data   = hash->md5;
--            hashData.Length = sizeof(SSL3Hashes);
-+            hashData.Data   = hash->u.raw;
-+            hashData.Length = hash->len;
-             break;
-         case dsaKey:
-         case ecKey:
-@@ -483,8 +561,13 @@
-                 PORT_Assert(sigAlg == CSSM_ALGID_DSA);
-                 doDerEncode = isTLS;
-             }
--            hashData.Data   = hash->sha;
--            hashData.Length = sizeof(hash->sha);
-+            if (hash->hashAlg == SEC_OID_UNKNOWN) {
-+                hashData.Data   = hash->u.s.sha;
-+                hashData.Length = sizeof(hash->u.s.sha);
-+            } else {
-+                hashData.Data   = hash->u.raw;
-+                hashData.Length = hash->len;
-+            }
-             break;
-         default:
-             PORT_SetError(SEC_ERROR_INVALID_KEY);
-Index: net/third_party/nss/ssl/ssl3ecc.c
-===================================================================
---- net/third_party/nss/ssl/ssl3ecc.c	(revision 202696)
-+++ net/third_party/nss/ssl/ssl3ecc.c	(working copy)
-@@ -31,6 +31,12 @@
- 
- #include <stdio.h>
- 
-+/* This is a bodge to allow this code to be compiled against older NSS headers
-+ * that don't contain the TLS 1.2 changes. */
-+#ifndef CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256
-+#define CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256 (CKM_NSS + 24)
-+#endif
-+
- #ifdef NSS_ENABLE_ECC
- 
- /*
-Index: net/third_party/nss/ssl/sslsock.c
-===================================================================
---- net/third_party/nss/ssl/sslsock.c	(revision 202696)
-+++ net/third_party/nss/ssl/sslsock.c	(working copy)
-@@ -18,8 +18,15 @@
- #ifndef NO_PKCS11_BYPASS
- #include "blapi.h"
- #endif
-+#include "pk11pub.h"
- #include "nss.h"
- 
-+/* This is a bodge to allow this code to be compiled against older NSS headers
-+ * that don't contain the TLS 1.2 changes. */
-+#ifndef CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256
-+#define CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256 (CKM_NSS + 24)
-+#endif
-+
- #define SET_ERROR_CODE   /* reminder */
- 
- struct cipherPolicyStr {
-@@ -1895,6 +1913,24 @@
-     return SECSuccess;
- }
- 
-+static PRCallOnceType checkTLS12TokenOnce;
-+static PRBool tls12TokenExists;
-+
-+static PRStatus  
-+ssl_CheckTLS12Token(void)
-+{
-+    tls12TokenExists =
-+	PK11_TokenExists(CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256);
-+    return PR_SUCCESS;
-+}
-+
-+static PRBool
-+ssl_TLS12TokenExists(void)
-+{
-+    (void) PR_CallOnce(&checkTLS12TokenOnce, ssl_CheckTLS12Token);
-+    return tls12TokenExists;
-+}
-+
- SECStatus
- SSL_VersionRangeSet(PRFileDesc *fd, const SSLVersionRange *vrange)
- {
-@@ -1915,6 +1951,24 @@
-     ssl_GetSSL3HandshakeLock(ss);
- 
-     ss->vrange = *vrange;
-+    /* If we don't have a sufficiently up-to-date softoken then we cannot do
-+     * TLS 1.2. */
-+    if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2 &&
-+        !ssl_TLS12TokenExists()) {
-+	/* If the user requested a minimum version of 1.2, then we don't
-+	 * silently downgrade. */
-+	if (ss->vrange.min >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	    ssl_ReleaseSSL3HandshakeLock(ss);
-+	    ssl_Release1stHandshakeLock(ss);
-+	    PORT_SetError(SSL_ERROR_INVALID_VERSION_RANGE);
-+	    return SECFailure;
-+	}
-+	ss->vrange.max = SSL_LIBRARY_VERSION_TLS_1_1;
-+    }
-+    /* PKCS#11 bypass is not supported with TLS 1.2. */
-+    if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	ss->opt.bypassPKCS11 = PR_FALSE;
-+    }
- 
-     ssl_ReleaseSSL3HandshakeLock(ss);
-     ssl_Release1stHandshakeLock(ss);
-Index: net/third_party/nss/ssl/ssl3con.c
-===================================================================
---- net/third_party/nss/ssl/ssl3con.c	(revision 202696)
-+++ net/third_party/nss/ssl/ssl3con.c	(working copy)
-@@ -31,6 +32,15 @@
- #include "blapi.h"
- #endif
- 
-+/* This is a bodge to allow this code to be compiled against older NSS headers
-+ * that don't contain the TLS 1.2 changes. */
-+#ifndef CKM_NSS_TLS_PRF_GENERAL_SHA256
-+#define CKM_NSS_TLS_PRF_GENERAL_SHA256          (CKM_NSS + 21)
-+#define CKM_NSS_TLS_MASTER_KEY_DERIVE_SHA256    (CKM_NSS + 22)
-+#define CKM_NSS_TLS_KEY_AND_MAC_DERIVE_SHA256   (CKM_NSS + 23)
-+#define CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256 (CKM_NSS + 24)
-+#endif
-+
- #include <stdio.h>
- #ifdef NSS_ENABLE_ZLIB
- #include "zlib.h"
-@@ -5360,16 +5737,18 @@
-     }
- 
-     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-+    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-     if (ss->ssl3.platformClientKey) {
- #ifdef NSS_PLATFORM_CLIENT_AUTH
-+	keyType = CERT_GetCertKeyType(
-+	    &ss->ssl3.clientCertificate->subjectPublicKeyInfo);
- 	rv = ssl3_PlatformSignHashes(
--	    &hashes, ss->ssl3.platformClientKey, &buf, isTLS,
--	    CERT_GetCertKeyType(
--		&ss->ssl3.clientCertificate->subjectPublicKeyInfo));
-+	    &hashes, ss->ssl3.platformClientKey, &buf, isTLS, keyType);
- 	ssl_FreePlatformKey(ss->ssl3.platformClientKey);
- 	ss->ssl3.platformClientKey = (PlatformKey)NULL;
- #endif /* NSS_PLATFORM_CLIENT_AUTH */
-     } else {
-+	keyType = ss->ssl3.clientPrivateKey->keyType;
- 	rv = ssl3_SignHashes(&hashes, ss->ssl3.clientPrivateKey, &buf, isTLS);
- 	if (rv == SECSuccess) {
- 	    PK11SlotInfo * slot;
-@@ -9409,9 +9978,10 @@
-     pub_bytes = spki->data + sizeof(P256_SPKI_PREFIX);
- 
-     memcpy(signed_data, CHANNEL_ID_MAGIC, sizeof(CHANNEL_ID_MAGIC));
--    memcpy(signed_data + sizeof(CHANNEL_ID_MAGIC), &hashes, sizeof(hashes));
-+    memcpy(signed_data + sizeof(CHANNEL_ID_MAGIC), hashes.u.raw, hashes.len);
- 
--    rv = PK11_HashBuf(SEC_OID_SHA256, digest, signed_data, sizeof(signed_data));
-+    rv = PK11_HashBuf(SEC_OID_SHA256, digest, signed_data,
-+		      sizeof(CHANNEL_ID_MAGIC) + hashes.len);
-     if (rv != SECSuccess)
- 	goto loser;
- 
diff --git a/src/net/third_party/nss/patches/tls12handshakehashes.patch b/src/net/third_party/nss/patches/tls12handshakehashes.patch
deleted file mode 100644
index a0a79cf..0000000
--- a/src/net/third_party/nss/patches/tls12handshakehashes.patch
+++ /dev/null
@@ -1,814 +0,0 @@
-Index: net/third_party/nss/ssl/derive.c
-===================================================================
---- net/third_party/nss/ssl/derive.c	(revision 206496)
-+++ net/third_party/nss/ssl/derive.c	(working copy)
-@@ -82,9 +82,11 @@
-     unsigned int    effKeySize;		/* effective size of cipher keys */
-     unsigned int    macSize;		/* size of MAC secret */
-     unsigned int    IVSize;		/* size of IV */
-+    PRBool          explicitIV = PR_FALSE;
-     SECStatus       rv    = SECFailure;
-     SECStatus       status = SECSuccess;
-     PRBool          isFIPS = PR_FALSE;
-+    PRBool          isTLS12 = pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2;
- 
-     SECItem         srcr;
-     SECItem         crsr;
-@@ -116,7 +118,13 @@
-     if (keySize == 0) {
- 	effKeySize = IVSize = 0; /* only MACing */
-     }
--    block_needed = 2 * (macSize + effKeySize + ((!isExport) * IVSize));
-+    if (cipher_def->type == type_block &&
-+	pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_1) {
-+	/* Block ciphers in >= TLS 1.1 use a per-record, explicit IV. */
-+	explicitIV = PR_TRUE;
-+    }
-+    block_needed =
-+	2 * (macSize + effKeySize + ((!isExport && !explicitIV) * IVSize));
- 
-     /*
-      * clear out our returned keys so we can recover on failure
-@@ -151,8 +159,13 @@
- 	keyblk.data = key_block;
- 	keyblk.len  = block_needed;
- 
--	status = TLS_PRF(&pwSpec->msItem, "key expansion", &srcr, &keyblk,
--			  isFIPS);
-+	if (isTLS12) {
-+	    status = TLS_P_hash(HASH_AlgSHA256, &pwSpec->msItem,
-+				"key expansion", &srcr, &keyblk, isFIPS);
-+	} else {
-+	    status = TLS_PRF(&pwSpec->msItem, "key expansion", &srcr, &keyblk,
-+			     isFIPS);
-+	}
- 	if (status != SECSuccess) {
- 	    goto key_and_mac_derive_fail;
- 	}
-@@ -240,22 +253,34 @@
- 	i += keySize;
- 
- 	if (IVSize > 0) {
--	    /* 
--	    ** client_write_IV[CipherSpec.IV_size]
--	    */
--	    buildSSLKey(&key_block[i], IVSize, &pwSpec->client.write_iv_item, \
--	                "Domestic Client Write IV");
--	    i += IVSize;
-+	    if (explicitIV) {
-+		static unsigned char zero_block[32];
-+		PORT_Assert(IVSize <= sizeof zero_block);
-+		buildSSLKey(&zero_block[0], IVSize, \
-+			    &pwSpec->client.write_iv_item, \
-+			    "Domestic Client Write IV");
-+		buildSSLKey(&zero_block[0], IVSize, \
-+			    &pwSpec->server.write_iv_item, \
-+			    "Domestic Server Write IV");
-+	    } else {
-+		/* 
-+		** client_write_IV[CipherSpec.IV_size]
-+		*/
-+		buildSSLKey(&key_block[i], IVSize, \
-+			    &pwSpec->client.write_iv_item, \
-+			    "Domestic Client Write IV");
-+		i += IVSize;
- 
--	    /* 
--	    ** server_write_IV[CipherSpec.IV_size]
--	    */
--	    buildSSLKey(&key_block[i], IVSize, &pwSpec->server.write_iv_item, \
--	                "Domestic Server Write IV");
--	    i += IVSize;
-+		/* 
-+		** server_write_IV[CipherSpec.IV_size]
-+		*/
-+		buildSSLKey(&key_block[i], IVSize, \
-+			    &pwSpec->server.write_iv_item, \
-+			    "Domestic Server Write IV");
-+		i += IVSize;
-+	    }
- 	}
- 	PORT_Assert(i <= block_bytes);
--
-     } else if (!isTLS) { 
- 	/*
- 	** Generate SSL3 Export write keys and IVs.
-@@ -418,6 +443,7 @@
-     unsigned char * key_block    = pwSpec->key_block;
-     SECStatus       rv    = SECSuccess;
-     PRBool          isFIPS = PR_FALSE;
-+    PRBool          isTLS12 = pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2;
- 
-     SECItem         crsr;
- 
-@@ -453,7 +479,12 @@
- 	master.data = key_block;
- 	master.len = SSL3_MASTER_SECRET_LENGTH;
- 
--	rv = TLS_PRF(pms, "master secret", &crsr, &master, isFIPS);
-+	if (isTLS12) {
-+	    rv = TLS_P_hash(HASH_AlgSHA256, pms, "master secret", &crsr,
-+			    &master, isFIPS);
-+	} else {
-+	    rv = TLS_PRF(pms, "master secret", &crsr, &master, isFIPS);
-+	}
- 	if (rv != SECSuccess) {
- 	    PORT_SetError(SSL_ERROR_SESSION_KEY_GEN_FAILURE);
- 	}
-Index: net/third_party/nss/ssl/sslsock.c
-===================================================================
---- net/third_party/nss/ssl/sslsock.c	(revision 206496)
-+++ net/third_party/nss/ssl/sslsock.c	(working copy)
-@@ -796,10 +796,7 @@
- 	    rv = SECFailure;
- 	} else {
-             if (PR_FALSE != on) {
--                /* PKCS#11 bypass is not supported with TLS 1.2. */
--                if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2) {
--                    ss->opt.bypassPKCS11 = PR_FALSE;
--                } else if (PR_SUCCESS == SSL_BypassSetup() ) {
-+                if (PR_SUCCESS == SSL_BypassSetup() ) {
- #ifdef NO_PKCS11_BYPASS
-                     ss->opt.bypassPKCS11 = PR_FALSE;
- #else
-@@ -1964,10 +1961,6 @@
- 	}
- 	ss->vrange.max = SSL_LIBRARY_VERSION_TLS_1_1;
-     }
--    /* PKCS#11 bypass is not supported with TLS 1.2. */
--    if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2) {
--	ss->opt.bypassPKCS11 = PR_FALSE;
--    }
- 
-     ssl_ReleaseSSL3HandshakeLock(ss);
-     ssl_Release1stHandshakeLock(ss);
-Index: net/third_party/nss/ssl/ssl3con.c
-===================================================================
---- net/third_party/nss/ssl/ssl3con.c	(revision 206496)
-+++ net/third_party/nss/ssl/ssl3con.c	(working copy)
-@@ -69,7 +69,6 @@
- static SECStatus ssl3_SendServerHello(       sslSocket *ss);
- static SECStatus ssl3_SendServerHelloDone(   sslSocket *ss);
- static SECStatus ssl3_SendServerKeyExchange( sslSocket *ss);
--static SECStatus ssl3_NewHandshakeHashes(    sslSocket *ss);
- static SECStatus ssl3_UpdateHandshakeHashes( sslSocket *ss,
-                                              const unsigned char *b,
-                                              unsigned int l);
-@@ -1072,6 +1071,9 @@
- 	} else if (hashAlg == SEC_OID_SHA384) {
- 	    SHA384_HashBuf(hashes->u.raw, hashBuf, bufLen);
- 	    hashes->len = SHA384_LENGTH;
-+	} else if (hashAlg == SEC_OID_SHA512) {
-+	    SHA512_HashBuf(hashes->u.raw, hashBuf, bufLen);
-+	    hashes->len = SHA512_LENGTH;
- 	} else {
- 	    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
- 	    return SECFailure;
-@@ -1535,7 +1537,8 @@
- }
- 
- #ifndef NO_PKCS11_BYPASS
--/* Initialize encryption and MAC contexts for pending spec.
-+/* Initialize encryption contexts for pending spec.
-+ * MAC contexts are set up when computing the mac, not here.
-  * Master Secret already is derived in spec->msItem
-  * Caller holds Spec write lock.
-  */
-@@ -1551,7 +1554,6 @@
-       unsigned int       optArg1  = 0;
-       unsigned int       optArg2  = 0;
-       PRBool             server_encrypts = ss->sec.isServer;
--      CK_ULONG           macLength;
-       SSLCipherAlgorithm calg;
-       SSLCompressionMethod compression_method;
-       SECStatus          rv;
-@@ -1562,12 +1564,7 @@
- 
-     pwSpec        = ss->ssl3.pwSpec;
-     cipher_def    = pwSpec->cipher_def;
--    macLength     = pwSpec->mac_size;
- 
--    /* MAC setup is done when computing the mac, not here.
--     * Now setup the crypto contexts.
--     */
--
-     calg = cipher_def->calg;
-     compression_method = pwSpec->compression_method;
- 
-@@ -3459,18 +3456,6 @@
- 	 */
- 	rv = PK11_ExtractKeyValue(pwSpec->master_secret);
- 	if (rv != SECSuccess) {
--#if defined(NSS_SURVIVE_DOUBLE_BYPASS_FAILURE)
--	    /* The double bypass failed.  
--	     * Attempt to revert to an all PKCS#11, non-bypass method.
--	     * Do we need any unacquired locks here?
--	     */
--	    ss->opt.bypassPKCS11 = 0;
--	    rv = ssl3_NewHandshakeHashes(ss);
--	    if (rv == SECSuccess) {
--		rv = ssl3_UpdateHandshakeHashes(ss, ss->ssl3.hs.messages.buf, 
--		                                    ss->ssl3.hs.messages.len);
--	    }
--#endif
- 	    return rv;
- 	} 
- 	/* This returns the address of the secItem inside the key struct,
-@@ -3640,34 +3625,90 @@
-     return SECFailure;
- }
- 
--/* ssl3_InitTLS12HandshakeHash creates a handshake hash context for TLS 1.2,
-- * if needed, and hashes in any buffered messages in ss->ssl3.hs.messages. */
-+/* ssl3_InitHandshakeHashes creates handshake hash contexts and hashes in
-+ * buffered messages in ss->ssl3.hs.messages. */
- static SECStatus
--ssl3_InitTLS12HandshakeHash(sslSocket *ss)
-+ssl3_InitHandshakeHashes(sslSocket *ss)
- {
--    if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_2 &&
--	ss->ssl3.hs.tls12_handshake_hash == NULL) {
--	/* If we ever support ciphersuites where the PRF hash isn't SHA-256
--	 * then this will need to be updated. */
--	ss->ssl3.hs.tls12_handshake_hash =
--	    PK11_CreateDigestContext(SEC_OID_SHA256);
--	if (!ss->ssl3.hs.tls12_handshake_hash ||
--	    PK11_DigestBegin(ss->ssl3.hs.tls12_handshake_hash) != SECSuccess) {
--	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
--	    return SECFailure;
-+    SSL_TRC(30,("%d: SSL3[%d]: start handshake hashes", SSL_GETPID(), ss->fd));
-+
-+    PORT_Assert(ss->ssl3.hs.hashType == handshake_hash_unknown);
-+#ifndef NO_PKCS11_BYPASS
-+    if (ss->opt.bypassPKCS11) {
-+	PORT_Assert(!ss->ssl3.hs.sha_obj && !ss->ssl3.hs.sha_clone);
-+	if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	    /* If we ever support ciphersuites where the PRF hash isn't SHA-256
-+	     * then this will need to be updated. */
-+	    ss->ssl3.hs.sha_obj = HASH_GetRawHashObject(HASH_AlgSHA256);
-+	    if (!ss->ssl3.hs.sha_obj) {
-+		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
-+	    ss->ssl3.hs.sha_clone = (void (*)(void *, void *))SHA256_Clone;
-+	    ss->ssl3.hs.hashType = handshake_hash_single;
-+	    ss->ssl3.hs.sha_obj->begin(ss->ssl3.hs.sha_cx);
-+	} else {
-+	    ss->ssl3.hs.hashType = handshake_hash_combo;
-+	    MD5_Begin((MD5Context *)ss->ssl3.hs.md5_cx);
-+	    SHA1_Begin((SHA1Context *)ss->ssl3.hs.sha_cx);
- 	}
--    }
-+    } else
-+#endif
-+    {
-+	PORT_Assert(!ss->ssl3.hs.md5 && !ss->ssl3.hs.sha);
-+	/*
-+	 * note: We should probably lookup an SSL3 slot for these
-+	 * handshake hashes in hopes that we wind up with the same slots
-+	 * that the master secret will wind up in ...
-+	 */
-+	if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	    /* If we ever support ciphersuites where the PRF hash isn't SHA-256
-+	     * then this will need to be updated. */
-+	    ss->ssl3.hs.sha = PK11_CreateDigestContext(SEC_OID_SHA256);
-+	    if (ss->ssl3.hs.sha == NULL) {
-+		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
-+	    ss->ssl3.hs.hashType = handshake_hash_single;
- 
--    if (ss->ssl3.hs.tls12_handshake_hash && ss->ssl3.hs.messages.len > 0) {
--	if (PK11_DigestOp(ss->ssl3.hs.tls12_handshake_hash,
--			  ss->ssl3.hs.messages.buf,
--			  ss->ssl3.hs.messages.len) != SECSuccess) {
--	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
--	    return SECFailure;
-+	    if (PK11_DigestBegin(ss->ssl3.hs.sha) != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
-+	} else {
-+	    /* Both ss->ssl3.hs.md5 and ss->ssl3.hs.sha should be NULL or
-+	     * created successfully. */
-+	    ss->ssl3.hs.md5 = PK11_CreateDigestContext(SEC_OID_MD5);
-+	    if (ss->ssl3.hs.md5 == NULL) {
-+		ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
-+	    ss->ssl3.hs.sha = PK11_CreateDigestContext(SEC_OID_SHA1);
-+	    if (ss->ssl3.hs.sha == NULL) {
-+		PK11_DestroyContext(ss->ssl3.hs.md5, PR_TRUE);
-+		ss->ssl3.hs.md5 = NULL;
-+		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
-+	    ss->ssl3.hs.hashType = handshake_hash_combo;
-+
-+	    if (PK11_DigestBegin(ss->ssl3.hs.md5) != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
-+	    if (PK11_DigestBegin(ss->ssl3.hs.sha) != SECSuccess) {
-+		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-+		return SECFailure;
-+	    }
- 	}
-     }
- 
--    if (ss->ssl3.hs.messages.buf && !ss->opt.bypassPKCS11) {
-+    if (ss->ssl3.hs.messages.len > 0) {
-+	if (ssl3_UpdateHandshakeHashes(ss, ss->ssl3.hs.messages.buf,
-+				       ss->ssl3.hs.messages.len) !=
-+	    SECSuccess) {
-+	    return SECFailure;
-+	}
- 	PORT_Free(ss->ssl3.hs.messages.buf);
- 	ss->ssl3.hs.messages.buf = NULL;
- 	ss->ssl3.hs.messages.len = 0;
-@@ -3682,83 +3723,30 @@
- {
-     SECStatus rv = SECSuccess;
- 
-+    SSL_TRC(30,("%d: SSL3[%d]: reset handshake hashes",
-+	    SSL_GETPID(), ss->fd ));
-+    ss->ssl3.hs.hashType = handshake_hash_unknown;
-     ss->ssl3.hs.messages.len = 0;
- #ifndef NO_PKCS11_BYPASS
--    if (ss->opt.bypassPKCS11) {
--	MD5_Begin((MD5Context *)ss->ssl3.hs.md5_cx);
--	SHA1_Begin((SHA1Context *)ss->ssl3.hs.sha_cx);
--    } else 
-+    ss->ssl3.hs.sha_obj = NULL;
-+    ss->ssl3.hs.sha_clone = NULL;
- #endif
--    {
--	if (ss->ssl3.hs.tls12_handshake_hash) {
--	    rv = PK11_DigestBegin(ss->ssl3.hs.tls12_handshake_hash);
--	    if (rv != SECSuccess) {
--		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
--		return rv;
--	    }
--	}
--	rv = PK11_DigestBegin(ss->ssl3.hs.md5);
--	if (rv != SECSuccess) {
--	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
--	    return rv;
--	}
--	rv = PK11_DigestBegin(ss->ssl3.hs.sha);
--	if (rv != SECSuccess) {
--	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
--	    return rv;
--	}
--    }
--    return rv;
--}
--
--static SECStatus
--ssl3_NewHandshakeHashes(sslSocket *ss)
--{
--    PK11Context *md5  = NULL;
--    PK11Context *sha  = NULL;
--
--    /*
--     * note: We should probably lookup an SSL3 slot for these
--     * handshake hashes in hopes that we wind up with the same slots
--     * that the master secret will wind up in ...
--     */
--    SSL_TRC(30,("%d: SSL3[%d]: start handshake hashes", SSL_GETPID(), ss->fd));
--    PORT_Assert(!ss->ssl3.hs.messages.buf && !ss->ssl3.hs.messages.space);
--    ss->ssl3.hs.messages.buf = NULL;
--    ss->ssl3.hs.messages.space = 0;
--
--    ss->ssl3.hs.md5 = md5 = PK11_CreateDigestContext(SEC_OID_MD5);
--    ss->ssl3.hs.sha = sha = PK11_CreateDigestContext(SEC_OID_SHA1);
--    ss->ssl3.hs.tls12_handshake_hash = NULL;
--    if (md5 == NULL) {
--	ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
--	goto loser;
--    }
--    if (sha == NULL) {
--	ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
--	goto loser;
--    }
--    if (SECSuccess == ssl3_RestartHandshakeHashes(ss)) {
--	return SECSuccess;
--    }
--
--loser:
--    if (md5 != NULL) {
--    	PK11_DestroyContext(md5, PR_TRUE);
-+    if (ss->ssl3.hs.md5) {
-+	PK11_DestroyContext(ss->ssl3.hs.md5,PR_TRUE);
- 	ss->ssl3.hs.md5 = NULL;
-     }
--    if (sha != NULL) {
--    	PK11_DestroyContext(sha, PR_TRUE);
-+    if (ss->ssl3.hs.sha) {
-+	PK11_DestroyContext(ss->ssl3.hs.sha,PR_TRUE);
- 	ss->ssl3.hs.sha = NULL;
-     }
--    return SECFailure;
--
-+    return rv;
- }
- 
- /*
-  * Handshake messages
-  */
--/* Called from	ssl3_AppendHandshake()
-+/* Called from	ssl3_InitHandshakeHashes()
-+**		ssl3_AppendHandshake()
- **		ssl3_StartHandshakeHash()
- **		ssl3_HandleV2ClientHello()
- **		ssl3_HandleHandshakeMessage()
-@@ -3772,31 +3760,27 @@
- 
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
- 
--    PRINT_BUF(90, (NULL, "MD5 & SHA handshake hash input:", b, l));
--
--    if ((ss->version == 0 || ss->version >= SSL_LIBRARY_VERSION_TLS_1_2) &&
--	!ss->opt.bypassPKCS11 &&
--	ss->ssl3.hs.tls12_handshake_hash == NULL) {
--	/* For TLS 1.2 connections we need to buffer the handshake messages
--	 * until we have established which PRF hash function to use. */
--	rv = sslBuffer_Append(&ss->ssl3.hs.messages, b, l);
--	if (rv != SECSuccess) {
--	    return rv;
--	}
-+    /* We need to buffer the handshake messages until we have established
-+     * which handshake hash function to use. */
-+    if (ss->ssl3.hs.hashType == handshake_hash_unknown) {
-+	return sslBuffer_Append(&ss->ssl3.hs.messages, b, l);
-     }
- 
-+    PRINT_BUF(90, (NULL, "handshake hash input:", b, l));
-+
- #ifndef NO_PKCS11_BYPASS
-     if (ss->opt.bypassPKCS11) {
--	MD5_Update((MD5Context *)ss->ssl3.hs.md5_cx, b, l);
--	SHA1_Update((SHA1Context *)ss->ssl3.hs.sha_cx, b, l);
--#if defined(NSS_SURVIVE_DOUBLE_BYPASS_FAILURE)
--	rv = sslBuffer_Append(&ss->ssl3.hs.messages, b, l);
--#endif
-+	if (ss->ssl3.hs.hashType == handshake_hash_single) {
-+	    ss->ssl3.hs.sha_obj->update(ss->ssl3.hs.sha_cx, b, l);
-+	} else {
-+	    MD5_Update((MD5Context *)ss->ssl3.hs.md5_cx, b, l);
-+	    SHA1_Update((SHA1Context *)ss->ssl3.hs.sha_cx, b, l);
-+	}
- 	return rv;
-     }
- #endif
--    if (ss->ssl3.hs.tls12_handshake_hash) {
--	rv = PK11_DigestOp(ss->ssl3.hs.tls12_handshake_hash, b, l);
-+    if (ss->ssl3.hs.hashType == handshake_hash_single) {
-+	rv = PK11_DigestOp(ss->ssl3.hs.sha, b, l);
- 	if (rv != SECSuccess) {
- 	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
- 	    return rv;
-@@ -3924,10 +3908,6 @@
- 
-     SSL_TRC(30,("%d: SSL3[%d]: append handshake header: type %s",
-     	SSL_GETPID(), ss->fd, ssl3_DecodeHandshakeType(t)));
--    PRINT_BUF(60, (ss, "MD5 handshake hash:",
--    	          (unsigned char*)ss->ssl3.hs.md5_cx, MD5_LENGTH));
--    PRINT_BUF(95, (ss, "SHA handshake hash:",
--    	          (unsigned char*)ss->ssl3.hs.sha_cx, SHA1_LENGTH));
- 
-     rv = ssl3_AppendHandshakeNumber(ss, t, 1);
-     if (rv != SECSuccess) {
-@@ -4275,8 +4255,28 @@
-     hashes->hashAlg = SEC_OID_UNKNOWN;
- 
- #ifndef NO_PKCS11_BYPASS
--    if (ss->opt.bypassPKCS11) {
-+    if (ss->opt.bypassPKCS11 &&
-+	ss->ssl3.hs.hashType == handshake_hash_single) {
- 	/* compute them without PKCS11 */
-+	PRUint64      sha_cx[MAX_MAC_CONTEXT_LLONGS];
-+
-+	if (!spec->msItem.data) {
-+	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_HANDSHAKE);
-+	    return SECFailure;
-+	}
-+
-+	ss->ssl3.hs.sha_clone(sha_cx, ss->ssl3.hs.sha_cx);
-+	ss->ssl3.hs.sha_obj->end(sha_cx, hashes->u.raw, &hashes->len,
-+				 sizeof(hashes->u.raw));
-+
-+	PRINT_BUF(60, (NULL, "SHA-256: result", hashes->u.raw, hashes->len));
-+
-+	/* If we ever support ciphersuites where the PRF hash isn't SHA-256
-+	 * then this will need to be updated. */
-+	hashes->hashAlg = SEC_OID_SHA256;
-+	rv = SECSuccess;
-+    } else if (ss->opt.bypassPKCS11) {
-+	/* compute them without PKCS11 */
- 	PRUint64      md5_cx[MAX_MAC_CONTEXT_LLONGS];
- 	PRUint64      sha_cx[MAX_MAC_CONTEXT_LLONGS];
- 
-@@ -4360,7 +4360,8 @@
- #undef shacx
-     } else 
- #endif
--    if (ss->ssl3.hs.tls12_handshake_hash) {
-+    if (ss->ssl3.hs.hashType == handshake_hash_single) {
-+	/* compute hashes with PKCS11 */
- 	PK11Context *h;
- 	unsigned int  stateLen;
- 	unsigned char stackBuf[1024];
-@@ -4371,7 +4372,7 @@
- 	    return SECFailure;
- 	}
- 
--	h = ss->ssl3.hs.tls12_handshake_hash;
-+	h = ss->ssl3.hs.sha;
- 	stateBuf = PK11_SaveContextAlloc(h, stackBuf,
- 					 sizeof(stackBuf), &stateLen);
- 	if (stateBuf == NULL) {
-@@ -4392,8 +4393,7 @@
- 
- tls12_loser:
- 	if (stateBuf) {
--	    if (PK11_RestoreContext(ss->ssl3.hs.tls12_handshake_hash, stateBuf,
--				    stateLen) != SECSuccess) {
-+	    if (PK11_RestoreContext(h, stateBuf, stateLen) != SECSuccess) {
- 		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
- 		rv = SECFailure;
- 	    }
-@@ -4402,7 +4402,7 @@
- 	    }
- 	}
-     } else {
--	/* compute hases with PKCS11 */
-+	/* compute hashes with PKCS11 */
- 	PK11Context * md5;
- 	PK11Context * sha       = NULL;
- 	unsigned char *md5StateBuf = NULL;
-@@ -4567,6 +4567,10 @@
-     if (rv != SECSuccess) {
- 	goto done;		/* ssl3_InitState has set the error code. */
-     }
-+    rv = ssl3_RestartHandshakeHashes(ss);
-+    if (rv != SECSuccess) {
-+	goto done;
-+    }
- 
-     PORT_Memset(&ss->ssl3.hs.client_random, 0, SSL3_RANDOM_LENGTH);
-     PORT_Memcpy(
-@@ -4626,8 +4630,6 @@
-      */
-     PORT_Memset(&ss->xtnData, 0, sizeof(TLSExtensionData));
- 
--    SSL_TRC(30,("%d: SSL3[%d]: reset handshake hashes",
--	    SSL_GETPID(), ss->fd ));
-     rv = ssl3_RestartHandshakeHashes(ss);
-     if (rv != SECSuccess) {
- 	return rv;
-@@ -5897,12 +5899,8 @@
-     	SSL_GETPID(), ss->fd));
-     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-+    PORT_Assert( ss->ssl3.initialized );
- 
--    rv = ssl3_InitState(ss);
--    if (rv != SECSuccess) {
--	errCode = PORT_GetError(); /* ssl3_InitState has set the error code. */
--	goto alert_loser;
--    }
-     if (ss->ssl3.hs.ws != wait_server_hello) {
-         errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_HELLO;
- 	desc    = unexpected_message;
-@@ -5970,7 +5968,7 @@
-     }
-     isTLS = (ss->version > SSL_LIBRARY_VERSION_3_0);
- 
--    rv = ssl3_InitTLS12HandshakeHash(ss);
-+    rv = ssl3_InitHandshakeHashes(ss);
-     if (rv != SECSuccess) {
- 	desc = internal_error;
- 	errCode = PORT_GetError();
-@@ -7308,6 +7306,7 @@
- 
-     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
-+    PORT_Assert( ss->ssl3.initialized );
- 
-     /* Get peer name of client */
-     rv = ssl_GetPeerInfo(ss);
-@@ -7335,11 +7334,6 @@
-     PORT_Memset(&ss->xtnData, 0, sizeof(TLSExtensionData));
-     ss->statelessResume = PR_FALSE;
- 
--    rv = ssl3_InitState(ss);
--    if (rv != SECSuccess) {
--	return rv;		/* ssl3_InitState has set the error code. */
--    }
--
-     if ((ss->ssl3.hs.ws != wait_client_hello) &&
- 	(ss->ssl3.hs.ws != idle_handshake)) {
- 	desc    = unexpected_message;
-@@ -7378,7 +7372,7 @@
- 	goto alert_loser;
-     }
- 
--    rv = ssl3_InitTLS12HandshakeHash(ss);
-+    rv = ssl3_InitHandshakeHashes(ss);
-     if (rv != SECSuccess) {
- 	desc = internal_error;
- 	errCode = PORT_GetError();
-@@ -8106,6 +8100,11 @@
- 	ssl_ReleaseSSL3HandshakeLock(ss);
- 	return rv;		/* ssl3_InitState has set the error code. */
-     }
-+    rv = ssl3_RestartHandshakeHashes(ss);
-+    if (rv != SECSuccess) {
-+	ssl_ReleaseSSL3HandshakeLock(ss);
-+	return rv;
-+    }
- 
-     if (ss->ssl3.hs.ws != wait_client_hello) {
- 	desc    = unexpected_message;
-@@ -8127,7 +8126,7 @@
- 	goto alert_loser;
-     }
- 
--    rv = ssl3_InitTLS12HandshakeHash(ss);
-+    rv = ssl3_InitHandshakeHashes(ss);
-     if (rv != SECSuccess) {
- 	desc = internal_error;
- 	errCode = PORT_GetError();
-@@ -8858,6 +8857,7 @@
- 
-     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-+    PORT_Assert( ss->ssl3.prSpec == ss->ssl3.pwSpec );
- 
-     enc_pms.data = b;
-     enc_pms.len  = length;
-@@ -9886,7 +9886,12 @@
- 	inData.len   = valLen;
- 	outData.data = out;
- 	outData.len  = outLen;
--	rv = TLS_PRF(&spec->msItem, label, &inData, &outData, isFIPS);
-+	if (spec->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+	    rv = TLS_P_hash(HASH_AlgSHA256, &spec->msItem, label, &inData,
-+			    &outData, isFIPS);
-+	} else {
-+	    rv = TLS_PRF(&spec->msItem, label, &inData, &outData, isFIPS);
-+	}
- 	PORT_Assert(rv != SECSuccess || outData.len == outLen);
- #endif
-     }
-@@ -10560,10 +10565,6 @@
-     }
-     SSL_TRC(30,("%d: SSL3[%d]: handle handshake message: %s", SSL_GETPID(),
- 		ss->fd, ssl3_DecodeHandshakeType(ss->ssl3.hs.msg_type)));
--    PRINT_BUF(60, (ss, "MD5 handshake hash:",
--    	      (unsigned char*)ss->ssl3.hs.md5_cx, MD5_LENGTH));
--    PRINT_BUF(95, (ss, "SHA handshake hash:",
--    	      (unsigned char*)ss->ssl3.hs.sha_cx, SHA1_LENGTH));
- 
-     hdr[0] = (PRUint8)ss->ssl3.hs.msg_type;
-     hdr[1] = (PRUint8)(length >> 16);
-@@ -10572,8 +10573,6 @@
- 
-     /* Start new handshake hashes when we start a new handshake */
-     if (ss->ssl3.hs.msg_type == client_hello) {
--	SSL_TRC(30,("%d: SSL3[%d]: reset handshake hashes",
--		SSL_GETPID(), ss->fd ));
- 	rv = ssl3_RestartHandshakeHashes(ss);
- 	if (rv != SECSuccess) {
- 	    return rv;
-@@ -11526,8 +11525,6 @@
- /* Called from:	ssl3_SendRecord
- **		ssl3_StartHandshakeHash() <- ssl2_BeginClientHandshake()
- **		ssl3_SendClientHello()
--**		ssl3_HandleServerHello()
--**		ssl3_HandleClientHello()
- **		ssl3_HandleV2ClientHello()
- **		ssl3_HandleRecord()
- **
-@@ -11538,7 +11535,6 @@
- static SECStatus
- ssl3_InitState(sslSocket *ss)
- {
--    SECStatus    rv;
-     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
- 
-     if (ss->ssl3.initialized)
-@@ -11571,12 +11567,12 @@
- 	dtls_SetMTU(ss, 0); /* Set the MTU to the highest plateau */
-     }
- 
--    rv = ssl3_NewHandshakeHashes(ss);
--    if (rv == SECSuccess) {
--	ss->ssl3.initialized = PR_TRUE;
--    }
-+    PORT_Assert(!ss->ssl3.hs.messages.buf && !ss->ssl3.hs.messages.space);
-+    ss->ssl3.hs.messages.buf = NULL;
-+    ss->ssl3.hs.messages.space = 0;
- 
--    return rv;
-+    ss->ssl3.initialized = PR_TRUE;
-+    return SECSuccess;
- }
- 
- /* Returns a reference counted object that contains a key pair.
-@@ -11942,8 +11938,12 @@
-     /* clean up handshake */
- #ifndef NO_PKCS11_BYPASS
-     if (ss->opt.bypassPKCS11) {
--	SHA1_DestroyContext((SHA1Context *)ss->ssl3.hs.sha_cx, PR_FALSE);
--	MD5_DestroyContext((MD5Context *)ss->ssl3.hs.md5_cx, PR_FALSE);
-+	if (ss->ssl3.hs.hashType == handshake_hash_combo) {
-+	    SHA1_DestroyContext((SHA1Context *)ss->ssl3.hs.sha_cx, PR_FALSE);
-+	    MD5_DestroyContext((MD5Context *)ss->ssl3.hs.md5_cx, PR_FALSE);
-+	} else if (ss->ssl3.hs.hashType == handshake_hash_single) {
-+	    ss->ssl3.hs.sha_obj->destroy(ss->ssl3.hs.sha_cx, PR_FALSE);
-+	}
-     } 
- #endif
-     if (ss->ssl3.hs.md5) {
-@@ -11952,9 +11952,6 @@
-     if (ss->ssl3.hs.sha) {
- 	PK11_DestroyContext(ss->ssl3.hs.sha,PR_TRUE);
-     }
--    if (ss->ssl3.hs.tls12_handshake_hash) {
--	PK11_DestroyContext(ss->ssl3.hs.tls12_handshake_hash,PR_TRUE);
--    }
-     if (ss->ssl3.hs.clientSigAndHash) {
- 	PORT_Free(ss->ssl3.hs.clientSigAndHash);
-     }
-Index: net/third_party/nss/ssl/sslimpl.h
-===================================================================
---- net/third_party/nss/ssl/sslimpl.h	(revision 206496)
-+++ net/third_party/nss/ssl/sslimpl.h	(working copy)
-@@ -506,7 +506,9 @@
- 
- typedef void (*DTLSTimerCb)(sslSocket *);
- 
--#define MAX_MAC_CONTEXT_BYTES 400
-+#define MAX_MAC_CONTEXT_BYTES 400  /* 400 is large enough for MD5, SHA-1, and
-+                                    * SHA-256. For SHA-384 support, increase
-+                                    * it to 712. */
- #define MAX_MAC_CONTEXT_LLONGS (MAX_MAC_CONTEXT_BYTES / 8)
- 
- #define MAX_CIPHER_CONTEXT_BYTES 2080
-@@ -788,6 +790,12 @@
-     PRUint16 len;         /* The data length */
- } DTLSQueuedMessage;
- 
-+typedef enum {
-+    handshake_hash_unknown = 0,
-+    handshake_hash_combo = 1,  /* The MD5/SHA-1 combination */
-+    handshake_hash_single = 2  /* A single hash */
-+} SSL3HandshakeHashType;
-+
- /*
- ** This is the "hs" member of the "ssl3" struct.
- ** This entire struct is protected by ssl3HandshakeLock
-@@ -796,11 +804,31 @@
-     SSL3Random            server_random;
-     SSL3Random            client_random;
-     SSL3WaitState         ws;
-+
-+    /* This group of members is used for handshake running hashes. */
-+    SSL3HandshakeHashType hashType;
-+    sslBuffer             messages;    /* Accumulated handshake messages */
-+#ifndef NO_PKCS11_BYPASS
-+    /* Bypass mode:
-+     * SSL 3.0 - TLS 1.1 use both |md5_cx| and |sha_cx|. |md5_cx| is used for
-+     * MD5 and |sha_cx| for SHA-1.
-+     * TLS 1.2 and later use only |sha_cx|, for SHA-256. NOTE: When we support
-+     * SHA-384, increase MAX_MAC_CONTEXT_BYTES to 712. */
-     PRUint64              md5_cx[MAX_MAC_CONTEXT_LLONGS];
-     PRUint64              sha_cx[MAX_MAC_CONTEXT_LLONGS];
--    PK11Context *         md5;            /* handshake running hashes */
-+    const SECHashObject * sha_obj;
-+    /* The function prototype of sha_obj->clone() does not match the prototype
-+     * of the freebl <HASH>_Clone functions, so we need a dedicated function
-+     * pointer for the <HASH>_Clone function. */
-+    void (*sha_clone)(void *dest, void *src);
-+#endif
-+    /* PKCS #11 mode:
-+     * SSL 3.0 - TLS 1.1 use both |md5| and |sha|. |md5| is used for MD5 and
-+     * |sha| for SHA-1.
-+     * TLS 1.2 and later use only |sha|, for SHA-256. */
-+    PK11Context *         md5;
-     PK11Context *         sha;
--    PK11Context *         tls12_handshake_hash;
-+
- const ssl3KEADef *        kea_def;
-     ssl3CipherSuite       cipher_suite;
- const ssl3CipherSuiteDef *suite_def;
-@@ -818,7 +846,6 @@
-     PRBool                sendingSCSV; /* instead of empty RI */
-     sslBuffer             msgState;    /* current state for handshake messages*/
-                                        /* protected by recvBufLock */
--    sslBuffer             messages;    /* Accumulated handshake messages */
-     PRUint16              finishedBytes; /* size of single finished below */
-     union {
- 	TLSFinished       tFinished[2]; /* client, then server */
diff --git a/src/net/third_party/nss/patches/tls12hmacsha256.patch b/src/net/third_party/nss/patches/tls12hmacsha256.patch
deleted file mode 100644
index 1ec2189..0000000
--- a/src/net/third_party/nss/patches/tls12hmacsha256.patch
+++ /dev/null
@@ -1,472 +0,0 @@
-Index: net/third_party/nss/ssl/sslproto.h
-===================================================================
---- net/third_party/nss/ssl/sslproto.h	(revision 203497)
-+++ net/third_party/nss/ssl/sslproto.h	(working copy)
-@@ -134,6 +134,9 @@
- #define TLS_DHE_DSS_WITH_AES_256_CBC_SHA  	0x0038
- #define TLS_DHE_RSA_WITH_AES_256_CBC_SHA  	0x0039
- #define TLS_DH_ANON_WITH_AES_256_CBC_SHA  	0x003A
-+#define TLS_RSA_WITH_NULL_SHA256		0x003B
-+#define TLS_RSA_WITH_AES_128_CBC_SHA256  	0x003C
-+#define TLS_RSA_WITH_AES_256_CBC_SHA256  	0x003D
- 
- #define TLS_RSA_WITH_CAMELLIA_128_CBC_SHA      	0x0041
- #define TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA   	0x0042
-@@ -148,6 +151,8 @@
- #define TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA 0x0063
- #define TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA  0x0065
- #define TLS_DHE_DSS_WITH_RC4_128_SHA            0x0066
-+#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     0x0067
-+#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     0x006B
- 
- #define TLS_RSA_WITH_CAMELLIA_256_CBC_SHA      	0x0084
- #define TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA   	0x0085
-@@ -197,6 +202,9 @@
- #define TLS_ECDH_anon_WITH_AES_128_CBC_SHA      0xC018
- #define TLS_ECDH_anon_WITH_AES_256_CBC_SHA      0xC019
- 
-+#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 0xC023
-+#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   0xC027
-+
- /* Netscape "experimental" cipher suites. */
- #define SSL_RSA_OLDFIPS_WITH_3DES_EDE_CBC_SHA	0xffe0
- #define SSL_RSA_OLDFIPS_WITH_DES_CBC_SHA	0xffe1
-Index: net/third_party/nss/ssl/sslt.h
-===================================================================
---- net/third_party/nss/ssl/sslt.h	(revision 203497)
-+++ net/third_party/nss/ssl/sslt.h	(working copy)
-@@ -102,7 +102,8 @@
-     ssl_mac_md5       = 1, 
-     ssl_mac_sha       = 2, 
-     ssl_hmac_md5      = 3, 	/* TLS HMAC version of mac_md5 */
--    ssl_hmac_sha      = 4 	/* TLS HMAC version of mac_sha */
-+    ssl_hmac_sha      = 4, 	/* TLS HMAC version of mac_sha */
-+    ssl_hmac_sha256   = 5
- } SSLMACAlgorithm;
- 
- typedef enum {
-Index: net/third_party/nss/ssl/sslinfo.c
-===================================================================
---- net/third_party/nss/ssl/sslinfo.c	(revision 203497)
-+++ net/third_party/nss/ssl/sslinfo.c	(working copy)
-@@ -128,6 +128,7 @@
- #define B_40    128,  40,  40
- #define B_0  	  0,   0,   0
- 
-+#define M_SHA256 "SHA256", ssl_hmac_sha256, 256
- #define M_SHA	"SHA1", ssl_mac_sha, 160
- #define M_MD5	"MD5",  ssl_mac_md5, 128
- 
-@@ -135,20 +136,24 @@
- /* <------ Cipher suite --------------------> <auth> <KEA>  <bulk cipher> <MAC> <FIPS> */
- {0,CS(TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA), S_RSA, K_DHE, C_CAMELLIA, B_256, M_SHA, 0, 0, 0, },
- {0,CS(TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA), S_DSA, K_DHE, C_CAMELLIA, B_256, M_SHA, 0, 0, 0, },
-+{0,CS(TLS_DHE_RSA_WITH_AES_256_CBC_SHA256),   S_RSA, K_DHE, C_AES, B_256, M_SHA256, 1, 0, 0, },
- {0,CS(TLS_DHE_RSA_WITH_AES_256_CBC_SHA),      S_RSA, K_DHE, C_AES, B_256, M_SHA, 1, 0, 0, },
- {0,CS(TLS_DHE_DSS_WITH_AES_256_CBC_SHA),      S_DSA, K_DHE, C_AES, B_256, M_SHA, 1, 0, 0, },
- {0,CS(TLS_RSA_WITH_CAMELLIA_256_CBC_SHA),     S_RSA, K_RSA, C_CAMELLIA, B_256, M_SHA, 0, 0, 0, },
-+{0,CS(TLS_RSA_WITH_AES_256_CBC_SHA256),       S_RSA, K_RSA, C_AES, B_256, M_SHA256, 1, 0, 0, },
- {0,CS(TLS_RSA_WITH_AES_256_CBC_SHA),          S_RSA, K_RSA, C_AES, B_256, M_SHA, 1, 0, 0, },
- 
- {0,CS(TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA), S_RSA, K_DHE, C_CAMELLIA, B_128, M_SHA, 0, 0, 0, },
- {0,CS(TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA), S_DSA, K_DHE, C_CAMELLIA, B_128, M_SHA, 0, 0, 0, },
- {0,CS(TLS_DHE_DSS_WITH_RC4_128_SHA),          S_DSA, K_DHE, C_RC4, B_128, M_SHA, 0, 0, 0, },
-+{0,CS(TLS_DHE_RSA_WITH_AES_128_CBC_SHA256),   S_RSA, K_DHE, C_AES, B_128, M_SHA256, 1, 0, 0, },
- {0,CS(TLS_DHE_RSA_WITH_AES_128_CBC_SHA),      S_RSA, K_DHE, C_AES, B_128, M_SHA, 1, 0, 0, },
- {0,CS(TLS_DHE_DSS_WITH_AES_128_CBC_SHA),      S_DSA, K_DHE, C_AES, B_128, M_SHA, 1, 0, 0, },
- {0,CS(TLS_RSA_WITH_SEED_CBC_SHA),             S_RSA, K_RSA, C_SEED,B_128, M_SHA, 1, 0, 0, },
- {0,CS(TLS_RSA_WITH_CAMELLIA_128_CBC_SHA),     S_RSA, K_RSA, C_CAMELLIA, B_128, M_SHA, 0, 0, 0, },
- {0,CS(SSL_RSA_WITH_RC4_128_SHA),              S_RSA, K_RSA, C_RC4, B_128, M_SHA, 0, 0, 0, },
- {0,CS(SSL_RSA_WITH_RC4_128_MD5),              S_RSA, K_RSA, C_RC4, B_128, M_MD5, 0, 0, 0, },
-+{0,CS(TLS_RSA_WITH_AES_128_CBC_SHA256),       S_RSA, K_RSA, C_AES, B_128, M_SHA256, 1, 0, 0, },
- {0,CS(TLS_RSA_WITH_AES_128_CBC_SHA),          S_RSA, K_RSA, C_AES, B_128, M_SHA, 1, 0, 0, },
- 
- {0,CS(SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA),     S_RSA, K_DHE, C_3DES,B_3DES,M_SHA, 1, 0, 0, },
-@@ -165,6 +170,7 @@
- {0,CS(TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA),   S_RSA, K_RSA, C_DES, B_DES, M_SHA, 0, 1, 0, },
- {0,CS(SSL_RSA_EXPORT_WITH_RC4_40_MD5),        S_RSA, K_RSA, C_RC4, B_40,  M_MD5, 0, 1, 0, },
- {0,CS(SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5),    S_RSA, K_RSA, C_RC2, B_40,  M_MD5, 0, 1, 0, },
-+{0,CS(TLS_RSA_WITH_NULL_SHA256),              S_RSA, K_RSA, C_NULL,B_0,   M_SHA256, 0, 1, 0, },
- {0,CS(SSL_RSA_WITH_NULL_SHA),                 S_RSA, K_RSA, C_NULL,B_0,   M_SHA, 0, 1, 0, },
- {0,CS(SSL_RSA_WITH_NULL_MD5),                 S_RSA, K_RSA, C_NULL,B_0,   M_MD5, 0, 1, 0, },
- 
-@@ -180,6 +186,7 @@
- {0,CS(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA),      S_ECDSA, K_ECDHE, C_RC4, B_128, M_SHA, 0, 0, 0, },
- {0,CS(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA), S_ECDSA, K_ECDHE, C_3DES, B_3DES, M_SHA, 1, 0, 0, },
- {0,CS(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA),  S_ECDSA, K_ECDHE, C_AES, B_128, M_SHA, 1, 0, 0, },
-+{0,CS(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256), S_ECDSA, K_ECDHE, C_AES, B_128, M_SHA256, 1, 0, 0, },
- {0,CS(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA),  S_ECDSA, K_ECDHE, C_AES, B_256, M_SHA, 1, 0, 0, },
- 
- {0,CS(TLS_ECDH_RSA_WITH_NULL_SHA),            S_RSA, K_ECDH, C_NULL, B_0, M_SHA, 0, 0, 0, },
-@@ -192,6 +199,7 @@
- {0,CS(TLS_ECDHE_RSA_WITH_RC4_128_SHA),        S_RSA, K_ECDHE, C_RC4, B_128, M_SHA, 0, 0, 0, },
- {0,CS(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA),   S_RSA, K_ECDHE, C_3DES, B_3DES, M_SHA, 1, 0, 0, },
- {0,CS(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA),    S_RSA, K_ECDHE, C_AES, B_128, M_SHA, 1, 0, 0, },
-+{0,CS(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256), S_RSA, K_ECDHE, C_AES, B_128, M_SHA256, 1, 0, 0, },
- {0,CS(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA),    S_RSA, K_ECDHE, C_AES, B_256, M_SHA, 1, 0, 0, },
- #endif /* NSS_ENABLE_ECC */
- 
-Index: net/third_party/nss/ssl/sslimpl.h
-===================================================================
---- net/third_party/nss/ssl/sslimpl.h	(revision 203497)
-+++ net/third_party/nss/ssl/sslimpl.h	(working copy)
-@@ -71,6 +71,7 @@
- #define mac_sha 	ssl_mac_sha
- #define hmac_md5	ssl_hmac_md5
- #define hmac_sha	ssl_hmac_sha
-+#define hmac_sha256	ssl_hmac_sha256
- 
- #define SET_ERROR_CODE		/* reminder */
- #define SEND_ALERT		/* reminder */
-@@ -290,9 +291,9 @@
- } ssl3CipherSuiteCfg;
- 
- #ifdef NSS_ENABLE_ECC
--#define ssl_V3_SUITES_IMPLEMENTED 50
-+#define ssl_V3_SUITES_IMPLEMENTED 57
- #else
--#define ssl_V3_SUITES_IMPLEMENTED 30
-+#define ssl_V3_SUITES_IMPLEMENTED 35
- #endif /* NSS_ENABLE_ECC */
- 
- #define MAX_DTLS_SRTP_CIPHER_SUITES 4
-Index: net/third_party/nss/ssl/ssl3ecc.c
-===================================================================
---- net/third_party/nss/ssl/ssl3ecc.c	(revision 203497)
-+++ net/third_party/nss/ssl/ssl3ecc.c	(working copy)
-@@ -911,6 +911,7 @@
- static const ssl3CipherSuite ecdhe_ecdsa_suites[] = {
-     TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
-     TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
-     TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-     TLS_ECDHE_ECDSA_WITH_NULL_SHA,
-     TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
-@@ -920,6 +921,7 @@
- static const ssl3CipherSuite ecdhe_rsa_suites[] = {
-     TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
-     TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
-     TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-     TLS_ECDHE_RSA_WITH_NULL_SHA,
-     TLS_ECDHE_RSA_WITH_RC4_128_SHA,
-@@ -930,11 +932,13 @@
- static const ssl3CipherSuite ecSuites[] = {
-     TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
-     TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
-     TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
-     TLS_ECDHE_ECDSA_WITH_NULL_SHA,
-     TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
-     TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
-     TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
-     TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-     TLS_ECDHE_RSA_WITH_NULL_SHA,
-     TLS_ECDHE_RSA_WITH_RC4_128_SHA,
-Index: net/third_party/nss/ssl/sslsock.c
-===================================================================
---- net/third_party/nss/ssl/sslsock.c	(revision 203497)
-+++ net/third_party/nss/ssl/sslsock.c	(working copy)
-@@ -38,8 +38,8 @@
- typedef struct cipherPolicyStr cipherPolicy;
- 
- /* This table contains two preconfigured policies: Export and France.
--** It is used only by the functions SSL_SetDomesticPolicy, 
--** SSL_SetExportPolicy, and SSL_SetFrancyPolicy.
-+** It is used only by the functions NSS_SetDomesticPolicy, 
-+** NSS_SetExportPolicy, and NSS_SetFrancePolicy.
- ** Order of entries is not important.
- */
- static cipherPolicy ssl_ciphers[] = {	   /*   Export           France   */
-@@ -62,14 +62,19 @@
-  {  SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA,      SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA,      SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_DHE_DSS_WITH_RC4_128_SHA,           SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-- {  SSL_RSA_WITH_NULL_SHA,		    SSL_ALLOWED,     SSL_ALLOWED },
-  {  SSL_RSA_WITH_NULL_MD5,		    SSL_ALLOWED,     SSL_ALLOWED },
-+ {  SSL_RSA_WITH_NULL_SHA,		    SSL_ALLOWED,     SSL_ALLOWED },
-+ {  TLS_RSA_WITH_NULL_SHA256,		    SSL_ALLOWED,     SSL_ALLOWED },
-  {  TLS_DHE_DSS_WITH_AES_128_CBC_SHA, 	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_DHE_RSA_WITH_AES_128_CBC_SHA,       SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-+ {  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_RSA_WITH_AES_128_CBC_SHA,     	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-+ {  TLS_RSA_WITH_AES_128_CBC_SHA256,        SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_DHE_DSS_WITH_AES_256_CBC_SHA, 	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_DHE_RSA_WITH_AES_256_CBC_SHA,       SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-+ {  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_RSA_WITH_AES_256_CBC_SHA,     	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-+ {  TLS_RSA_WITH_AES_256_CBC_SHA256,        SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA, 	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-@@ -89,6 +94,7 @@
-  {  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,       SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,   SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-+ {  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,   SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDH_RSA_WITH_NULL_SHA,             SSL_ALLOWED,     SSL_ALLOWED },
-  {  TLS_ECDH_RSA_WITH_RC4_128_SHA,          SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-@@ -99,6 +105,7 @@
-  {  TLS_ECDHE_RSA_WITH_RC4_128_SHA,         SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,     SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-+ {  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
-  {  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,     SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- #endif /* NSS_ENABLE_ECC */
-  {  0,					    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED }
-@@ -789,28 +796,20 @@
- 	    rv = SECFailure;
- 	} else {
-             if (PR_FALSE != on) {
--		/* TLS 1.2 isn't supported in bypass mode. */
--		if (ss->vrange.min >= SSL_LIBRARY_VERSION_TLS_1_2) {
--		    /* If the user requested a minimum version of TLS 1.2 then
--		     * we don't silently downgrade. */
--		    PORT_SetError(SSL_ERROR_INVALID_VERSION_RANGE);
--		    rv = SECFailure;
--		    break;
--		}
--		if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2) {
--		    ss->vrange.max = SSL_LIBRARY_VERSION_TLS_1_1;
--		}
--                if (PR_SUCCESS == SSL_BypassSetup() ) {
-+                /* PKCS#11 bypass is not supported with TLS 1.2. */
-+                if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2) {
-+                    ss->opt.bypassPKCS11 = PR_FALSE;
-+                } else if (PR_SUCCESS == SSL_BypassSetup() ) {
- #ifdef NO_PKCS11_BYPASS
--                    ss->opt.bypassPKCS11   = PR_FALSE;
-+                    ss->opt.bypassPKCS11 = PR_FALSE;
- #else
--                    ss->opt.bypassPKCS11   = on;
-+                    ss->opt.bypassPKCS11 = on;
- #endif
-                 } else {
-                     rv = SECFailure;
-                 }
-             } else {
--                ss->opt.bypassPKCS11   = PR_FALSE;
-+                ss->opt.bypassPKCS11 = PR_FALSE;
-             }
- 	}
- 	break;
-Index: net/third_party/nss/ssl/ssl3con.c
-===================================================================
---- net/third_party/nss/ssl/ssl3con.c	(revision 203497)
-+++ net/third_party/nss/ssl/ssl3con.c	(working copy)
-@@ -97,6 +97,7 @@
-  { TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_DHE_RSA_WITH_AES_256_CBC_SHA, 	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-+ { TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,    SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-  { TLS_DHE_DSS_WITH_AES_256_CBC_SHA, 	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- #ifdef NSS_ENABLE_ECC
-  { TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,      SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-@@ -104,17 +105,21 @@
- #endif /* NSS_ENABLE_ECC */
-  { TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,  	   SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_RSA_WITH_AES_256_CBC_SHA,     	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-+ { TLS_RSA_WITH_AES_256_CBC_SHA256,	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- 
- #ifdef NSS_ENABLE_ECC
-  { TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,       SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,   SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-+ { TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_ECDHE_RSA_WITH_RC4_128_SHA,         SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,     SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-+ { TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
- #endif /* NSS_ENABLE_ECC */
-  { TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_DHE_DSS_WITH_RC4_128_SHA,           SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { TLS_DHE_RSA_WITH_AES_128_CBC_SHA,       SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-+ { TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,    SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-  { TLS_DHE_DSS_WITH_AES_128_CBC_SHA, 	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- #ifdef NSS_ENABLE_ECC
-  { TLS_ECDH_RSA_WITH_RC4_128_SHA,          SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-@@ -127,6 +132,7 @@
-  { SSL_RSA_WITH_RC4_128_SHA,               SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-  { SSL_RSA_WITH_RC4_128_MD5,               SSL_NOT_ALLOWED, PR_TRUE, PR_FALSE},
-  { TLS_RSA_WITH_AES_128_CBC_SHA,     	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
-+ { TLS_RSA_WITH_AES_128_CBC_SHA256,	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- 
- #ifdef NSS_ENABLE_ECC
-  { TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-@@ -159,6 +165,7 @@
-  { TLS_ECDH_ECDSA_WITH_NULL_SHA,           SSL_NOT_ALLOWED, PR_FALSE, PR_FALSE},
- #endif /* NSS_ENABLE_ECC */
-  { SSL_RSA_WITH_NULL_SHA,                  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-+ { TLS_RSA_WITH_NULL_SHA256,               SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
-  { SSL_RSA_WITH_NULL_MD5,                  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
- 
- };
-@@ -282,6 +289,7 @@
-     {SSL_NULL_WITH_NULL_NULL,       cipher_null,   mac_null, kea_null},
-     {SSL_RSA_WITH_NULL_MD5,         cipher_null,   mac_md5, kea_rsa},
-     {SSL_RSA_WITH_NULL_SHA,         cipher_null,   mac_sha, kea_rsa},
-+    {TLS_RSA_WITH_NULL_SHA256,      cipher_null,   hmac_sha256, kea_rsa},
-     {SSL_RSA_EXPORT_WITH_RC4_40_MD5,cipher_rc4_40, mac_md5, kea_rsa_export},
-     {SSL_RSA_WITH_RC4_128_MD5,      cipher_rc4,    mac_md5, kea_rsa},
-     {SSL_RSA_WITH_RC4_128_SHA,      cipher_rc4,    mac_sha, kea_rsa},
-@@ -326,11 +334,15 @@
- 
- /* New TLS cipher suites */
-     {TLS_RSA_WITH_AES_128_CBC_SHA,     	cipher_aes_128, mac_sha, kea_rsa},
-+    {TLS_RSA_WITH_AES_128_CBC_SHA256,	cipher_aes_128, hmac_sha256, kea_rsa},
-     {TLS_DHE_DSS_WITH_AES_128_CBC_SHA, 	cipher_aes_128, mac_sha, kea_dhe_dss},
-     {TLS_DHE_RSA_WITH_AES_128_CBC_SHA, 	cipher_aes_128, mac_sha, kea_dhe_rsa},
-+    {TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, cipher_aes_128, hmac_sha256, kea_dhe_rsa},
-     {TLS_RSA_WITH_AES_256_CBC_SHA,     	cipher_aes_256, mac_sha, kea_rsa},
-+    {TLS_RSA_WITH_AES_256_CBC_SHA256,	cipher_aes_256, hmac_sha256, kea_rsa},
-     {TLS_DHE_DSS_WITH_AES_256_CBC_SHA, 	cipher_aes_256, mac_sha, kea_dhe_dss},
-     {TLS_DHE_RSA_WITH_AES_256_CBC_SHA, 	cipher_aes_256, mac_sha, kea_dhe_rsa},
-+    {TLS_DHE_RSA_WITH_AES_256_CBC_SHA256, cipher_aes_256, hmac_sha256, kea_dhe_rsa},
- #if 0
-     {TLS_DH_DSS_WITH_AES_128_CBC_SHA,  	cipher_aes_128, mac_sha, kea_dh_dss},
-     {TLS_DH_RSA_WITH_AES_128_CBC_SHA,  	cipher_aes_128, mac_sha, kea_dh_rsa},
-@@ -372,6 +384,7 @@
-     {TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,      cipher_rc4, mac_sha, kea_ecdhe_ecdsa},
-     {TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, cipher_3des, mac_sha, kea_ecdhe_ecdsa},
-     {TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, cipher_aes_128, mac_sha, kea_ecdhe_ecdsa},
-+    {TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, cipher_aes_128, hmac_sha256, kea_ecdhe_ecdsa},
-     {TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, cipher_aes_256, mac_sha, kea_ecdhe_ecdsa},
- 
-     {TLS_ECDH_RSA_WITH_NULL_SHA,         cipher_null,    mac_sha, kea_ecdh_rsa},
-@@ -384,6 +397,7 @@
-     {TLS_ECDHE_RSA_WITH_RC4_128_SHA,      cipher_rc4,     mac_sha, kea_ecdhe_rsa},
-     {TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, cipher_3des,    mac_sha, kea_ecdhe_rsa},
-     {TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,  cipher_aes_128, mac_sha, kea_ecdhe_rsa},
-+    {TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, cipher_aes_128, hmac_sha256, kea_ecdhe_rsa},
-     {TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,  cipher_aes_256, mac_sha, kea_ecdhe_rsa},
- 
- #if 0
-@@ -430,14 +444,17 @@
- #define mmech_sha      CKM_SSL3_SHA1_MAC
- #define mmech_md5_hmac CKM_MD5_HMAC
- #define mmech_sha_hmac CKM_SHA_1_HMAC
-+#define mmech_sha256_hmac CKM_SHA256_HMAC
- 
- static const ssl3MACDef mac_defs[] = { /* indexed by SSL3MACAlgorithm */
-+    /* pad_size is only used for SSL 3.0 MAC. See RFC 6101 Sec. 5.2.3.1. */
-     /* mac      mmech       pad_size  mac_size                       */
-     { mac_null, mmech_null,       0,  0          },
-     { mac_md5,  mmech_md5,       48,  MD5_LENGTH },
-     { mac_sha,  mmech_sha,       40,  SHA1_LENGTH},
--    {hmac_md5,  mmech_md5_hmac,  48,  MD5_LENGTH },
--    {hmac_sha,  mmech_sha_hmac,  40,  SHA1_LENGTH},
-+    {hmac_md5,  mmech_md5_hmac,   0,  MD5_LENGTH },
-+    {hmac_sha,  mmech_sha_hmac,   0,  SHA1_LENGTH},
-+    {hmac_sha256, mmech_sha256_hmac, 0, SHA256_LENGTH},
- };
- 
- /* indexed by SSL3BulkCipher */
-@@ -580,6 +597,14 @@
-      *   SSL_DH_ANON_EXPORT_WITH_DES40_CBC_SHA:  never implemented
-      */
- 	return version <= SSL_LIBRARY_VERSION_TLS_1_0;
-+    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
-+    case TLS_RSA_WITH_AES_256_CBC_SHA256:
-+    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
-+    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
-+    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
-+    case TLS_RSA_WITH_AES_128_CBC_SHA256:
-+    case TLS_RSA_WITH_NULL_SHA256:
-+	return version >= SSL_LIBRARY_VERSION_TLS_1_2;
-     default:
- 	return PR_TRUE;
-     }
-@@ -1334,7 +1359,7 @@
-     cipher = suite_def->bulk_cipher_alg;
-     kea    = suite_def->key_exchange_alg;
-     mac    = suite_def->mac_alg;
--    if (isTLS)
-+    if (mac <= ssl_mac_sha && isTLS)
- 	mac += 2;
- 
-     ss->ssl3.hs.suite_def = suite_def;
-@@ -2060,6 +2085,9 @@
- 	case ssl_hmac_sha: /* used with TLS */
- 	    hashObj = HASH_GetRawHashObject(HASH_AlgSHA1);
- 	    break;
-+	case ssl_hmac_sha256: /* used with TLS */
-+	    hashObj = HASH_GetRawHashObject(HASH_AlgSHA256);
-+	    break;
- 	default:
- 	    break;
- 	}
-@@ -3517,6 +3545,13 @@
-     key_material_params.ulMacSizeInBits = pwSpec->mac_size           * BPB;
-     key_material_params.ulKeySizeInBits = cipher_def->secret_key_size* BPB;
-     key_material_params.ulIVSizeInBits  = cipher_def->iv_size        * BPB;
-+    if (cipher_def->type == type_block &&
-+	pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_1) {
-+	/* Block ciphers in >= TLS 1.1 use a per-record, explicit IV. */
-+	key_material_params.ulIVSizeInBits = 0;
-+	memset(pwSpec->client.write_iv, 0, cipher_def->iv_size);
-+	memset(pwSpec->server.write_iv, 0, cipher_def->iv_size);
-+    }
- 
-     key_material_params.bIsExport = (CK_BBOOL)(kea_def->is_limited);
-     /* was:	(CK_BBOOL)(cipher_def->keygen_mode != kg_strong); */
-Index: net/third_party/nss/ssl/sslenum.c
-===================================================================
---- net/third_party/nss/ssl/sslenum.c	(revision 203497)
-+++ net/third_party/nss/ssl/sslenum.c	(working copy)
-@@ -26,6 +26,8 @@
-  *
-  * If new ECC cipher suites are added, also update the ssl3CipherSuite arrays
-  * in ssl3ecc.c.
-+ *
-+ * Finally, update the ssl_V3_SUITES_IMPLEMENTED macro in sslimpl.h.
-  */
- const PRUint16 SSL_ImplementedCiphers[] = {
-     /* 256-bit */
-@@ -36,6 +38,7 @@
-     TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,
-     TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,
-     TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
-     TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
- #ifdef NSS_ENABLE_ECC
-     TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,
-@@ -43,18 +46,22 @@
- #endif /* NSS_ENABLE_ECC */
-     TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,
-     TLS_RSA_WITH_AES_256_CBC_SHA,
-+    TLS_RSA_WITH_AES_256_CBC_SHA256,
- 
-     /* 128-bit */
- #ifdef NSS_ENABLE_ECC
-     TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
-     TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
-     TLS_ECDHE_RSA_WITH_RC4_128_SHA,
-     TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
- #endif /* NSS_ENABLE_ECC */
-     TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,
-     TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,
-     TLS_DHE_DSS_WITH_RC4_128_SHA,
-     TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
-     TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
- #ifdef NSS_ENABLE_ECC
-     TLS_ECDH_RSA_WITH_RC4_128_SHA,
-@@ -67,6 +74,7 @@
-     SSL_RSA_WITH_RC4_128_SHA,
-     SSL_RSA_WITH_RC4_128_MD5,
-     TLS_RSA_WITH_AES_128_CBC_SHA,
-+    TLS_RSA_WITH_AES_128_CBC_SHA256,
- 
-     /* 112-bit 3DES */
- #ifdef NSS_ENABLE_ECC
-@@ -104,6 +112,7 @@
-     TLS_ECDH_ECDSA_WITH_NULL_SHA,
- #endif /* NSS_ENABLE_ECC */
-     SSL_RSA_WITH_NULL_SHA,
-+    TLS_RSA_WITH_NULL_SHA256,
-     SSL_RSA_WITH_NULL_MD5,
- 
-     /* SSL2 cipher suites. */
diff --git a/src/net/third_party/nss/patches/tlsunique.patch b/src/net/third_party/nss/patches/tlsunique.patch
index 153a5a3..a4214a4 100644
--- a/src/net/third_party/nss/patches/tlsunique.patch
+++ b/src/net/third_party/nss/patches/tlsunique.patch
@@ -1,7 +1,7 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-04-27 09:39:13.645022181 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-04-27 09:39:32.395287400 -0700
-@@ -11081,6 +11081,68 @@ ssl3_InitSocketPolicy(sslSocket *ss)
+diff -pu -r a/net/third_party/nss/ssl/ssl3con.c b/net/third_party/nss/ssl/ssl3con.c
+--- a/net/third_party/nss/ssl/ssl3con.c	2012-11-09 16:13:22.012407752 -0800
++++ b/net/third_party/nss/ssl/ssl3con.c	2012-11-09 16:14:14.123162240 -0800
+@@ -10719,6 +10719,68 @@ ssl3_InitSocketPolicy(sslSocket *ss)
      PORT_Memcpy(ss->cipherSuites, cipherSuites, sizeof cipherSuites);
  }
  
@@ -70,9 +70,9 @@ diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
  /* ssl3_config_match_init must have already been called by
   * the caller of this function.
   */
-diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
---- a/nss/lib/ssl/ssl.h	2013-04-27 09:39:13.645022181 -0700
-+++ b/nss/lib/ssl/ssl.h	2013-04-27 09:39:32.395287400 -0700
+diff -pu -r a/net/third_party/nss/ssl/ssl.h b/net/third_party/nss/ssl/ssl.h
+--- a/net/third_party/nss/ssl/ssl.h	2012-11-09 16:13:22.062408475 -0800
++++ b/net/third_party/nss/ssl/ssl.h	2012-11-09 16:14:14.123162240 -0800
 @@ -250,6 +250,27 @@ SSL_IMPORT SECStatus SSL_CipherPrefGetDe
  SSL_IMPORT SECStatus SSL_CipherPolicySet(PRInt32 cipher, PRInt32 policy);
  SSL_IMPORT SECStatus SSL_CipherPolicyGet(PRInt32 cipher, PRInt32 *policy);
@@ -101,10 +101,10 @@ diff -pu a/nss/lib/ssl/ssl.h b/nss/lib/ssl/ssl.h
  /* SSL Version Range API
  **
  ** This API should be used to control SSL 3.0 & TLS support instead of the
-diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
---- a/nss/lib/ssl/sslimpl.h	2013-04-27 09:39:13.645022181 -0700
-+++ b/nss/lib/ssl/sslimpl.h	2013-04-27 09:39:32.395287400 -0700
-@@ -1724,6 +1724,11 @@ extern PRBool ssl_GetSessionTicketKeysPK
+diff -pu -r a/net/third_party/nss/ssl/sslimpl.h b/net/third_party/nss/ssl/sslimpl.h
+--- a/net/third_party/nss/ssl/sslimpl.h	2012-11-09 16:13:22.062408475 -0800
++++ b/net/third_party/nss/ssl/sslimpl.h	2012-11-09 16:14:14.123162240 -0800
+@@ -1732,6 +1732,11 @@ extern PRBool ssl_GetSessionTicketKeysPK
  extern SECStatus ssl3_ValidateNextProtoNego(const unsigned char* data,
  					    unsigned int length);
  
@@ -116,10 +116,10 @@ diff -pu a/nss/lib/ssl/sslimpl.h b/nss/lib/ssl/sslimpl.h
  /* Construct a new NSPR socket for the app to use */
  extern PRFileDesc *ssl_NewPRSocket(sslSocket *ss, PRFileDesc *fd);
  extern void ssl_FreePRSocket(PRFileDesc *fd);
-diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
---- a/nss/lib/ssl/sslsock.c	2013-04-27 09:39:13.655022320 -0700
-+++ b/nss/lib/ssl/sslsock.c	2013-04-27 09:39:32.395287400 -0700
-@@ -1360,6 +1360,27 @@ NSS_SetFrancePolicy(void)
+diff -pu -r a/net/third_party/nss/ssl/sslsock.c b/net/third_party/nss/ssl/sslsock.c
+--- a/net/third_party/nss/ssl/sslsock.c	2012-11-09 16:13:22.062408475 -0800
++++ b/net/third_party/nss/ssl/sslsock.c	2012-11-09 16:14:14.123162240 -0800
+@@ -1354,6 +1354,27 @@ NSS_SetFrancePolicy(void)
      return NSS_SetDomesticPolicy();
  }
  
diff --git a/src/net/third_party/nss/patches/unusedvariables.patch b/src/net/third_party/nss/patches/unusedvariables.patch
deleted file mode 100644
index 820a6ce..0000000
--- a/src/net/third_party/nss/patches/unusedvariables.patch
+++ /dev/null
@@ -1,14 +0,0 @@
-diff -pu a/nss/lib/ssl/ssl3con.c b/nss/lib/ssl/ssl3con.c
---- a/nss/lib/ssl/ssl3con.c	2013-05-01 14:37:22.992813168 -0700
-+++ b/nss/lib/ssl/ssl3con.c	2013-05-01 14:43:57.088382323 -0700
-@@ -8657,10 +8657,7 @@ static SECStatus
- ssl3_SendCertificateStatus(sslSocket *ss)
- {
-     SECStatus            rv;
--    CERTCertificateList *certChain;
-     int                  len 		= 0;
--    int                  i;
--    SSL3KEAType          certIndex;
- 
-     SSL_TRC(3, ("%d: SSL3[%d]: send certificate status handshake",
- 		SSL_GETPID(), ss->fd));
diff --git a/src/net/third_party/nss/patches/versionskew.patch b/src/net/third_party/nss/patches/versionskew.patch
index 79737a1..0b62b67 100644
--- a/src/net/third_party/nss/patches/versionskew.patch
+++ b/src/net/third_party/nss/patches/versionskew.patch
@@ -1,6 +1,6 @@
-diff -pu a/nss/lib/ssl/sslsecur.c b/nss/lib/ssl/sslsecur.c
---- a/nss/lib/ssl/sslsecur.c	2013-04-27 09:17:17.216390477 -0700
-+++ b/nss/lib/ssl/sslsecur.c	2013-04-27 09:18:33.277467610 -0700
+diff -pu -r a/net/third_party/nss/ssl/sslsecur.c b/net/third_party/nss/ssl/sslsecur.c
+--- a/net/third_party/nss/ssl/sslsecur.c	2012-05-24 13:34:51.000000000 -0700
++++ b/net/third_party/nss/ssl/sslsecur.c	2012-11-09 15:15:21.901558709 -0800
 @@ -1312,6 +1312,10 @@ SSL_SetURL(PRFileDesc *fd, const char *u
  SECStatus
  SSL_SetTrustAnchors(PRFileDesc *fd, CERTCertList *certList)
@@ -20,10 +20,10 @@ diff -pu a/nss/lib/ssl/sslsecur.c b/nss/lib/ssl/sslsecur.c
  }
  
  /*
-diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
---- a/nss/lib/ssl/sslsock.c	2013-04-27 09:17:17.226390616 -0700
-+++ b/nss/lib/ssl/sslsock.c	2013-04-27 09:18:33.277467610 -0700
-@@ -1622,6 +1622,11 @@ SSL_GetSRTPCipher(PRFileDesc *fd, PRUint
+diff -pu -r a/net/third_party/nss/ssl/sslsock.c b/net/third_party/nss/ssl/sslsock.c
+--- a/net/third_party/nss/ssl/sslsock.c	2012-09-24 16:57:42.000000000 -0700
++++ b/net/third_party/nss/ssl/sslsock.c	2012-11-09 15:15:21.901558709 -0800
+@@ -1603,6 +1603,11 @@ SSL_GetSRTPCipher(PRFileDesc *fd, PRUint
  PRFileDesc *
  SSL_ReconfigFD(PRFileDesc *model, PRFileDesc *fd)
  {
@@ -35,7 +35,7 @@ diff -pu a/nss/lib/ssl/sslsock.c b/nss/lib/ssl/sslsock.c
      sslSocket * sm = NULL, *ss = NULL;
      int i;
      sslServerCerts * mc = NULL;
-@@ -1737,6 +1742,7 @@ SSL_ReconfigFD(PRFileDesc *model, PRFile
+@@ -1711,6 +1716,7 @@ SSL_ReconfigFD(PRFileDesc *model, PRFile
      return fd;
  loser:
      return NULL;
diff --git a/src/net/third_party/nss/ssl.gyp b/src/net/third_party/nss/ssl.gyp
index 31567c2..7eaa56b 100644
--- a/src/net/third_party/nss/ssl.gyp
+++ b/src/net/third_party/nss/ssl.gyp
@@ -67,7 +67,6 @@
         'ssl/unix_err.h',
         'ssl/win32err.c',
         'ssl/win32err.h',
-        'ssl/bodge/secitem_array.c',
         'ssl/bodge/secure_memcmp.c',
       ],
       'sources!': [
diff --git a/src/net/third_party/nss/ssl/SSLerrs.h b/src/net/third_party/nss/ssl/SSLerrs.h
index dc22f76..9124549 100644
--- a/src/net/third_party/nss/ssl/SSLerrs.h
+++ b/src/net/third_party/nss/ssl/SSLerrs.h
@@ -412,12 +412,3 @@ ER3(SSL_ERROR_INVALID_CHANNEL_ID_KEY, (SSL_ERROR_BASE + 127),
 
 ER3(SSL_ERROR_GET_CHANNEL_ID_FAILED, (SSL_ERROR_BASE + 128),
 "The application could not get a TLS Channel ID.")
-
-ER3(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM, (SSL_ERROR_BASE + 129),
-"Unsupported hash algorithm used by TLS peer.")
-
-ER3(SSL_ERROR_DIGEST_FAILURE, (SSL_ERROR_BASE + 130),
-"Digest function failed.")
-
-ER3(SSL_ERROR_INCORRECT_SIGNATURE_ALGORITHM, (SSL_ERROR_BASE + 131),
-"Incorrect signature algorithm specified in a digitally-signed element.")
diff --git a/src/net/third_party/nss/ssl/authcert.c b/src/net/third_party/nss/ssl/authcert.c
index b45f0a6..a0b6667 100644
--- a/src/net/third_party/nss/ssl/authcert.c
+++ b/src/net/third_party/nss/ssl/authcert.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: authcert.c,v 1.6 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include <stdio.h>
 #include <string.h>
diff --git a/src/net/third_party/nss/ssl/bodge/secitem_array.c b/src/net/third_party/nss/ssl/bodge/secitem_array.c
index 62e5907..ac80da8 100644
--- a/src/net/third_party/nss/ssl/bodge/secitem_array.c
+++ b/src/net/third_party/nss/ssl/bodge/secitem_array.c
@@ -6,7 +6,6 @@
  * Support routines for SECItemArray data structure.
  */
 
-#include "nssutil.h"
 #include "seccomon.h"
 #include "secitem.h"
 #include "secerr.h"
@@ -14,15 +13,10 @@
 
 typedef struct SECItemArrayStr SECItemArray;
 
-#define NSSUTIL_VERSION_NUM \
-    (NSSUTIL_VMAJOR * 10000 + NSSUTIL_VMINOR * 100 + NSSUTIL_VPATCH)
-#if NSSUTIL_VERSION_NUM < 31500
-// Added in NSS 3.15.
 struct SECItemArrayStr {
     SECItem *items;
     unsigned int len;
 };
-#endif
 
 SECItemArray *
 SECITEM_AllocArray(PLArenaPool *arena, SECItemArray *array, unsigned int len)
diff --git a/src/net/third_party/nss/ssl/cmpcert.c b/src/net/third_party/nss/ssl/cmpcert.c
index b40500c..27ec88b 100644
--- a/src/net/third_party/nss/ssl/cmpcert.c
+++ b/src/net/third_party/nss/ssl/cmpcert.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: cmpcert.c,v 1.7 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include <stdio.h>
 #include <string.h>
diff --git a/src/net/third_party/nss/ssl/derive.c b/src/net/third_party/nss/ssl/derive.c
index d292545..da62682 100644
--- a/src/net/third_party/nss/ssl/derive.c
+++ b/src/net/third_party/nss/ssl/derive.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: derive.c,v 1.16 2012/06/11 02:38:30 emaldona%redhat.com Exp $ */
 
 #include "ssl.h" 	/* prereq to sslimpl.h */
 #include "certt.h"	/* prereq to sslimpl.h */
@@ -82,11 +82,9 @@ ssl3_KeyAndMacDeriveBypass(
     unsigned int    effKeySize;		/* effective size of cipher keys */
     unsigned int    macSize;		/* size of MAC secret */
     unsigned int    IVSize;		/* size of IV */
-    PRBool          explicitIV = PR_FALSE;
     SECStatus       rv    = SECFailure;
     SECStatus       status = SECSuccess;
     PRBool          isFIPS = PR_FALSE;
-    PRBool          isTLS12 = pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2;
 
     SECItem         srcr;
     SECItem         crsr;
@@ -118,13 +116,7 @@ ssl3_KeyAndMacDeriveBypass(
     if (keySize == 0) {
 	effKeySize = IVSize = 0; /* only MACing */
     }
-    if (cipher_def->type == type_block &&
-	pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_1) {
-	/* Block ciphers in >= TLS 1.1 use a per-record, explicit IV. */
-	explicitIV = PR_TRUE;
-    }
-    block_needed =
-	2 * (macSize + effKeySize + ((!isExport && !explicitIV) * IVSize));
+    block_needed = 2 * (macSize + effKeySize + ((!isExport) * IVSize));
 
     /*
      * clear out our returned keys so we can recover on failure
@@ -159,13 +151,8 @@ ssl3_KeyAndMacDeriveBypass(
 	keyblk.data = key_block;
 	keyblk.len  = block_needed;
 
-	if (isTLS12) {
-	    status = TLS_P_hash(HASH_AlgSHA256, &pwSpec->msItem,
-				"key expansion", &srcr, &keyblk, isFIPS);
-	} else {
-	    status = TLS_PRF(&pwSpec->msItem, "key expansion", &srcr, &keyblk,
-			     isFIPS);
-	}
+	status = TLS_PRF(&pwSpec->msItem, "key expansion", &srcr, &keyblk,
+			  isFIPS);
 	if (status != SECSuccess) {
 	    goto key_and_mac_derive_fail;
 	}
@@ -253,34 +240,22 @@ ssl3_KeyAndMacDeriveBypass(
 	i += keySize;
 
 	if (IVSize > 0) {
-	    if (explicitIV) {
-		static unsigned char zero_block[32];
-		PORT_Assert(IVSize <= sizeof zero_block);
-		buildSSLKey(&zero_block[0], IVSize, \
-			    &pwSpec->client.write_iv_item, \
-			    "Domestic Client Write IV");
-		buildSSLKey(&zero_block[0], IVSize, \
-			    &pwSpec->server.write_iv_item, \
-			    "Domestic Server Write IV");
-	    } else {
-		/* 
-		** client_write_IV[CipherSpec.IV_size]
-		*/
-		buildSSLKey(&key_block[i], IVSize, \
-			    &pwSpec->client.write_iv_item, \
-			    "Domestic Client Write IV");
-		i += IVSize;
-
-		/* 
-		** server_write_IV[CipherSpec.IV_size]
-		*/
-		buildSSLKey(&key_block[i], IVSize, \
-			    &pwSpec->server.write_iv_item, \
-			    "Domestic Server Write IV");
-		i += IVSize;
-	    }
+	    /* 
+	    ** client_write_IV[CipherSpec.IV_size]
+	    */
+	    buildSSLKey(&key_block[i], IVSize, &pwSpec->client.write_iv_item, \
+	                "Domestic Client Write IV");
+	    i += IVSize;
+
+	    /* 
+	    ** server_write_IV[CipherSpec.IV_size]
+	    */
+	    buildSSLKey(&key_block[i], IVSize, &pwSpec->server.write_iv_item, \
+	                "Domestic Server Write IV");
+	    i += IVSize;
 	}
 	PORT_Assert(i <= block_bytes);
+
     } else if (!isTLS) { 
 	/*
 	** Generate SSL3 Export write keys and IVs.
@@ -443,7 +418,6 @@ ssl3_MasterKeyDeriveBypass(
     unsigned char * key_block    = pwSpec->key_block;
     SECStatus       rv    = SECSuccess;
     PRBool          isFIPS = PR_FALSE;
-    PRBool          isTLS12 = pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2;
 
     SECItem         crsr;
 
@@ -479,12 +453,7 @@ ssl3_MasterKeyDeriveBypass(
 	master.data = key_block;
 	master.len = SSL3_MASTER_SECRET_LENGTH;
 
-	if (isTLS12) {
-	    rv = TLS_P_hash(HASH_AlgSHA256, pms, "master secret", &crsr,
-			    &master, isFIPS);
-	} else {
-	    rv = TLS_PRF(pms, "master secret", &crsr, &master, isFIPS);
-	}
+	rv = TLS_PRF(pms, "master secret", &crsr, &master, isFIPS);
 	if (rv != SECSuccess) {
 	    PORT_SetError(SSL_ERROR_SESSION_KEY_GEN_FAILURE);
 	}
@@ -795,9 +764,8 @@ SSL_CanBypass(CERTCertificate *cert, SECKEYPrivateKey *srvPrivkey,
 		     requiredECCbits = signatureKeyStrength;
 
 		ec_curve =
-		    ssl3_GetCurveWithECKeyStrength(
-					ssl3_GetSupportedECCCurveMask(NULL),
-				  	requiredECCbits);
+		    ssl3_GetCurveWithECKeyStrength(SSL3_SUPPORTED_CURVES_MASK,
+						   requiredECCbits);
 		rv = ssl3_ECName2Params(NULL, ec_curve, &ecParams);
 		if (rv == SECFailure) {
 		    break;
diff --git a/src/net/third_party/nss/ssl/dtlscon.c b/src/net/third_party/nss/ssl/dtlscon.c
index e346871..5eb13ab 100644
--- a/src/net/third_party/nss/ssl/dtlscon.c
+++ b/src/net/third_party/nss/ssl/dtlscon.c
@@ -5,7 +5,7 @@
 /*
  * DTLS Protocol
  */
-/* $Id$ */
+/* $Id: dtlscon.c,v 1.5 2012/09/28 01:46:45 wtc%google.com Exp $ */
 
 #include "ssl.h"
 #include "sslimpl.h"
diff --git a/src/net/third_party/nss/ssl/exports_win.def b/src/net/third_party/nss/ssl/exports_win.def
index 9c359b4..848f048 100644
--- a/src/net/third_party/nss/ssl/exports_win.def
+++ b/src/net/third_party/nss/ssl/exports_win.def
@@ -31,7 +31,6 @@ SSL_OptionGetDefault
 SSL_OptionSet
 SSL_OptionSetDefault
 SSL_PeerCertificate
-SSL_PeerStapledOCSPResponses
 SSL_ResetHandshake
 SSL_SetSockPeerID
 SSL_SetURL
@@ -54,5 +53,6 @@ SSL_PeerCertificateChain
 SSL_SetClientChannelIDCallback
 SSL_GetPlatformClientAuthDataHook
 SSL_HandshakeResumedSession
+SSL_GetStapledOCSPResponse
 SSL_RestartHandshakeAfterChannelIDReq
 SSL_GetChannelBinding
diff --git a/src/net/third_party/nss/ssl/manifest.mn b/src/net/third_party/nss/ssl/manifest.mn
index 4d46d46..3bb28a2 100644
--- a/src/net/third_party/nss/ssl/manifest.mn
+++ b/src/net/third_party/nss/ssl/manifest.mn
@@ -2,7 +2,7 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
-CORE_DEPTH = ../..
+CORE_DEPTH = ../../..
 
 # DEFINES = -DTRACE
 
diff --git a/src/net/third_party/nss/ssl/notes.txt b/src/net/third_party/nss/ssl/notes.txt
index a71c08e..8f0e3d2 100644
--- a/src/net/third_party/nss/ssl/notes.txt
+++ b/src/net/third_party/nss/ssl/notes.txt
@@ -1,6 +1,6 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ This Source Code Form is subject to the terms of the Mozilla Public
+ # License, v. 2.0. If a copy of the MPL was not distributed with this
+ # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 SSL's Buffers: enumerated and explained.
 
diff --git a/src/net/third_party/nss/ssl/os2_err.c b/src/net/third_party/nss/ssl/os2_err.c
index ee76003..af43f34 100644
--- a/src/net/third_party/nss/ssl/os2_err.c
+++ b/src/net/third_party/nss/ssl/os2_err.c
@@ -10,7 +10,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: os2_err.c,v 1.5 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "prerror.h"
 #include "prlog.h"
diff --git a/src/net/third_party/nss/ssl/os2_err.h b/src/net/third_party/nss/ssl/os2_err.h
index 21defa9..ba33707 100644
--- a/src/net/third_party/nss/ssl/os2_err.h
+++ b/src/net/third_party/nss/ssl/os2_err.h
@@ -9,7 +9,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: os2_err.h,v 1.5 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 /*  NSPR doesn't make these functions public, so we have to duplicate
 **  them in NSS.
diff --git a/src/net/third_party/nss/ssl/preenc.h b/src/net/third_party/nss/ssl/preenc.h
index 1b735ec..d20d4a0 100644
--- a/src/net/third_party/nss/ssl/preenc.h
+++ b/src/net/third_party/nss/ssl/preenc.h
@@ -6,7 +6,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: preenc.h,v 1.7 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 /* Fortezza support is removed.
  * This file remains so that old programs will continue to compile,
diff --git a/src/net/third_party/nss/ssl/prelib.c b/src/net/third_party/nss/ssl/prelib.c
index 0c8036f..f6bca55 100644
--- a/src/net/third_party/nss/ssl/prelib.c
+++ b/src/net/third_party/nss/ssl/prelib.c
@@ -7,7 +7,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: prelib.c,v 1.8 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "cert.h"
 #include "ssl.h"
diff --git a/src/net/third_party/nss/ssl/ssl.h b/src/net/third_party/nss/ssl/ssl.h
index 8e9ba24..8a669d1 100644
--- a/src/net/third_party/nss/ssl/ssl.h
+++ b/src/net/third_party/nss/ssl/ssl.h
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: ssl.h,v 1.59 2012/09/21 21:58:43 wtc%google.com Exp $ */
 
 #ifndef __ssl_h_
 #define __ssl_h_
@@ -424,35 +424,6 @@ SSL_IMPORT SECStatus SSL_SecurityStatus(PRFileDesc *fd, int *on, char **cipher,
 */
 SSL_IMPORT CERTCertificate *SSL_PeerCertificate(PRFileDesc *fd);
 
-/* SSL_PeerStapledOCSPResponses returns the OCSP responses that were provided
- * by the TLS server. The return value is a pointer to an internal SECItemArray
- * that contains the returned OCSP responses; it is only valid until the
- * callback function that calls SSL_PeerStapledOCSPResponses returns.
- *
- * If no OCSP responses were given by the server then the result will be empty.
- * If there was an error, then the result will be NULL.
- *
- * You must set the SSL_ENABLE_OCSP_STAPLING option to enable OCSP stapling.
- * to be provided by a server.
- *
- * libssl does not do any validation of the OCSP response itself; the
- * authenticate certificate hook is responsible for doing so. The default
- * authenticate certificate hook, SSL_AuthCertificate, does not implement
- * any OCSP stapling funtionality, but this may change in future versions.
- */
-SSL_IMPORT const SECItemArray * SSL_PeerStapledOCSPResponses(PRFileDesc *fd);
-
-/* SSL_SetStapledOCSPResponses stores an array of one or multiple OCSP responses
- * in the fd's data, which may be sent as part of a server side cert_status
- * handshake message.
- * If takeOwnership is false, the function will duplicate the responses.
- * If takeOwnership is true, the ownership of responses is transfered into the
- * SSL library, and the caller must stop using it.
- */
-SSL_IMPORT SECStatus
-SSL_SetStapledOCSPResponses(PRFileDesc *fd, SECItemArray *responses,
-			    PRBool takeOwnership);
-
 /*
 ** Return references to the certificates presented by the SSL peer.
 ** |maxNumCerts| must contain the size of the |certs| array. On successful
@@ -465,6 +436,23 @@ SSL_IMPORT SECStatus SSL_PeerCertificateChain(
 	PRFileDesc *fd, CERTCertificate **certs,
 	unsigned int *numCerts, unsigned int maxNumCerts);
 
+/* SSL_GetStapledOCSPResponse returns the OCSP response that was provided by
+ * the TLS server. The resulting data is copied to |out_data|. On entry, |*len|
+ * must contain the size of |out_data|. On exit, |*len| will contain the size
+ * of the OCSP stapled response. If the stapled response is too large to fit in
+ * |out_data| then it will be truncated. If no OCSP response was given by the
+ * server then it has zero length.
+ *
+ * You must set the SSL_ENABLE_OCSP_STAPLING option in order for OCSP responses
+ * to be provided by a server.
+ *
+ * You can call this function during the certificate verification callback or
+ * any time afterwards.
+ */
+SSL_IMPORT SECStatus SSL_GetStapledOCSPResponse(PRFileDesc *fd,
+						unsigned char *out_data,
+						unsigned int *len);
+
 /*
 ** Authenticate certificate hook. Called when a certificate comes in
 ** (because of SSL_REQUIRE_CERTIFICATE in SSL_Enable) to authenticate the
@@ -485,16 +473,6 @@ SSL_IMPORT SECStatus SSL_PeerCertificateChain(
 ** See the documentation for SSL_AuthCertificateComplete for more information
 ** about the asynchronous behavior that occurs when the authenticate
 ** certificate hook returns SECWouldBlock.
-**
-** RFC 6066 says that clients should send the bad_certificate_status_response
-** alert when they encounter an error processing the stapled OCSP response.
-** libssl does not provide a way for the authenticate certificate hook to
-** indicate that an OCSP error (SEC_ERROR_OCSP_*) that it returns is an error
-** in the stapled OCSP response or an error in some other OCSP response.
-** Further, NSS does not provide a convenient way to control or determine
-** which OCSP response(s) were used to validate a certificate chain.
-** Consequently, the current version of libssl does not ever send the
-** bad_certificate_status_response alert. This may change in future releases.
 */
 typedef SECStatus (PR_CALLBACK *SSLAuthCertificate)(void *arg, PRFileDesc *fd, 
                                                     PRBool checkSig,
diff --git a/src/net/third_party/nss/ssl/ssl3con.c b/src/net/third_party/nss/ssl/ssl3con.c
index 00c83db..541d8a2 100644
--- a/src/net/third_party/nss/ssl/ssl3con.c
+++ b/src/net/third_party/nss/ssl/ssl3con.c
@@ -5,7 +5,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: ssl3con.c,v 1.192 2012/09/28 05:10:25 wtc%google.com Exp $ */
 
 /* TODO(ekr): Implement HelloVerifyRequest on server side. OK for now. */
 
@@ -15,7 +15,6 @@
 #include "keyhi.h"
 #include "secder.h"
 #include "secitem.h"
-#include "sechash.h"
 
 #include "sslimpl.h"
 #include "sslproto.h"
@@ -32,15 +31,6 @@
 #include "blapi.h"
 #endif
 
-/* This is a bodge to allow this code to be compiled against older NSS headers
- * that don't contain the TLS 1.2 changes. */
-#ifndef CKM_NSS_TLS_PRF_GENERAL_SHA256
-#define CKM_NSS_TLS_PRF_GENERAL_SHA256          (CKM_NSS + 21)
-#define CKM_NSS_TLS_MASTER_KEY_DERIVE_SHA256    (CKM_NSS + 22)
-#define CKM_NSS_TLS_KEY_AND_MAC_DERIVE_SHA256   (CKM_NSS + 23)
-#define CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256 (CKM_NSS + 24)
-#endif
-
 #include <stdio.h>
 #ifdef NSS_ENABLE_ZLIB
 #include "zlib.h"
@@ -60,7 +50,6 @@ static SECStatus ssl3_DeriveConnectionKeysPKCS11(sslSocket *ss);
 static SECStatus ssl3_HandshakeFailure(      sslSocket *ss);
 static SECStatus ssl3_InitState(             sslSocket *ss);
 static SECStatus ssl3_SendCertificate(       sslSocket *ss);
-static SECStatus ssl3_SendCertificateStatus( sslSocket *ss);
 static SECStatus ssl3_SendEmptyCertificate(  sslSocket *ss);
 static SECStatus ssl3_SendCertificateRequest(sslSocket *ss);
 static SECStatus ssl3_SendNextProto(         sslSocket *ss);
@@ -69,11 +58,11 @@ static SECStatus ssl3_SendFinished(          sslSocket *ss, PRInt32 flags);
 static SECStatus ssl3_SendServerHello(       sslSocket *ss);
 static SECStatus ssl3_SendServerHelloDone(   sslSocket *ss);
 static SECStatus ssl3_SendServerKeyExchange( sslSocket *ss);
+static SECStatus ssl3_NewHandshakeHashes(    sslSocket *ss);
 static SECStatus ssl3_UpdateHandshakeHashes( sslSocket *ss,
                                              const unsigned char *b,
                                              unsigned int l);
 static SECStatus ssl3_FlushHandshakeMessages(sslSocket *ss, PRInt32 flags);
-static int       ssl3_OIDToTLSHashAlgorithm(SECOidTag oid);
 
 static SECStatus Null_Cipher(void *ctx, unsigned char *output, int *outputLen,
 			     int maxOutputLen, const unsigned char *input,
@@ -96,7 +85,6 @@ static ssl3CipherSuiteCfg cipherSuites[ssl_V3_SUITES_IMPLEMENTED] = {
  { TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_DHE_RSA_WITH_AES_256_CBC_SHA, 	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- { TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,    SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
  { TLS_DHE_DSS_WITH_AES_256_CBC_SHA, 	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
 #ifdef NSS_ENABLE_ECC
  { TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,      SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
@@ -104,21 +92,17 @@ static ssl3CipherSuiteCfg cipherSuites[ssl_V3_SUITES_IMPLEMENTED] = {
 #endif /* NSS_ENABLE_ECC */
  { TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,  	   SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_RSA_WITH_AES_256_CBC_SHA,     	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- { TLS_RSA_WITH_AES_256_CBC_SHA256,	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
 
 #ifdef NSS_ENABLE_ECC
  { TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,       SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,   SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
- { TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_ECDHE_RSA_WITH_RC4_128_SHA,         SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,     SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
- { TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
 #endif /* NSS_ENABLE_ECC */
  { TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_DHE_DSS_WITH_RC4_128_SHA,           SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { TLS_DHE_RSA_WITH_AES_128_CBC_SHA,       SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- { TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,    SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
  { TLS_DHE_DSS_WITH_AES_128_CBC_SHA, 	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
 #ifdef NSS_ENABLE_ECC
  { TLS_ECDH_RSA_WITH_RC4_128_SHA,          SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
@@ -131,7 +115,6 @@ static ssl3CipherSuiteCfg cipherSuites[ssl_V3_SUITES_IMPLEMENTED] = {
  { SSL_RSA_WITH_RC4_128_SHA,               SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
  { SSL_RSA_WITH_RC4_128_MD5,               SSL_NOT_ALLOWED, PR_TRUE, PR_FALSE},
  { TLS_RSA_WITH_AES_128_CBC_SHA,     	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
- { TLS_RSA_WITH_AES_128_CBC_SHA256,	   SSL_NOT_ALLOWED, PR_TRUE,PR_FALSE},
 
 #ifdef NSS_ENABLE_ECC
  { TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
@@ -164,7 +147,6 @@ static ssl3CipherSuiteCfg cipherSuites[ssl_V3_SUITES_IMPLEMENTED] = {
  { TLS_ECDH_ECDSA_WITH_NULL_SHA,           SSL_NOT_ALLOWED, PR_FALSE, PR_FALSE},
 #endif /* NSS_ENABLE_ECC */
  { SSL_RSA_WITH_NULL_SHA,                  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
- { TLS_RSA_WITH_NULL_SHA256,               SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
  { SSL_RSA_WITH_NULL_MD5,                  SSL_NOT_ALLOWED, PR_FALSE,PR_FALSE},
 
 };
@@ -202,25 +184,10 @@ compressionEnabled(sslSocket *ss, SSLCompressionMethod compression)
 
 static const /*SSL3ClientCertificateType */ uint8 certificate_types [] = {
     ct_RSA_sign,
+    ct_DSS_sign,
 #ifdef NSS_ENABLE_ECC
     ct_ECDSA_sign,
 #endif /* NSS_ENABLE_ECC */
-    ct_DSS_sign,
-};
-
-/* This block is our supported_signature_algorithms value, in wire format.
- * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-static const PRUint8 supported_signature_algorithms[] = {
-    tls_hash_sha256, tls_sig_rsa,
-    tls_hash_sha384, tls_sig_rsa,
-    tls_hash_sha1,   tls_sig_rsa,
-#ifdef NSS_ENABLE_ECC
-    tls_hash_sha256, tls_sig_ecdsa,
-    tls_hash_sha384, tls_sig_ecdsa,
-    tls_hash_sha1,   tls_sig_ecdsa,
-#endif
-    tls_hash_sha256, tls_sig_dsa,
-    tls_hash_sha1,   tls_sig_dsa,
 };
 
 #define EXPORT_RSA_KEY_LENGTH 64	/* bytes */
@@ -288,7 +255,6 @@ static const ssl3CipherSuiteDef cipher_suite_defs[] =
     {SSL_NULL_WITH_NULL_NULL,       cipher_null,   mac_null, kea_null},
     {SSL_RSA_WITH_NULL_MD5,         cipher_null,   mac_md5, kea_rsa},
     {SSL_RSA_WITH_NULL_SHA,         cipher_null,   mac_sha, kea_rsa},
-    {TLS_RSA_WITH_NULL_SHA256,      cipher_null,   hmac_sha256, kea_rsa},
     {SSL_RSA_EXPORT_WITH_RC4_40_MD5,cipher_rc4_40, mac_md5, kea_rsa_export},
     {SSL_RSA_WITH_RC4_128_MD5,      cipher_rc4,    mac_md5, kea_rsa},
     {SSL_RSA_WITH_RC4_128_SHA,      cipher_rc4,    mac_sha, kea_rsa},
@@ -333,15 +299,11 @@ static const ssl3CipherSuiteDef cipher_suite_defs[] =
 
 /* New TLS cipher suites */
     {TLS_RSA_WITH_AES_128_CBC_SHA,     	cipher_aes_128, mac_sha, kea_rsa},
-    {TLS_RSA_WITH_AES_128_CBC_SHA256,	cipher_aes_128, hmac_sha256, kea_rsa},
     {TLS_DHE_DSS_WITH_AES_128_CBC_SHA, 	cipher_aes_128, mac_sha, kea_dhe_dss},
     {TLS_DHE_RSA_WITH_AES_128_CBC_SHA, 	cipher_aes_128, mac_sha, kea_dhe_rsa},
-    {TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, cipher_aes_128, hmac_sha256, kea_dhe_rsa},
     {TLS_RSA_WITH_AES_256_CBC_SHA,     	cipher_aes_256, mac_sha, kea_rsa},
-    {TLS_RSA_WITH_AES_256_CBC_SHA256,	cipher_aes_256, hmac_sha256, kea_rsa},
     {TLS_DHE_DSS_WITH_AES_256_CBC_SHA, 	cipher_aes_256, mac_sha, kea_dhe_dss},
     {TLS_DHE_RSA_WITH_AES_256_CBC_SHA, 	cipher_aes_256, mac_sha, kea_dhe_rsa},
-    {TLS_DHE_RSA_WITH_AES_256_CBC_SHA256, cipher_aes_256, hmac_sha256, kea_dhe_rsa},
 #if 0
     {TLS_DH_DSS_WITH_AES_128_CBC_SHA,  	cipher_aes_128, mac_sha, kea_dh_dss},
     {TLS_DH_RSA_WITH_AES_128_CBC_SHA,  	cipher_aes_128, mac_sha, kea_dh_rsa},
@@ -383,7 +345,6 @@ static const ssl3CipherSuiteDef cipher_suite_defs[] =
     {TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,      cipher_rc4, mac_sha, kea_ecdhe_ecdsa},
     {TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, cipher_3des, mac_sha, kea_ecdhe_ecdsa},
     {TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, cipher_aes_128, mac_sha, kea_ecdhe_ecdsa},
-    {TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, cipher_aes_128, hmac_sha256, kea_ecdhe_ecdsa},
     {TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, cipher_aes_256, mac_sha, kea_ecdhe_ecdsa},
 
     {TLS_ECDH_RSA_WITH_NULL_SHA,         cipher_null,    mac_sha, kea_ecdh_rsa},
@@ -396,7 +357,6 @@ static const ssl3CipherSuiteDef cipher_suite_defs[] =
     {TLS_ECDHE_RSA_WITH_RC4_128_SHA,      cipher_rc4,     mac_sha, kea_ecdhe_rsa},
     {TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, cipher_3des,    mac_sha, kea_ecdhe_rsa},
     {TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,  cipher_aes_128, mac_sha, kea_ecdhe_rsa},
-    {TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, cipher_aes_128, hmac_sha256, kea_ecdhe_rsa},
     {TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,  cipher_aes_256, mac_sha, kea_ecdhe_rsa},
 
 #if 0
@@ -443,17 +403,14 @@ static const SSLCipher2Mech alg2Mech[] = {
 #define mmech_sha      CKM_SSL3_SHA1_MAC
 #define mmech_md5_hmac CKM_MD5_HMAC
 #define mmech_sha_hmac CKM_SHA_1_HMAC
-#define mmech_sha256_hmac CKM_SHA256_HMAC
 
 static const ssl3MACDef mac_defs[] = { /* indexed by SSL3MACAlgorithm */
-    /* pad_size is only used for SSL 3.0 MAC. See RFC 6101 Sec. 5.2.3.1. */
     /* mac      mmech       pad_size  mac_size                       */
     { mac_null, mmech_null,       0,  0          },
     { mac_md5,  mmech_md5,       48,  MD5_LENGTH },
     { mac_sha,  mmech_sha,       40,  SHA1_LENGTH},
-    {hmac_md5,  mmech_md5_hmac,   0,  MD5_LENGTH },
-    {hmac_sha,  mmech_sha_hmac,   0,  SHA1_LENGTH},
-    {hmac_sha256, mmech_sha256_hmac, 0, SHA256_LENGTH},
+    {hmac_md5,  mmech_md5_hmac,  48,  MD5_LENGTH },
+    {hmac_sha,  mmech_sha_hmac,  40,  SHA1_LENGTH},
 };
 
 /* indexed by SSL3BulkCipher */
@@ -596,14 +553,6 @@ ssl3_CipherSuiteAllowedForVersion(ssl3CipherSuite cipherSuite,
      *   SSL_DH_ANON_EXPORT_WITH_DES40_CBC_SHA:  never implemented
      */
 	return version <= SSL_LIBRARY_VERSION_TLS_1_0;
-    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
-    case TLS_RSA_WITH_AES_256_CBC_SHA256:
-    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
-    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
-    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
-    case TLS_RSA_WITH_AES_128_CBC_SHA256:
-    case TLS_RSA_WITH_NULL_SHA256:
-	return version >= SSL_LIBRARY_VERSION_TLS_1_2;
     default:
 	return PR_TRUE;
     }
@@ -861,36 +810,32 @@ ssl3_SignHashes(SSL3Hashes *hash, SECKEYPrivateKey *key, SECItem *buf,
     SECItem   hashItem;
 
     buf->data    = NULL;
+    signatureLen = PK11_SignatureLen(key);
+    if (signatureLen <= 0) {
+	PORT_SetError(SEC_ERROR_INVALID_KEY);
+        goto done;
+    }
+
+    buf->len  = (unsigned)signatureLen;
+    buf->data = (unsigned char *)PORT_Alloc(signatureLen);
+    if (!buf->data)
+        goto done;	/* error code was set. */
 
     switch (key->keyType) {
     case rsaKey:
-	hashItem.data = hash->u.raw;
-	hashItem.len = hash->len;
+    	hashItem.data = hash->md5;
+    	hashItem.len = sizeof(SSL3Hashes);
 	break;
     case dsaKey:
 	doDerEncode = isTLS;
-	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-	 * In that case, we use just the SHA1 part. */
-	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-	    hashItem.data = hash->u.s.sha;
-	    hashItem.len = sizeof(hash->u.s.sha);
-	} else {
-	    hashItem.data = hash->u.raw;
-	    hashItem.len = hash->len;
-	}
+	hashItem.data = hash->sha;
+	hashItem.len = sizeof(hash->sha);
 	break;
 #ifdef NSS_ENABLE_ECC
     case ecKey:
 	doDerEncode = PR_TRUE;
-	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-	 * In that case, we use just the SHA1 part. */
-	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-	    hashItem.data = hash->u.s.sha;
-	    hashItem.len = sizeof(hash->u.s.sha);
-	} else {
-	    hashItem.data = hash->u.raw;
-	    hashItem.len = hash->len;
-	}
+	hashItem.data = hash->sha;
+	hashItem.len = sizeof(hash->sha);
 	break;
 #endif /* NSS_ENABLE_ECC */
     default:
@@ -899,22 +844,7 @@ ssl3_SignHashes(SSL3Hashes *hash, SECKEYPrivateKey *key, SECItem *buf,
     }
     PRINT_BUF(60, (NULL, "hash(es) to be signed", hashItem.data, hashItem.len));
 
-    if (hash->hashAlg == SEC_OID_UNKNOWN) {
-	signatureLen = PK11_SignatureLen(key);
-	if (signatureLen <= 0) {
-	    PORT_SetError(SEC_ERROR_INVALID_KEY);
-	    goto done;
-	}
-
-	buf->len  = (unsigned)signatureLen;
-	buf->data = (unsigned char *)PORT_Alloc(signatureLen);
-	if (!buf->data)
-	    goto done;  /* error code was set. */
-
-	rv = PK11_Sign(key, buf, &hashItem);
-    } else {
-	rv = SGN_Digest(key, hash->hashAlg, buf, &hashItem);
-    }
+    rv = PK11_Sign(key, buf, &hashItem);
     if (rv != SECSuccess) {
 	ssl_MapLowLevelError(SSL_ERROR_SIGN_HASHES_FAILURE);
     } else if (doDerEncode) {
@@ -948,8 +878,9 @@ ssl3_VerifySignedHashes(SSL3Hashes *hash, CERTCertificate *cert,
     SECItem *         signature	= NULL;
     SECStatus         rv;
     SECItem           hashItem;
-    SECOidTag         encAlg;
-    SECOidTag         hashAlg;
+#ifdef NSS_ENABLE_ECC
+    unsigned int      len;
+#endif /* NSS_ENABLE_ECC */
 
 
     PRINT_BUF(60, (NULL, "check signed hashes",
@@ -961,24 +892,14 @@ ssl3_VerifySignedHashes(SSL3Hashes *hash, CERTCertificate *cert,
     	return SECFailure;
     }
 
-    hashAlg = hash->hashAlg;
     switch (key->keyType) {
     case rsaKey:
-	encAlg = SEC_OID_PKCS1_RSA_ENCRYPTION;
-	hashItem.data = hash->u.raw;
-	hashItem.len = hash->len;
+    	hashItem.data = hash->md5;
+    	hashItem.len = sizeof(SSL3Hashes);
 	break;
     case dsaKey:
-	encAlg = SEC_OID_ANSIX9_DSA_SIGNATURE;
-	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-	 * In that case, we use just the SHA1 part. */
-	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-	    hashItem.data = hash->u.s.sha;
-	    hashItem.len = sizeof(hash->u.s.sha);
-	} else {
-	    hashItem.data = hash->u.raw;
-	    hashItem.len = hash->len;
-	}
+	hashItem.data = hash->sha;
+	hashItem.len = sizeof(hash->sha);
 	/* Allow DER encoded DSA signatures in SSL 3.0 */
 	if (isTLS || buf->len != SECKEY_SignatureLen(key)) {
 	    signature = DSAU_DecodeDerSig(buf);
@@ -992,21 +913,25 @@ ssl3_VerifySignedHashes(SSL3Hashes *hash, CERTCertificate *cert,
 
 #ifdef NSS_ENABLE_ECC
     case ecKey:
-	encAlg = SEC_OID_ANSIX962_EC_PUBLIC_KEY;
-	/* SEC_OID_UNKNOWN is used to specify the MD5/SHA1 concatenated hash.
-	 * In that case, we use just the SHA1 part.
-	 * ECDSA signatures always encode the integers r and s using ASN.1
-	 * (unlike DSA where ASN.1 encoding is used with TLS but not with
-	 * SSL3). So we can use VFY_VerifyDigestDirect for ECDSA.
+	hashItem.data = hash->sha;
+	hashItem.len = sizeof(hash->sha);
+	/*
+	 * ECDSA signatures always encode the integers r and s 
+	 * using ASN (unlike DSA where ASN encoding is used
+	 * with TLS but not with SSL3)
 	 */
-	if (hash->hashAlg == SEC_OID_UNKNOWN) {
-	    hashAlg = SEC_OID_SHA1;
-	    hashItem.data = hash->u.s.sha;
-	    hashItem.len = sizeof(hash->u.s.sha);
-	} else {
-	    hashItem.data = hash->u.raw;
-	    hashItem.len = hash->len;
+	len = SECKEY_SignatureLen(key);
+	if (len == 0) {
+	    SECKEY_DestroyPublicKey(key);
+	    PORT_SetError(SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE);
+	    return SECFailure;
 	}
+	signature = DSAU_DecodeDerSigToLen(buf, len);
+	if (!signature) {
+	    PORT_SetError(SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE);
+	    return SECFailure;
+	}
+	buf = signature;
 	break;
 #endif /* NSS_ENABLE_ECC */
 
@@ -1019,17 +944,7 @@ ssl3_VerifySignedHashes(SSL3Hashes *hash, CERTCertificate *cert,
     PRINT_BUF(60, (NULL, "hash(es) to be verified",
                   hashItem.data, hashItem.len));
 
-    if (hashAlg == SEC_OID_UNKNOWN || key->keyType == dsaKey) {
-	/* VFY_VerifyDigestDirect requires DSA signatures to be DER-encoded.
-	 * DSA signatures are DER-encoded in TLS but not in SSL3 and the code
-	 * above always removes the DER encoding of DSA signatures when
-	 * present. Thus DSA signatures are always verified with PK11_Verify.
-	 */
-	rv = PK11_Verify(key, buf, &hashItem, pwArg);
-    } else {
-	rv = VFY_VerifyDigestDirect(&hashItem, key, buf, encAlg, hashAlg,
-				    pwArg);
-    }
+    rv = PK11_Verify(key, buf, &hashItem, pwArg);
     SECKEY_DestroyPublicKey(key);
     if (signature) {
     	SECITEM_FreeItem(signature, PR_TRUE);
@@ -1045,72 +960,33 @@ ssl3_VerifySignedHashes(SSL3Hashes *hash, CERTCertificate *cert,
 /* Called from ssl3_ComputeExportRSAKeyHash
  *             ssl3_ComputeDHKeyHash
  * which are called from ssl3_HandleServerKeyExchange. 
- *
- * hashAlg: either the OID for a hash algorithm or SEC_OID_UNKNOWN to specify
- * the pre-1.2, MD5/SHA1 combination hash.
  */
 SECStatus
-ssl3_ComputeCommonKeyHash(SECOidTag hashAlg,
-			  PRUint8 * hashBuf, unsigned int bufLen,
-			  SSL3Hashes *hashes, PRBool bypassPKCS11)
+ssl3_ComputeCommonKeyHash(PRUint8 * hashBuf, unsigned int bufLen,
+			     SSL3Hashes *hashes, PRBool bypassPKCS11)
 {
     SECStatus     rv 		= SECSuccess;
 
 #ifndef NO_PKCS11_BYPASS
     if (bypassPKCS11) {
-	if (hashAlg == SEC_OID_UNKNOWN) {
-	    MD5_HashBuf (hashes->u.s.md5, hashBuf, bufLen);
-	    SHA1_HashBuf(hashes->u.s.sha, hashBuf, bufLen);
-	    hashes->len = MD5_LENGTH + SHA1_LENGTH;
-	} else if (hashAlg == SEC_OID_SHA1) {
-	    SHA1_HashBuf(hashes->u.raw, hashBuf, bufLen);
-	    hashes->len = SHA1_LENGTH;
-	} else if (hashAlg == SEC_OID_SHA256) {
-	    SHA256_HashBuf(hashes->u.raw, hashBuf, bufLen);
-	    hashes->len = SHA256_LENGTH;
-	} else if (hashAlg == SEC_OID_SHA384) {
-	    SHA384_HashBuf(hashes->u.raw, hashBuf, bufLen);
-	    hashes->len = SHA384_LENGTH;
-	} else if (hashAlg == SEC_OID_SHA512) {
-	    SHA512_HashBuf(hashes->u.raw, hashBuf, bufLen);
-	    hashes->len = SHA512_LENGTH;
-	} else {
-	    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-	    return SECFailure;
-	}
+	MD5_HashBuf (hashes->md5, hashBuf, bufLen);
+	SHA1_HashBuf(hashes->sha, hashBuf, bufLen);
     } else 
 #endif
     {
-	if (hashAlg == SEC_OID_UNKNOWN) {
-	    rv = PK11_HashBuf(SEC_OID_MD5, hashes->u.s.md5, hashBuf, bufLen);
-	    if (rv != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-		rv = SECFailure;
-		goto done;
-	    }
+	rv = PK11_HashBuf(SEC_OID_MD5, hashes->md5, hashBuf, bufLen);
+	if (rv != SECSuccess) {
+	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
+	    rv = SECFailure;
+	    goto done;
+	}
 
-	    rv = PK11_HashBuf(SEC_OID_SHA1, hashes->u.s.sha, hashBuf, bufLen);
-	    if (rv != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-		rv = SECFailure;
-	    }
-	    hashes->len = MD5_LENGTH + SHA1_LENGTH;
-	} else {
-	    hashes->len = HASH_ResultLenByOidTag(hashAlg);
-	    if (hashes->len > sizeof(hashes->u.raw)) {
-		ssl_MapLowLevelError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-		rv = SECFailure;
-		goto done;
-	    }
-	    rv = PK11_HashBuf(hashAlg, hashes->u.raw, hashBuf, bufLen);
-	    if (rv != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-		rv = SECFailure;
-	    }
+	rv = PK11_HashBuf(SEC_OID_SHA1, hashes->sha, hashBuf, bufLen);
+	if (rv != SECSuccess) {
+	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
+	    rv = SECFailure;
 	}
     }
-    hashes->hashAlg = hashAlg;
-
 done:
     return rv;
 }
@@ -1120,8 +996,7 @@ done:
 **             ssl3_HandleServerKeyExchange.
 */
 static SECStatus
-ssl3_ComputeExportRSAKeyHash(SECOidTag hashAlg,
-			     SECItem modulus, SECItem publicExponent,
+ssl3_ComputeExportRSAKeyHash(SECItem modulus, SECItem publicExponent,
 			     SSL3Random *client_rand, SSL3Random *server_rand,
 			     SSL3Hashes *hashes, PRBool bypassPKCS11)
 {
@@ -1157,19 +1032,11 @@ ssl3_ComputeExportRSAKeyHash(SECOidTag hashAlg,
     	pBuf += publicExponent.len;
     PORT_Assert((unsigned int)(pBuf - hashBuf) == bufLen);
 
-    rv = ssl3_ComputeCommonKeyHash(hashAlg, hashBuf, bufLen, hashes,
-				   bypassPKCS11);
+    rv = ssl3_ComputeCommonKeyHash(hashBuf, bufLen, hashes, bypassPKCS11);
 
     PRINT_BUF(95, (NULL, "RSAkey hash: ", hashBuf, bufLen));
-    if (hashAlg == SEC_OID_UNKNOWN) {
-	PRINT_BUF(95, (NULL, "RSAkey hash: MD5 result",
-		  hashes->u.s.md5, MD5_LENGTH));
-	PRINT_BUF(95, (NULL, "RSAkey hash: SHA1 result",
-		  hashes->u.s.sha, SHA1_LENGTH));
-    } else {
-	PRINT_BUF(95, (NULL, "RSAkey hash: result",
-		  hashes->u.raw, hashes->len));
-    }
+    PRINT_BUF(95, (NULL, "RSAkey hash: MD5 result", hashes->md5, MD5_LENGTH));
+    PRINT_BUF(95, (NULL, "RSAkey hash: SHA1 result", hashes->sha, SHA1_LENGTH));
 
     if (hashBuf != buf && hashBuf != NULL)
     	PORT_Free(hashBuf);
@@ -1179,10 +1046,9 @@ ssl3_ComputeExportRSAKeyHash(SECOidTag hashAlg,
 /* Caller must set hiLevel error code. */
 /* Called from ssl3_HandleServerKeyExchange. */
 static SECStatus
-ssl3_ComputeDHKeyHash(SECOidTag hashAlg,
-		      SECItem dh_p, SECItem dh_g, SECItem dh_Ys,
-		      SSL3Random *client_rand, SSL3Random *server_rand,
-		      SSL3Hashes *hashes, PRBool bypassPKCS11)
+ssl3_ComputeDHKeyHash(SECItem dh_p, SECItem dh_g, SECItem dh_Ys,
+			     SSL3Random *client_rand, SSL3Random *server_rand,
+			     SSL3Hashes *hashes, PRBool bypassPKCS11)
 {
     PRUint8     * hashBuf;
     PRUint8     * pBuf;
@@ -1221,19 +1087,11 @@ ssl3_ComputeDHKeyHash(SECOidTag hashAlg,
     	pBuf += dh_Ys.len;
     PORT_Assert((unsigned int)(pBuf - hashBuf) == bufLen);
 
-    rv = ssl3_ComputeCommonKeyHash(hashAlg, hashBuf, bufLen, hashes,
-				   bypassPKCS11);
+    rv = ssl3_ComputeCommonKeyHash(hashBuf, bufLen, hashes, bypassPKCS11);
 
     PRINT_BUF(95, (NULL, "DHkey hash: ", hashBuf, bufLen));
-    if (hashAlg == SEC_OID_UNKNOWN) {
-	PRINT_BUF(95, (NULL, "DHkey hash: MD5 result",
-		  hashes->u.s.md5, MD5_LENGTH));
-	PRINT_BUF(95, (NULL, "DHkey hash: SHA1 result",
-		  hashes->u.s.sha, SHA1_LENGTH));
-    } else {
-	PRINT_BUF(95, (NULL, "DHkey hash: result",
-		  hashes->u.raw, hashes->len));
-    }
+    PRINT_BUF(95, (NULL, "DHkey hash: MD5 result", hashes->md5, MD5_LENGTH));
+    PRINT_BUF(95, (NULL, "DHkey hash: SHA1 result", hashes->sha, SHA1_LENGTH));
 
     if (hashBuf != buf && hashBuf != NULL)
     	PORT_Free(hashBuf);
@@ -1361,7 +1219,7 @@ ssl3_SetupPendingCipherSpec(sslSocket *ss)
     cipher = suite_def->bulk_cipher_alg;
     kea    = suite_def->key_exchange_alg;
     mac    = suite_def->mac_alg;
-    if (mac <= ssl_mac_sha && isTLS)
+    if (isTLS)
 	mac += 2;
 
     ss->ssl3.hs.suite_def = suite_def;
@@ -1537,8 +1395,7 @@ ssl3_InitCompressionContext(ssl3CipherSpec *pwSpec)
 }
 
 #ifndef NO_PKCS11_BYPASS
-/* Initialize encryption contexts for pending spec.
- * MAC contexts are set up when computing the mac, not here.
+/* Initialize encryption and MAC contexts for pending spec.
  * Master Secret already is derived in spec->msItem
  * Caller holds Spec write lock.
  */
@@ -1554,6 +1411,7 @@ ssl3_InitPendingContextsBypass(sslSocket *ss)
       unsigned int       optArg1  = 0;
       unsigned int       optArg2  = 0;
       PRBool             server_encrypts = ss->sec.isServer;
+      CK_ULONG           macLength;
       SSLCipherAlgorithm calg;
       SSLCompressionMethod compression_method;
       SECStatus          rv;
@@ -1564,6 +1422,11 @@ ssl3_InitPendingContextsBypass(sslSocket *ss)
 
     pwSpec        = ss->ssl3.pwSpec;
     cipher_def    = pwSpec->cipher_def;
+    macLength     = pwSpec->mac_size;
+
+    /* MAC setup is done when computing the mac, not here.
+     * Now setup the crypto contexts.
+     */
 
     calg = cipher_def->calg;
     compression_method = pwSpec->compression_method;
@@ -2082,9 +1945,6 @@ ssl3_ComputeRecordMAC(
 	case ssl_hmac_sha: /* used with TLS */
 	    hashObj = HASH_GetRawHashObject(HASH_AlgSHA1);
 	    break;
-	case ssl_hmac_sha256: /* used with TLS */
-	    hashObj = HASH_GetRawHashObject(HASH_AlgSHA256);
-	    break;
 	default:
 	    break;
 	}
@@ -3329,8 +3189,6 @@ ssl3_DeriveMasterSecret(sslSocket *ss, PK11SymKey *pms)
     unsigned char *   sr     = (unsigned char *)&ss->ssl3.hs.server_random;
     PRBool            isTLS  = (PRBool)(kea_def->tls_keygen ||
                                 (pwSpec->version > SSL_LIBRARY_VERSION_3_0));
-    PRBool            isTLS12=
-	    (PRBool)(isTLS && pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
     /* 
      * Whenever isDH is true, we need to use CKM_TLS_MASTER_KEY_DERIVE_DH
      * which, unlike CKM_TLS_MASTER_KEY_DERIVE, converts arbitrary size
@@ -3349,12 +3207,7 @@ ssl3_DeriveMasterSecret(sslSocket *ss, PK11SymKey *pms)
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
     PORT_Assert( ss->opt.noLocks || ssl_HaveSpecWriteLock(ss));
     PORT_Assert(ss->ssl3.prSpec == ss->ssl3.pwSpec);
-    if (isTLS12) {
-	if(isDH) master_derive = CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256;
-	else master_derive = CKM_NSS_TLS_MASTER_KEY_DERIVE_SHA256;
-	key_derive    = CKM_NSS_TLS_KEY_AND_MAC_DERIVE_SHA256;
-	keyFlags      = CKF_SIGN | CKF_VERIFY;
-    } else if (isTLS) {
+    if (isTLS) {
 	if(isDH) master_derive = CKM_TLS_MASTER_KEY_DERIVE_DH;
 	else master_derive = CKM_TLS_MASTER_KEY_DERIVE;
 	key_derive    = CKM_TLS_KEY_AND_MAC_DERIVE;
@@ -3456,6 +3309,18 @@ ssl3_DeriveMasterSecret(sslSocket *ss, PK11SymKey *pms)
 	 */
 	rv = PK11_ExtractKeyValue(pwSpec->master_secret);
 	if (rv != SECSuccess) {
+#if defined(NSS_SURVIVE_DOUBLE_BYPASS_FAILURE)
+	    /* The double bypass failed.  
+	     * Attempt to revert to an all PKCS#11, non-bypass method.
+	     * Do we need any unacquired locks here?
+	     */
+	    ss->opt.bypassPKCS11 = 0;
+	    rv = ssl3_NewHandshakeHashes(ss);
+	    if (rv == SECSuccess) {
+		rv = ssl3_UpdateHandshakeHashes(ss, ss->ssl3.hs.messages.buf, 
+		                                    ss->ssl3.hs.messages.len);
+	    }
+#endif
 	    return rv;
 	} 
 	/* This returns the address of the secItem inside the key struct,
@@ -3500,8 +3365,6 @@ ssl3_DeriveConnectionKeysPKCS11(sslSocket *ss)
     unsigned char *   sr     = (unsigned char *)&ss->ssl3.hs.server_random;
     PRBool            isTLS  = (PRBool)(kea_def->tls_keygen ||
                                 (pwSpec->version > SSL_LIBRARY_VERSION_3_0));
-    PRBool            isTLS12=
-	    (PRBool)(isTLS && pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
     /* following variables used in PKCS11 path */
     const ssl3BulkCipherDef *cipher_def = pwSpec->cipher_def;
     PK11SlotInfo *         slot   = NULL;
@@ -3530,13 +3393,6 @@ ssl3_DeriveConnectionKeysPKCS11(sslSocket *ss)
     key_material_params.ulMacSizeInBits = pwSpec->mac_size           * BPB;
     key_material_params.ulKeySizeInBits = cipher_def->secret_key_size* BPB;
     key_material_params.ulIVSizeInBits  = cipher_def->iv_size        * BPB;
-    if (cipher_def->type == type_block &&
-	pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_1) {
-	/* Block ciphers in >= TLS 1.1 use a per-record, explicit IV. */
-	key_material_params.ulIVSizeInBits = 0;
-	memset(pwSpec->client.write_iv, 0, cipher_def->iv_size);
-	memset(pwSpec->server.write_iv, 0, cipher_def->iv_size);
-    }
 
     key_material_params.bIsExport = (CK_BBOOL)(kea_def->is_limited);
     /* was:	(CK_BBOOL)(cipher_def->keygen_mode != kg_strong); */
@@ -3566,9 +3422,7 @@ ssl3_DeriveConnectionKeysPKCS11(sslSocket *ss)
     params.data    = (unsigned char *)&key_material_params;
     params.len     = sizeof(key_material_params);
 
-    if (isTLS12) {
-	key_derive    = CKM_NSS_TLS_KEY_AND_MAC_DERIVE_SHA256;
-    } else if (isTLS) {
+    if (isTLS) {
 	key_derive    = CKM_TLS_KEY_AND_MAC_DERIVE;
     } else {
 	key_derive    = CKM_SSL3_KEY_AND_MAC_DERIVE;
@@ -3625,128 +3479,85 @@ loser:
     return SECFailure;
 }
 
-/* ssl3_InitHandshakeHashes creates handshake hash contexts and hashes in
- * buffered messages in ss->ssl3.hs.messages. */
-static SECStatus
-ssl3_InitHandshakeHashes(sslSocket *ss)
+static SECStatus 
+ssl3_RestartHandshakeHashes(sslSocket *ss)
 {
-    SSL_TRC(30,("%d: SSL3[%d]: start handshake hashes", SSL_GETPID(), ss->fd));
+    SECStatus rv = SECSuccess;
 
-    PORT_Assert(ss->ssl3.hs.hashType == handshake_hash_unknown);
 #ifndef NO_PKCS11_BYPASS
     if (ss->opt.bypassPKCS11) {
-	PORT_Assert(!ss->ssl3.hs.sha_obj && !ss->ssl3.hs.sha_clone);
-	if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-	    /* If we ever support ciphersuites where the PRF hash isn't SHA-256
-	     * then this will need to be updated. */
-	    ss->ssl3.hs.sha_obj = HASH_GetRawHashObject(HASH_AlgSHA256);
-	    if (!ss->ssl3.hs.sha_obj) {
-		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-		return SECFailure;
-	    }
-	    ss->ssl3.hs.sha_clone = (void (*)(void *, void *))SHA256_Clone;
-	    ss->ssl3.hs.hashType = handshake_hash_single;
-	    ss->ssl3.hs.sha_obj->begin(ss->ssl3.hs.sha_cx);
-	} else {
-	    ss->ssl3.hs.hashType = handshake_hash_combo;
-	    MD5_Begin((MD5Context *)ss->ssl3.hs.md5_cx);
-	    SHA1_Begin((SHA1Context *)ss->ssl3.hs.sha_cx);
-	}
-    } else
+	ss->ssl3.hs.messages.len = 0;
+	MD5_Begin((MD5Context *)ss->ssl3.hs.md5_cx);
+	SHA1_Begin((SHA1Context *)ss->ssl3.hs.sha_cx);
+    } else 
 #endif
     {
-	PORT_Assert(!ss->ssl3.hs.md5 && !ss->ssl3.hs.sha);
-	/*
-	 * note: We should probably lookup an SSL3 slot for these
-	 * handshake hashes in hopes that we wind up with the same slots
-	 * that the master secret will wind up in ...
-	 */
-	if (ss->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-	    /* If we ever support ciphersuites where the PRF hash isn't SHA-256
-	     * then this will need to be updated. */
-	    ss->ssl3.hs.sha = PK11_CreateDigestContext(SEC_OID_SHA256);
-	    if (ss->ssl3.hs.sha == NULL) {
-		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-		return SECFailure;
-	    }
-	    ss->ssl3.hs.hashType = handshake_hash_single;
-
-	    if (PK11_DigestBegin(ss->ssl3.hs.sha) != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-		return SECFailure;
-	    }
-	} else {
-	    /* Both ss->ssl3.hs.md5 and ss->ssl3.hs.sha should be NULL or
-	     * created successfully. */
-	    ss->ssl3.hs.md5 = PK11_CreateDigestContext(SEC_OID_MD5);
-	    if (ss->ssl3.hs.md5 == NULL) {
-		ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-		return SECFailure;
-	    }
-	    ss->ssl3.hs.sha = PK11_CreateDigestContext(SEC_OID_SHA1);
-	    if (ss->ssl3.hs.sha == NULL) {
-		PK11_DestroyContext(ss->ssl3.hs.md5, PR_TRUE);
-		ss->ssl3.hs.md5 = NULL;
-		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-		return SECFailure;
-	    }
-	    ss->ssl3.hs.hashType = handshake_hash_combo;
-
-	    if (PK11_DigestBegin(ss->ssl3.hs.md5) != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-		return SECFailure;
-	    }
-	    if (PK11_DigestBegin(ss->ssl3.hs.sha) != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-		return SECFailure;
-	    }
+	rv = PK11_DigestBegin(ss->ssl3.hs.md5);
+	if (rv != SECSuccess) {
+	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
+	    return rv;
 	}
-    }
-
-    if (ss->ssl3.hs.messages.len > 0) {
-	if (ssl3_UpdateHandshakeHashes(ss, ss->ssl3.hs.messages.buf,
-				       ss->ssl3.hs.messages.len) !=
-	    SECSuccess) {
-	    return SECFailure;
+	rv = PK11_DigestBegin(ss->ssl3.hs.sha);
+	if (rv != SECSuccess) {
+	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
+	    return rv;
 	}
-	PORT_Free(ss->ssl3.hs.messages.buf);
-	ss->ssl3.hs.messages.buf = NULL;
-	ss->ssl3.hs.messages.len = 0;
-	ss->ssl3.hs.messages.space = 0;
     }
-
-    return SECSuccess;
+    return rv;
 }
 
-static SECStatus 
-ssl3_RestartHandshakeHashes(sslSocket *ss)
+static SECStatus
+ssl3_NewHandshakeHashes(sslSocket *ss)
 {
-    SECStatus rv = SECSuccess;
+    PK11Context *md5  = NULL;
+    PK11Context *sha  = NULL;
 
-    SSL_TRC(30,("%d: SSL3[%d]: reset handshake hashes",
-	    SSL_GETPID(), ss->fd ));
-    ss->ssl3.hs.hashType = handshake_hash_unknown;
-    ss->ssl3.hs.messages.len = 0;
+    /*
+     * note: We should probably lookup an SSL3 slot for these
+     * handshake hashes in hopes that we wind up with the same slots
+     * that the master secret will wind up in ...
+     */
+    SSL_TRC(30,("%d: SSL3[%d]: start handshake hashes", SSL_GETPID(), ss->fd));
 #ifndef NO_PKCS11_BYPASS
-    ss->ssl3.hs.sha_obj = NULL;
-    ss->ssl3.hs.sha_clone = NULL;
+    if (ss->opt.bypassPKCS11) {
+	PORT_Assert(!ss->ssl3.hs.messages.buf && !ss->ssl3.hs.messages.space);
+	ss->ssl3.hs.messages.buf = NULL;
+	ss->ssl3.hs.messages.space = 0;
+    } else 
 #endif
-    if (ss->ssl3.hs.md5) {
-	PK11_DestroyContext(ss->ssl3.hs.md5,PR_TRUE);
+    {
+	ss->ssl3.hs.md5 = md5 = PK11_CreateDigestContext(SEC_OID_MD5);
+	ss->ssl3.hs.sha = sha = PK11_CreateDigestContext(SEC_OID_SHA1);
+	if (md5 == NULL) {
+	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
+	    goto loser;
+	}
+	if (sha == NULL) {
+	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
+	    goto loser;
+	}
+    }
+    if (SECSuccess == ssl3_RestartHandshakeHashes(ss)) {
+	return SECSuccess;
+    }
+
+loser:
+    if (md5 != NULL) {
+    	PK11_DestroyContext(md5, PR_TRUE);
 	ss->ssl3.hs.md5 = NULL;
     }
-    if (ss->ssl3.hs.sha) {
-	PK11_DestroyContext(ss->ssl3.hs.sha,PR_TRUE);
+    if (sha != NULL) {
+    	PK11_DestroyContext(sha, PR_TRUE);
 	ss->ssl3.hs.sha = NULL;
     }
-    return rv;
+    return SECFailure;
+
 }
 
 /*
  * Handshake messages
  */
-/* Called from	ssl3_InitHandshakeHashes()
-**		ssl3_AppendHandshake()
+/* Called from	ssl3_AppendHandshake()
 **		ssl3_StartHandshakeHash()
 **		ssl3_HandleV2ClientHello()
 **		ssl3_HandleHandshakeMessage()
@@ -3760,42 +3571,27 @@ ssl3_UpdateHandshakeHashes(sslSocket *ss, const unsigned char *b,
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
 
-    /* We need to buffer the handshake messages until we have established
-     * which handshake hash function to use. */
-    if (ss->ssl3.hs.hashType == handshake_hash_unknown) {
-	return sslBuffer_Append(&ss->ssl3.hs.messages, b, l);
-    }
-
-    PRINT_BUF(90, (NULL, "handshake hash input:", b, l));
+    PRINT_BUF(90, (NULL, "MD5 & SHA handshake hash input:", b, l));
 
 #ifndef NO_PKCS11_BYPASS
     if (ss->opt.bypassPKCS11) {
-	if (ss->ssl3.hs.hashType == handshake_hash_single) {
-	    ss->ssl3.hs.sha_obj->update(ss->ssl3.hs.sha_cx, b, l);
-	} else {
-	    MD5_Update((MD5Context *)ss->ssl3.hs.md5_cx, b, l);
-	    SHA1_Update((SHA1Context *)ss->ssl3.hs.sha_cx, b, l);
-	}
+	MD5_Update((MD5Context *)ss->ssl3.hs.md5_cx, b, l);
+	SHA1_Update((SHA1Context *)ss->ssl3.hs.sha_cx, b, l);
+#if defined(NSS_SURVIVE_DOUBLE_BYPASS_FAILURE)
+	rv = sslBuffer_Append(&ss->ssl3.hs.messages, b, l);
+#endif
 	return rv;
     }
 #endif
-    if (ss->ssl3.hs.hashType == handshake_hash_single) {
-	rv = PK11_DigestOp(ss->ssl3.hs.sha, b, l);
-	if (rv != SECSuccess) {
-	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-	    return rv;
-	}
-    } else {
-	rv = PK11_DigestOp(ss->ssl3.hs.md5, b, l);
-	if (rv != SECSuccess) {
-	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
-	    return rv;
-	}
-	rv = PK11_DigestOp(ss->ssl3.hs.sha, b, l);
-	if (rv != SECSuccess) {
-	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
-	    return rv;
-	}
+    rv = PK11_DigestOp(ss->ssl3.hs.md5, b, l);
+    if (rv != SECSuccess) {
+	ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
+	return rv;
+    }
+    rv = PK11_DigestOp(ss->ssl3.hs.sha, b, l);
+    if (rv != SECSuccess) {
+	ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
+	return rv;
     }
     return rv;
 }
@@ -3908,6 +3704,10 @@ ssl3_AppendHandshakeHeader(sslSocket *ss, SSL3HandshakeType t, PRUint32 length)
 
     SSL_TRC(30,("%d: SSL3[%d]: append handshake header: type %s",
     	SSL_GETPID(), ss->fd, ssl3_DecodeHandshakeType(t)));
+    PRINT_BUF(60, (ss, "MD5 handshake hash:",
+    	          (unsigned char*)ss->ssl3.hs.md5_cx, MD5_LENGTH));
+    PRINT_BUF(95, (ss, "SHA handshake hash:",
+    	          (unsigned char*)ss->ssl3.hs.sha_cx, SHA1_LENGTH));
 
     rv = ssl3_AppendHandshakeNumber(ss, t, 1);
     if (rv != SECSuccess) {
@@ -3943,42 +3743,6 @@ ssl3_AppendHandshakeHeader(sslSocket *ss, SSL3HandshakeType t, PRUint32 length)
     return rv;		/* error code set by AppendHandshake, if applicable. */
 }
 
-/* ssl3_AppendSignatureAndHashAlgorithm appends the serialisation of
- * |sigAndHash| to the current handshake message. */
-SECStatus
-ssl3_AppendSignatureAndHashAlgorithm(
-	sslSocket *ss, const SSL3SignatureAndHashAlgorithm* sigAndHash)
-{
-    unsigned char serialized[2];
-
-    serialized[0] = ssl3_OIDToTLSHashAlgorithm(sigAndHash->hashAlg);
-    if (serialized[0] == 0) {
-	PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-	return SECFailure;
-    }
-
-    serialized[1] = sigAndHash->sigAlg;
-
-    return ssl3_AppendHandshake(ss, serialized, sizeof(serialized));
-}
-
-/* Appends our supported_signature_algorithms value to the current handshake
- * message. */
-SECStatus
-ssl3_AppendSupportedSignatureAlgorithms(sslSocket *ss)
-{
-    return ssl3_AppendHandshakeVariable(ss, supported_signature_algorithms,
-					sizeof supported_signature_algorithms,
-					2);
-}
-
-/* Returns the size in bytes of our supported_signature_algorithms value. */
-unsigned int
-ssl3_SizeOfSupportedSignatureAlgorithms(void)
-{
-    return sizeof supported_signature_algorithms;
-}
-
 /**************************************************************************
  * Consume Handshake functions.
  *
@@ -4085,147 +3849,6 @@ ssl3_ConsumeHandshakeVariable(sslSocket *ss, SECItem *i, PRInt32 bytes,
     return SECSuccess;
 }
 
-/* tlsHashOIDMap contains the mapping between TLS hash identifiers and the
- * SECOidTag used internally by NSS. */
-static const struct {
-    int tlsHash;
-    SECOidTag oid;
-} tlsHashOIDMap[] = {
-    { tls_hash_md5, SEC_OID_MD5 },
-    { tls_hash_sha1, SEC_OID_SHA1 },
-    { tls_hash_sha224, SEC_OID_SHA224 },
-    { tls_hash_sha256, SEC_OID_SHA256 },
-    { tls_hash_sha384, SEC_OID_SHA384 },
-    { tls_hash_sha512, SEC_OID_SHA512 }
-};
-
-/* ssl3_TLSHashAlgorithmToOID converts a TLS hash identifier into an OID value.
- * If the hash is not recognised, SEC_OID_UNKNOWN is returned.
- *
- * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-SECOidTag
-ssl3_TLSHashAlgorithmToOID(int hashFunc)
-{
-    unsigned int i;
-
-    for (i = 0; i < PR_ARRAY_SIZE(tlsHashOIDMap); i++) {
-	if (hashFunc == tlsHashOIDMap[i].tlsHash) {
-	    return tlsHashOIDMap[i].oid;
-	}
-    }
-    return SEC_OID_UNKNOWN;
-}
-
-/* ssl3_OIDToTLSHashAlgorithm converts an OID to a TLS hash algorithm
- * identifier. If the hash is not recognised, zero is returned.
- *
- * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-static int
-ssl3_OIDToTLSHashAlgorithm(SECOidTag oid)
-{
-    unsigned int i;
-
-    for (i = 0; i < PR_ARRAY_SIZE(tlsHashOIDMap); i++) {
-	if (oid == tlsHashOIDMap[i].oid) {
-	    return tlsHashOIDMap[i].tlsHash;
-	}
-    }
-    return 0;
-}
-
-/* ssl3_TLSSignatureAlgorithmForKeyType returns the TLS 1.2 signature algorithm
- * identifier for a given KeyType. */
-static SECStatus
-ssl3_TLSSignatureAlgorithmForKeyType(KeyType keyType,
-				     TLSSignatureAlgorithm *out)
-{
-    switch (keyType) {
-    case rsaKey:
-	*out = tls_sig_rsa;
-	return SECSuccess;
-    case dsaKey:
-	*out = tls_sig_dsa;
-	return SECSuccess;
-    case ecKey:
-	*out = tls_sig_ecdsa;
-	return SECSuccess;
-    default:
-	PORT_SetError(SEC_ERROR_INVALID_KEY);
-	return SECFailure;
-    }
-}
-
-/* ssl3_TLSSignatureAlgorithmForCertificate returns the TLS 1.2 signature
- * algorithm identifier for the given certificate. */
-static SECStatus
-ssl3_TLSSignatureAlgorithmForCertificate(CERTCertificate *cert,
-					 TLSSignatureAlgorithm *out)
-{
-    SECKEYPublicKey *key;
-    KeyType keyType;
-
-    key = CERT_ExtractPublicKey(cert);
-    if (key == NULL) {
-	ssl_MapLowLevelError(SSL_ERROR_EXTRACT_PUBLIC_KEY_FAILURE);
-    	return SECFailure;
-    }
-
-    keyType = key->keyType;
-    SECKEY_DestroyPublicKey(key);
-    return ssl3_TLSSignatureAlgorithmForKeyType(keyType, out);
-}
-
-/* ssl3_CheckSignatureAndHashAlgorithmConsistency checks that the signature
- * algorithm identifier in |sigAndHash| is consistent with the public key in
- * |cert|. If so, SECSuccess is returned. Otherwise, PORT_SetError is called
- * and SECFailure is returned. */
-SECStatus
-ssl3_CheckSignatureAndHashAlgorithmConsistency(
-	const SSL3SignatureAndHashAlgorithm *sigAndHash, CERTCertificate* cert)
-{
-    SECStatus rv;
-    TLSSignatureAlgorithm sigAlg;
-
-    rv = ssl3_TLSSignatureAlgorithmForCertificate(cert, &sigAlg);
-    if (rv != SECSuccess) {
-	return rv;
-    }
-    if (sigAlg != sigAndHash->sigAlg) {
-	PORT_SetError(SSL_ERROR_INCORRECT_SIGNATURE_ALGORITHM);
-	return SECFailure;
-    }
-    return SECSuccess;
-}
-
-/* ssl3_ConsumeSignatureAndHashAlgorithm reads a SignatureAndHashAlgorithm
- * structure from |b| and puts the resulting value into |out|. |b| and |length|
- * are updated accordingly.
- *
- * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-SECStatus
-ssl3_ConsumeSignatureAndHashAlgorithm(sslSocket *ss,
-				      SSL3Opaque **b,
-				      PRUint32 *length,
-				      SSL3SignatureAndHashAlgorithm *out)
-{
-    unsigned char bytes[2];
-    SECStatus rv;
-
-    rv = ssl3_ConsumeHandshake(ss, bytes, sizeof(bytes), b, length);
-    if (rv != SECSuccess) {
-	return rv;
-    }
-
-    out->hashAlg = ssl3_TLSHashAlgorithmToOID(bytes[0]);
-    if (out->hashAlg == SEC_OID_UNKNOWN) {
-	PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-	return SECFailure;
-    }
-
-    out->sigAlg = bytes[1];
-    return SECSuccess;
-}
-
 /**************************************************************************
  * end of Consume Handshake functions.
  **************************************************************************/
@@ -4252,30 +3875,9 @@ ssl3_ComputeHandshakeHashes(sslSocket *     ss,
     SSL3Opaque    sha_inner[MAX_MAC_LENGTH];
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-    hashes->hashAlg = SEC_OID_UNKNOWN;
 
 #ifndef NO_PKCS11_BYPASS
-    if (ss->opt.bypassPKCS11 &&
-	ss->ssl3.hs.hashType == handshake_hash_single) {
-	/* compute them without PKCS11 */
-	PRUint64      sha_cx[MAX_MAC_CONTEXT_LLONGS];
-
-	if (!spec->msItem.data) {
-	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_HANDSHAKE);
-	    return SECFailure;
-	}
-
-	ss->ssl3.hs.sha_clone(sha_cx, ss->ssl3.hs.sha_cx);
-	ss->ssl3.hs.sha_obj->end(sha_cx, hashes->u.raw, &hashes->len,
-				 sizeof(hashes->u.raw));
-
-	PRINT_BUF(60, (NULL, "SHA-256: result", hashes->u.raw, hashes->len));
-
-	/* If we ever support ciphersuites where the PRF hash isn't SHA-256
-	 * then this will need to be updated. */
-	hashes->hashAlg = SEC_OID_SHA256;
-	rv = SECSuccess;
-    } else if (ss->opt.bypassPKCS11) {
+    if (ss->opt.bypassPKCS11) {
 	/* compute them without PKCS11 */
 	PRUint64      md5_cx[MAX_MAC_CONTEXT_LLONGS];
 	PRUint64      sha_cx[MAX_MAC_CONTEXT_LLONGS];
@@ -4336,9 +3938,9 @@ ssl3_ComputeHandshakeHashes(sslSocket *     ss,
 	    MD5_Update(md5cx, mac_pad_2, mac_defs[mac_md5].pad_size);
 	    MD5_Update(md5cx, md5_inner, MD5_LENGTH);
 	}
-	MD5_End(md5cx, hashes->u.s.md5, &outLength, MD5_LENGTH);
+	MD5_End(md5cx, hashes->md5, &outLength, MD5_LENGTH);
 
-	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->u.s.md5, MD5_LENGTH));
+	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->md5, MD5_LENGTH));
 
 	if (!isTLS) {
 	    PRINT_BUF(95, (NULL, "SHA outer: MAC Pad 2", mac_pad_2, 
@@ -4350,59 +3952,17 @@ ssl3_ComputeHandshakeHashes(sslSocket *     ss,
 	    SHA1_Update(shacx, mac_pad_2, mac_defs[mac_sha].pad_size);
 	    SHA1_Update(shacx, sha_inner, SHA1_LENGTH);
 	}
-	SHA1_End(shacx, hashes->u.s.sha, &outLength, SHA1_LENGTH);
+	SHA1_End(shacx, hashes->sha, &outLength, SHA1_LENGTH);
 
-	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->u.s.sha, SHA1_LENGTH));
+	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->sha, SHA1_LENGTH));
 
-	hashes->len = MD5_LENGTH + SHA1_LENGTH;
 	rv = SECSuccess;
 #undef md5cx
 #undef shacx
     } else 
 #endif
-    if (ss->ssl3.hs.hashType == handshake_hash_single) {
-	/* compute hashes with PKCS11 */
-	PK11Context *h;
-	unsigned int  stateLen;
-	unsigned char stackBuf[1024];
-	unsigned char *stateBuf = NULL;
-
-	if (!spec->master_secret) {
-	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_HANDSHAKE);
-	    return SECFailure;
-	}
-
-	h = ss->ssl3.hs.sha;
-	stateBuf = PK11_SaveContextAlloc(h, stackBuf,
-					 sizeof(stackBuf), &stateLen);
-	if (stateBuf == NULL) {
-	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-	    goto tls12_loser;
-	}
-	rv |= PK11_DigestFinal(h, hashes->u.raw, &hashes->len,
-			       sizeof(hashes->u.raw));
-	if (rv != SECSuccess) {
-	    ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-	    rv = SECFailure;
-	    goto tls12_loser;
-	}
-	/* If we ever support ciphersuites where the PRF hash isn't SHA-256
-	 * then this will need to be updated. */
-	hashes->hashAlg = SEC_OID_SHA256;
-	rv = SECSuccess;
-
-tls12_loser:
-	if (stateBuf) {
-	    if (PK11_RestoreContext(h, stateBuf, stateLen) != SECSuccess) {
-		ssl_MapLowLevelError(SSL_ERROR_DIGEST_FAILURE);
-		rv = SECFailure;
-	    }
-	    if (stateBuf != stackBuf) {
-		PORT_ZFree(stateBuf, stateLen);
-	    }
-	}
-    } else {
-	/* compute hashes with PKCS11 */
+    {
+	/* compute hases with PKCS11 */
 	PK11Context * md5;
 	PK11Context * sha       = NULL;
 	unsigned char *md5StateBuf = NULL;
@@ -4490,7 +4050,7 @@ tls12_loser:
 	    rv |= PK11_DigestOp(md5, mac_pad_2, mac_defs[mac_md5].pad_size);
 	    rv |= PK11_DigestOp(md5, md5_inner, MD5_LENGTH);
 	}
-	rv |= PK11_DigestFinal(md5, hashes->u.s.md5, &outLength, MD5_LENGTH);
+	rv |= PK11_DigestFinal(md5, hashes->md5, &outLength, MD5_LENGTH);
 	PORT_Assert(rv != SECSuccess || outLength == MD5_LENGTH);
 	if (rv != SECSuccess) {
 	    ssl_MapLowLevelError(SSL_ERROR_MD5_DIGEST_FAILURE);
@@ -4498,7 +4058,7 @@ tls12_loser:
 	    goto loser;
 	}
 
-	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->u.s.md5, MD5_LENGTH));
+	PRINT_BUF(60, (NULL, "MD5 outer: result", hashes->md5, MD5_LENGTH));
 
 	if (!isTLS) {
 	    PRINT_BUF(95, (NULL, "SHA outer: MAC Pad 2", mac_pad_2, 
@@ -4510,7 +4070,7 @@ tls12_loser:
 	    rv |= PK11_DigestOp(sha, mac_pad_2, mac_defs[mac_sha].pad_size);
 	    rv |= PK11_DigestOp(sha, sha_inner, SHA1_LENGTH);
 	}
-	rv |= PK11_DigestFinal(sha, hashes->u.s.sha, &outLength, SHA1_LENGTH);
+	rv |= PK11_DigestFinal(sha, hashes->sha, &outLength, SHA1_LENGTH);
 	PORT_Assert(rv != SECSuccess || outLength == SHA1_LENGTH);
 	if (rv != SECSuccess) {
 	    ssl_MapLowLevelError(SSL_ERROR_SHA_DIGEST_FAILURE);
@@ -4518,9 +4078,8 @@ tls12_loser:
 	    goto loser;
 	}
 
-	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->u.s.sha, SHA1_LENGTH));
+	PRINT_BUF(60, (NULL, "SHA outer: result", hashes->sha, SHA1_LENGTH));
 
-	hashes->len = MD5_LENGTH + SHA1_LENGTH;
 	rv = SECSuccess;
 
     loser:
@@ -4567,10 +4126,6 @@ ssl3_StartHandshakeHash(sslSocket *ss, unsigned char * buf, int length)
     if (rv != SECSuccess) {
 	goto done;		/* ssl3_InitState has set the error code. */
     }
-    rv = ssl3_RestartHandshakeHashes(ss);
-    if (rv != SECSuccess) {
-	goto done;
-    }
 
     PORT_Memset(&ss->ssl3.hs.client_random, 0, SSL3_RANDOM_LENGTH);
     PORT_Memcpy(
@@ -4629,7 +4184,13 @@ ssl3_SendClientHello(sslSocket *ss, PRBool resending)
      * clear previous state.
      */
     PORT_Memset(&ss->xtnData, 0, sizeof(TLSExtensionData));
+    ss->ssl3.hs.may_get_cert_status = PR_FALSE;
+    if (ss->ssl3.hs.cert_status.data) {
+	SECITEM_FreeItem(&ss->ssl3.hs.cert_status, PR_FALSE);
+    }
 
+    SSL_TRC(30,("%d: SSL3[%d]: reset handshake hashes",
+	    SSL_GETPID(), ss->fd ));
     rv = ssl3_RestartHandshakeHashes(ss);
     if (rv != SECSuccess) {
 	return rv;
@@ -4837,7 +4398,7 @@ ssl3_SendClientHello(sslSocket *ss, PRBool resending)
 	    total_exten_len += 2;
     }
 
-#if defined(NSS_ENABLE_ECC)
+#if defined(NSS_ENABLE_ECC) && !defined(NSS_ECC_MORE_THAN_SUITE_B)
     if (!total_exten_len || !isTLS) {
 	/* not sending the elliptic_curves and ec_point_formats extensions */
     	ssl3_DisableECCSuites(ss, NULL); /* disable all ECC suites */
@@ -5785,12 +5346,8 @@ ssl3_SendCertificateVerify(sslSocket *ss)
 {
     SECStatus     rv		= SECFailure;
     PRBool        isTLS;
-    PRBool        isTLS12;
     SECItem       buf           = {siBuffer, NULL, 0};
     SSL3Hashes    hashes;
-    KeyType       keyType;
-    unsigned int  len;
-    SSL3SignatureAndHashAlgorithm sigAndHash;
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
@@ -5806,18 +5363,15 @@ ssl3_SendCertificateVerify(sslSocket *ss)
     }
 
     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
     if (ss->ssl3.platformClientKey) {
 #ifdef NSS_PLATFORM_CLIENT_AUTH
-	keyType = CERT_GetCertKeyType(
-	    &ss->ssl3.clientCertificate->subjectPublicKeyInfo);
 	rv = ssl3_PlatformSignHashes(
-	    &hashes, ss->ssl3.platformClientKey, &buf, isTLS, keyType);
+	    &hashes, ss->ssl3.platformClientKey, &buf, isTLS, 
+	    CERT_GetCertKeyType(&ss->ssl3.clientCertificate->subjectPublicKeyInfo));
 	ssl_FreePlatformKey(ss->ssl3.platformClientKey);
 	ss->ssl3.platformClientKey = (PlatformKey)NULL;
 #endif /* NSS_PLATFORM_CLIENT_AUTH */
     } else {
-	keyType = ss->ssl3.clientPrivateKey->keyType;
 	rv = ssl3_SignHashes(&hashes, ss->ssl3.clientPrivateKey, &buf, isTLS);
 	if (rv == SECSuccess) {
 	    PK11SlotInfo * slot;
@@ -5841,30 +5395,10 @@ ssl3_SendCertificateVerify(sslSocket *ss)
 	goto done;	/* err code was set by ssl3_SignHashes */
     }
 
-    len = buf.len + 2 + (isTLS12 ? 2 : 0);
-
-    rv = ssl3_AppendHandshakeHeader(ss, certificate_verify, len);
+    rv = ssl3_AppendHandshakeHeader(ss, certificate_verify, buf.len + 2);
     if (rv != SECSuccess) {
 	goto done;	/* error code set by AppendHandshake */
     }
-    if (isTLS12) {
-	rv = ssl3_TLSSignatureAlgorithmForKeyType(keyType,
-						  &sigAndHash.sigAlg);
-	if (rv != SECSuccess) {
-	    goto done;
-	}
-	/* We always sign using the handshake hash function. It's possible that
-	 * a server could support SHA-256 as the handshake hash but not as a
-	 * signature hash. In that case we wouldn't be able to do client
-	 * certificates with it. The alternative is to buffer all handshake
-	 * messages. */
-	sigAndHash.hashAlg = hashes.hashAlg;
-
-	rv = ssl3_AppendSignatureAndHashAlgorithm(ss, &sigAndHash);
-	if (rv != SECSuccess) {
-	    goto done; 	/* err set by AppendHandshake. */
-	}
-    }
     rv = ssl3_AppendHandshakeVariable(ss, buf.data, buf.len, 2);
     if (rv != SECSuccess) {
 	goto done;	/* error code set by AppendHandshake */
@@ -5899,8 +5433,12 @@ ssl3_HandleServerHello(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     	SSL_GETPID(), ss->fd));
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-    PORT_Assert( ss->ssl3.initialized );
 
+    rv = ssl3_InitState(ss);
+    if (rv != SECSuccess) {
+	errCode = PORT_GetError(); /* ssl3_InitState has set the error code. */
+	goto alert_loser;
+    }
     if (ss->ssl3.hs.ws != wait_server_hello) {
         errCode = SSL_ERROR_RX_UNEXPECTED_SERVER_HELLO;
 	desc    = unexpected_message;
@@ -5968,13 +5506,6 @@ ssl3_HandleServerHello(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     }
     isTLS = (ss->version > SSL_LIBRARY_VERSION_3_0);
 
-    rv = ssl3_InitHandshakeHashes(ss);
-    if (rv != SECSuccess) {
-	desc = internal_error;
-	errCode = PORT_GetError();
-	goto alert_loser;
-    }
-
     rv = ssl3_ConsumeHandshake(
 	ss, &ss->ssl3.hs.server_random, SSL3_RANDOM_LENGTH, &b, &length);
     if (rv != SECSuccess) {
@@ -6210,6 +5741,7 @@ ssl3_HandleServerHello(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	    ssl3_CopyPeerCertsFromSID(ss, sid);
 	}
 
+
 	/* NULL value for PMS signifies re-use of the old MS */
 	rv = ssl3_InitPendingCipherSpec(ss,  NULL);
 	if (rv != SECSuccess) {
@@ -6305,15 +5837,12 @@ ssl3_HandleServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 {
     PRArenaPool *    arena     = NULL;
     SECKEYPublicKey *peerKey   = NULL;
-    PRBool           isTLS, isTLS12;
+    PRBool           isTLS;
     SECStatus        rv;
     int              errCode   = SSL_ERROR_RX_MALFORMED_SERVER_KEY_EXCH;
     SSL3AlertDescription desc  = illegal_parameter;
     SSL3Hashes       hashes;
     SECItem          signature = {siBuffer, NULL, 0};
-    SSL3SignatureAndHashAlgorithm sigAndHash;
-
-    sigAndHash.hashAlg = SEC_OID_UNKNOWN;
 
     SSL_TRC(3, ("%d: SSL3[%d]: handle server_key_exchange handshake",
 		SSL_GETPID(), ss->fd));
@@ -6333,7 +5862,6 @@ ssl3_HandleServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     }
 
     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
 
     switch (ss->ssl3.hs.kea_def->exchKeyType) {
 
@@ -6349,18 +5877,6 @@ ssl3_HandleServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
 	}
-	if (isTLS12) {
-	    rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-						       &sigAndHash);
-	    if (rv != SECSuccess) {
-		goto loser;	/* malformed or unsupported. */
-	    }
-	    rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-		    &sigAndHash, ss->sec.peerCert);
-	    if (rv != SECSuccess) {
-		goto loser;
-	    }
-	}
     	rv = ssl3_ConsumeHandshakeVariable(ss, &signature, 2, &b, &length);
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
@@ -6378,7 +5894,7 @@ ssl3_HandleServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     	/*
      	 *  check to make sure the hash is signed by right guy
      	 */
-	rv = ssl3_ComputeExportRSAKeyHash(sigAndHash.hashAlg, modulus, exponent,
+    	rv = ssl3_ComputeExportRSAKeyHash(modulus, exponent,
 					  &ss->ssl3.hs.client_random,
 					  &ss->ssl3.hs.server_random, 
 					  &hashes, ss->opt.bypassPKCS11);
@@ -6451,18 +5967,6 @@ ssl3_HandleServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	}
 	if (dh_Ys.len > dh_p.len || !ssl3_BigIntGreaterThanOne(&dh_Ys))
 	    goto alert_loser;
-	if (isTLS12) {
-	    rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-						       &sigAndHash);
-	    if (rv != SECSuccess) {
-		goto loser;	/* malformed or unsupported. */
-	    }
-	    rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-		    &sigAndHash, ss->sec.peerCert);
-	    if (rv != SECSuccess) {
-		goto loser;
-	    }
-	}
     	rv = ssl3_ConsumeHandshakeVariable(ss, &signature, 2, &b, &length);
     	if (rv != SECSuccess) {
 	    goto loser;		/* malformed. */
@@ -6484,7 +5988,7 @@ ssl3_HandleServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     	/*
      	 *  check to make sure the hash is signed by right guy
      	 */
-	rv = ssl3_ComputeDHKeyHash(sigAndHash.hashAlg, dh_p, dh_g, dh_Ys,
+    	rv = ssl3_ComputeDHKeyHash(dh_p, dh_g, dh_Ys,
 					  &ss->ssl3.hs.client_random,
 					  &ss->ssl3.hs.server_random, 
 					  &hashes, ss->opt.bypassPKCS11);
@@ -6573,14 +6077,12 @@ ssl3_HandleCertificateRequest(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     dnameNode *          node;
     PRInt32              remaining;
     PRBool               isTLS       = PR_FALSE;
-    PRBool               isTLS12     = PR_FALSE;
     int                  i;
     int                  errCode     = SSL_ERROR_RX_MALFORMED_CERT_REQUEST;
     int                  nnames      = 0;
     SECStatus            rv;
     SSL3AlertDescription desc        = illegal_parameter;
     SECItem              cert_types  = {siBuffer, NULL, 0};
-    SECItem              algorithms  = {siBuffer, NULL, 0};
     CERTDistNames        ca_list;
 #ifdef NSS_PLATFORM_CLIENT_AUTH
     CERTCertList *       platform_cert_list = NULL;
@@ -6605,7 +6107,6 @@ ssl3_HandleCertificateRequest(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     PORT_Assert(ss->ssl3.platformClientKey == (PlatformKey)NULL);
 
     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
     rv = ssl3_ConsumeHandshakeVariable(ss, &cert_types, 1, &b, &length);
     if (rv != SECSuccess)
     	goto loser;		/* malformed, alert has been sent */
@@ -6613,18 +6114,6 @@ ssl3_HandleCertificateRequest(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     PORT_Assert(!ss->requestedCertTypes);
     ss->requestedCertTypes = &cert_types;
 
-    if (isTLS12) {
-	rv = ssl3_ConsumeHandshakeVariable(ss, &algorithms, 2, &b, &length);
-	if (rv != SECSuccess)
-	    goto loser;		/* malformed, alert has been sent */
-	/* An empty or odd-length value is invalid.
-	 *    SignatureAndHashAlgorithm
-	 *      supported_signature_algorithms<2..2^16-2>;
-	 */
-	if (algorithms.len == 0 || (algorithms.len & 1) != 0)
-	    goto alert_loser;
-    }
-
     arena = ca_list.arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     if (arena == NULL)
     	goto no_mem;
@@ -6687,7 +6176,7 @@ ssl3_HandleCertificateRequest(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 
 #ifdef NSS_PLATFORM_CLIENT_AUTH
     if (ss->getPlatformClientAuthData != NULL) {
-	/* XXX Should pass cert_types and algorithms in this call!! */
+	/* XXX Should pass cert_types in this call!! */
         rv = (SECStatus)(*ss->getPlatformClientAuthData)(
                                         ss->getPlatformClientAuthDataArg,
                                         ss->fd, &ca_list,
@@ -6697,14 +6186,14 @@ ssl3_HandleCertificateRequest(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
                                         &ss->ssl3.clientPrivateKey);
     } else
 #endif
-    if (ss->getClientAuthData != NULL) {
-	/* XXX Should pass cert_types and algorithms in this call!! */
+    if (ss->getClientAuthData == NULL) {
+	rv = SECFailure; /* force it to send a no_certificate alert */
+    } else {
+	/* XXX Should pass cert_types in this call!! */
 	rv = (SECStatus)(*ss->getClientAuthData)(ss->getClientAuthDataArg,
 						 ss->fd, &ca_list,
 						 &ss->ssl3.clientCertificate,
 						 &ss->ssl3.clientPrivateKey);
-    } else {
-	rv = SECFailure; /* force it to send a no_certificate alert */
     }
 
     switch (rv) {
@@ -7216,10 +6705,6 @@ ssl3_SendServerHelloSequence(sslSocket *ss)
     if (rv != SECSuccess) {
 	return rv;	/* error code is set. */
     }
-    rv = ssl3_SendCertificateStatus(ss);
-    if (rv != SECSuccess) {
-	return rv;	/* error code is set. */
-    }
     /* We have to do this after the call to ssl3_SendServerHello,
      * because kea_def is set up by ssl3_SendServerHello().
      */
@@ -7306,7 +6791,6 @@ ssl3_HandleClientHello(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
-    PORT_Assert( ss->ssl3.initialized );
 
     /* Get peer name of client */
     rv = ssl_GetPeerInfo(ss);
@@ -7334,6 +6818,11 @@ ssl3_HandleClientHello(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     PORT_Memset(&ss->xtnData, 0, sizeof(TLSExtensionData));
     ss->statelessResume = PR_FALSE;
 
+    rv = ssl3_InitState(ss);
+    if (rv != SECSuccess) {
+	return rv;		/* ssl3_InitState has set the error code. */
+    }
+
     if ((ss->ssl3.hs.ws != wait_client_hello) &&
 	(ss->ssl3.hs.ws != idle_handshake)) {
 	desc    = unexpected_message;
@@ -7372,13 +6861,6 @@ ssl3_HandleClientHello(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	goto alert_loser;
     }
 
-    rv = ssl3_InitHandshakeHashes(ss);
-    if (rv != SECSuccess) {
-	desc = internal_error;
-	errCode = PORT_GetError();
-	goto alert_loser;
-    }
-
     /* grab the client random data. */
     rv = ssl3_ConsumeHandshake(
 	ss, &ss->ssl3.hs.client_random, SSL3_RANDOM_LENGTH, &b, &length);
@@ -8100,11 +7582,6 @@ ssl3_HandleV2ClientHello(sslSocket *ss, unsigned char *buffer, int length)
 	ssl_ReleaseSSL3HandshakeLock(ss);
 	return rv;		/* ssl3_InitState has set the error code. */
     }
-    rv = ssl3_RestartHandshakeHashes(ss);
-    if (rv != SECSuccess) {
-	ssl_ReleaseSSL3HandshakeLock(ss);
-	return rv;
-    }
 
     if (ss->ssl3.hs.ws != wait_client_hello) {
 	desc    = unexpected_message;
@@ -8126,13 +7603,6 @@ ssl3_HandleV2ClientHello(sslSocket *ss, unsigned char *buffer, int length)
 	goto alert_loser;
     }
 
-    rv = ssl3_InitHandshakeHashes(ss);
-    if (rv != SECSuccess) {
-	desc = internal_error;
-	errCode = PORT_GetError();
-	goto alert_loser;
-    }
-
     /* if we get a non-zero SID, just ignore it. */
     if (length !=
         SSL_HL_CLIENT_HELLO_HBYTES + suite_length + sid_length + rand_length) {
@@ -8380,85 +7850,6 @@ ssl3_SendServerHello(sslSocket *ss)
     return SECSuccess;
 }
 
-/* ssl3_PickSignatureHashAlgorithm selects a hash algorithm to use when signing
- * elements of the handshake. (The negotiated cipher suite determines the
- * signature algorithm.) Prior to TLS 1.2, the MD5/SHA1 combination is always
- * used. With TLS 1.2, a client may advertise its support for signature and
- * hash combinations. */
-static SECStatus
-ssl3_PickSignatureHashAlgorithm(sslSocket *ss,
-				SSL3SignatureAndHashAlgorithm* out)
-{
-    TLSSignatureAlgorithm sigAlg;
-    unsigned int i, j;
-    /* hashPreference expresses our preferences for hash algorithms, most
-     * preferable first. */
-    static const PRUint8 hashPreference[] = {
-	tls_hash_sha256,
-	tls_hash_sha384,
-	tls_hash_sha512,
-	tls_hash_sha1,
-    };
-
-    switch (ss->ssl3.hs.kea_def->kea) {
-    case kea_rsa:
-    case kea_rsa_export:
-    case kea_rsa_export_1024:
-    case kea_dh_rsa:
-    case kea_dh_rsa_export:
-    case kea_dhe_rsa:
-    case kea_dhe_rsa_export:
-    case kea_rsa_fips:
-    case kea_ecdh_rsa:
-    case kea_ecdhe_rsa:
-	sigAlg = tls_sig_rsa;
-	break;
-    case kea_dh_dss:
-    case kea_dh_dss_export:
-    case kea_dhe_dss:
-    case kea_dhe_dss_export:
-	sigAlg = tls_sig_dsa;
-	break;
-    case kea_ecdh_ecdsa:
-    case kea_ecdhe_ecdsa:
-	sigAlg = tls_sig_ecdsa;
-	break;
-    default:
-	PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
-	return SECFailure;
-    }
-    out->sigAlg = sigAlg;
-
-    if (ss->version <= SSL_LIBRARY_VERSION_TLS_1_1) {
-	/* SEC_OID_UNKNOWN means the MD5/SHA1 combo hash used in TLS 1.1 and
-	 * prior. */
-	out->hashAlg = SEC_OID_UNKNOWN;
-	return SECSuccess;
-    }
-
-    if (ss->ssl3.hs.numClientSigAndHash == 0) {
-	/* If the client didn't provide any signature_algorithms extension then
-	 * we can assume that they support SHA-1:
-	 * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-	out->hashAlg = SEC_OID_SHA1;
-	return SECSuccess;
-    }
-
-    for (i = 0; i < PR_ARRAY_SIZE(hashPreference); i++) {
-	for (j = 0; j < ss->ssl3.hs.numClientSigAndHash; j++) {
-	    const SSL3SignatureAndHashAlgorithm* sh =
-		&ss->ssl3.hs.clientSigAndHash[j];
-	    if (sh->sigAlg == sigAlg && sh->hashAlg == hashPreference[i]) {
-		out->hashAlg = sh->hashAlg;
-		return SECSuccess;
-	    }
-	}
-    }
-
-    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-    return SECFailure;
-}
-
 
 static SECStatus
 ssl3_SendServerKeyExchange(sslSocket *ss)
@@ -8470,7 +7861,6 @@ ssl3_SendServerKeyExchange(sslSocket *ss)
     SECItem            signed_hash = {siBuffer, NULL, 0};
     SSL3Hashes         hashes;
     SECKEYPublicKey *  sdPub;	/* public key for step-down */
-    SSL3SignatureAndHashAlgorithm sigAndHash;
 
     SSL_TRC(3, ("%d: SSL3[%d]: send server_key_exchange handshake",
 		SSL_GETPID(), ss->fd));
@@ -8478,10 +7868,6 @@ ssl3_SendServerKeyExchange(sslSocket *ss)
     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
 
-    if (ssl3_PickSignatureHashAlgorithm(ss, &sigAndHash) != SECSuccess) {
-	return SECFailure;
-    }
-
     switch (kea_def->exchKeyType) {
     case kt_rsa:
 	/* Perform SSL Step-Down here. */
@@ -8491,8 +7877,7 @@ ssl3_SendServerKeyExchange(sslSocket *ss)
 	    PORT_SetError(SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE);
 	    return SECFailure;
 	}
-	rv = ssl3_ComputeExportRSAKeyHash(sigAndHash.hashAlg,
-					  sdPub->u.rsa.modulus,
+    	rv = ssl3_ComputeExportRSAKeyHash(sdPub->u.rsa.modulus,
 					  sdPub->u.rsa.publicExponent,
 	                                  &ss->ssl3.hs.client_random,
 	                                  &ss->ssl3.hs.server_random,
@@ -8535,13 +7920,6 @@ ssl3_SendServerKeyExchange(sslSocket *ss)
 	    goto loser; 	/* err set by AppendHandshake. */
 	}
 
-	if (ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-	    rv = ssl3_AppendSignatureAndHashAlgorithm(ss, &sigAndHash);
-	    if (rv != SECSuccess) {
-		goto loser; 	/* err set by AppendHandshake. */
-	    }
-	}
-
 	rv = ssl3_AppendHandshakeVariable(ss, signed_hash.data,
 	                                  signed_hash.len, 2);
 	if (rv != SECSuccess) {
@@ -8552,7 +7930,7 @@ ssl3_SendServerKeyExchange(sslSocket *ss)
 
 #ifdef NSS_ENABLE_ECC
     case kt_ecdh: {
-	rv = ssl3_SendECDHServerKeyExchange(ss, &sigAndHash);
+	rv = ssl3_SendECDHServerKeyExchange(ss);
 	return rv;
     }
 #endif /* NSS_ENABLE_ECC */
@@ -8573,7 +7951,6 @@ loser:
 static SECStatus
 ssl3_SendCertificateRequest(sslSocket *ss)
 {
-    PRBool         isTLS12;
     SECItem *      name;
     CERTDistNames *ca_list;
     const uint8 *  certTypes;
@@ -8591,8 +7968,6 @@ ssl3_SendCertificateRequest(sslSocket *ss)
     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
 
-    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-
     /* ssl3.ca_list is initialized to NULL, and never changed. */
     ca_list = ss->ssl3.ca_list;
     if (!ca_list) {
@@ -8612,9 +7987,6 @@ ssl3_SendCertificateRequest(sslSocket *ss)
     certTypesLength = sizeof certificate_types;
 
     length = 1 + certTypesLength + 2 + calen;
-    if (isTLS12) {
-	length += 2 + ssl3_SizeOfSupportedSignatureAlgorithms();
-    }
 
     rv = ssl3_AppendHandshakeHeader(ss, certificate_request, length);
     if (rv != SECSuccess) {
@@ -8624,12 +7996,6 @@ ssl3_SendCertificateRequest(sslSocket *ss)
     if (rv != SECSuccess) {
 	return rv; 		/* err set by AppendHandshake. */
     }
-    if (isTLS12) {
-	rv = ssl3_AppendSupportedSignatureAlgorithms(ss);
-	if (rv != SECSuccess) {
-	    return rv; 		/* err set by AppendHandshake. */
-	}
-    }
     rv = ssl3_AppendHandshakeNumber(ss, calen, 2);
     if (rv != SECSuccess) {
 	return rv; 		/* err set by AppendHandshake. */
@@ -8678,51 +8044,26 @@ ssl3_HandleCertificateVerify(sslSocket *ss, SSL3Opaque *b, PRUint32 length,
     SECStatus            rv;
     int                  errCode     = SSL_ERROR_RX_MALFORMED_CERT_VERIFY;
     SSL3AlertDescription desc        = handshake_failure;
-    PRBool               isTLS, isTLS12;
-    SSL3SignatureAndHashAlgorithm sigAndHash;
+    PRBool               isTLS;
 
     SSL_TRC(3, ("%d: SSL3[%d]: handle certificate_verify handshake",
 		SSL_GETPID(), ss->fd));
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
 
-    isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
-
     if (ss->ssl3.hs.ws != wait_cert_verify || ss->sec.peerCert == NULL) {
 	desc    = unexpected_message;
 	errCode = SSL_ERROR_RX_UNEXPECTED_CERT_VERIFY;
 	goto alert_loser;
     }
 
-    if (isTLS12) {
-	rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-						   &sigAndHash);
-	if (rv != SECSuccess) {
-	    goto loser;	/* malformed or unsupported. */
-	}
-	rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-		&sigAndHash, ss->sec.peerCert);
-	if (rv != SECSuccess) {
-	    errCode = PORT_GetError();
-	    desc = decrypt_error;
-	    goto alert_loser;
-	}
-
-	/* We only support CertificateVerify messages that use the handshake
-	 * hash. */
-	if (sigAndHash.hashAlg != hashes->hashAlg) {
-	    errCode = SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM;
-	    desc = decrypt_error;
-	    goto alert_loser;
-	}
-    }
-
     rv = ssl3_ConsumeHandshakeVariable(ss, &signed_hash, 2, &b, &length);
     if (rv != SECSuccess) {
 	goto loser;		/* malformed. */
     }
 
+    isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
+
     /* XXX verify that the key & kea match */
     rv = ssl3_VerifySignedHashes(hashes, ss->sec.peerCert, &signed_hash,
 				 isTLS, ss->pkcs11PinArg);
@@ -8857,7 +8198,6 @@ ssl3_HandleRSAClientKeyExchange(sslSocket *ss,
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
-    PORT_Assert( ss->ssl3.prSpec == ss->ssl3.pwSpec );
 
     enc_pms.data = b;
     enc_pms.len  = length;
@@ -9308,49 +8648,6 @@ ssl3_SendCertificate(sslSocket *ss)
     return SECSuccess;
 }
 
-/*
- * Used by server only.
- * single-stapling, send only a single cert status
- */
-static SECStatus
-ssl3_SendCertificateStatus(sslSocket *ss)
-{
-    SECStatus            rv;
-    int                  len 		= 0;
-
-    SSL_TRC(3, ("%d: SSL3[%d]: send certificate status handshake",
-		SSL_GETPID(), ss->fd));
-
-    PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
-    PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
-
-    if (!ssl3_ExtensionNegotiated(ss, ssl_cert_status_xtn))
-	return SECSuccess;
-
-    if (!ss->certStatusArray)
-	return SECSuccess;
-
-    /* Use the array's first item only (single stapling) */
-    len = 1 + ss->certStatusArray->items[0].len + 3;
-
-    rv = ssl3_AppendHandshakeHeader(ss, certificate_status, len);
-    if (rv != SECSuccess) {
-	return rv; 		/* err set by AppendHandshake. */
-    }
-    rv = ssl3_AppendHandshakeNumber(ss, 1 /*ocsp*/, 1);
-    if (rv != SECSuccess)
-	return rv; 		/* err set by AppendHandshake. */
-
-    rv = ssl3_AppendHandshakeVariable(ss,
-				      ss->certStatusArray->items[0].data,
-				      ss->certStatusArray->items[0].len,
-				      3);
-    if (rv != SECSuccess)
-	return rv; 		/* err set by AppendHandshake. */
-
-    return SECSuccess;
-}
-
 /* This is used to delete the CA certificates in the peer certificate chain
  * from the cert database after they've been validated.
  */
@@ -9416,46 +8713,46 @@ static SECStatus
 ssl3_HandleCertificateStatus(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 {
     PRInt32 status, len;
-    PORT_Assert(ss->ssl3.hs.ws == wait_certificate_status);
+    int     errCode;
+    SSL3AlertDescription desc;
+
+    if (!ss->ssl3.hs.may_get_cert_status ||
+	ss->ssl3.hs.ws != wait_server_cert ||
+	!ss->ssl3.hs.pending_cert_msg.data ||
+	ss->ssl3.hs.cert_status.data) {
+	errCode = SSL_ERROR_RX_UNEXPECTED_CERT_STATUS;
+	desc = unexpected_message;
+	goto alert_loser;
+    }
 
     /* Consume the CertificateStatusType enum */
     status = ssl3_ConsumeHandshakeNumber(ss, 1, &b, &length);
     if (status != 1 /* ocsp */) {
-       goto format_loser;
+	goto format_loser;
     }
 
     len = ssl3_ConsumeHandshakeNumber(ss, 3, &b, &length);
     if (len != length) {
-       goto format_loser;
+	goto format_loser;
     }
 
-#define MAX_CERTSTATUS_LEN 0x1ffff   /* 128k - 1 */
-    if (length > MAX_CERTSTATUS_LEN)
-       goto format_loser;
-#undef MAX_CERTSTATUS_LEN
-
-    /* Array size 1, because we currently implement single-stapling only*/
-    SECITEM_AllocArray(NULL, &ss->sec.ci.sid->peerCertStatus, 1);
-    if (!ss->sec.ci.sid->peerCertStatus.items)
-       return SECFailure;
-
-    ss->sec.ci.sid->peerCertStatus.items[0].data = PORT_Alloc(length);
-
-    if (!ss->sec.ci.sid->peerCertStatus.items[0].data) {
-        SECITEM_FreeArray(&ss->sec.ci.sid->peerCertStatus, PR_FALSE);
+    if (SECITEM_AllocItem(NULL, &ss->ssl3.hs.cert_status, length) == NULL) {
         return SECFailure;
     }
+    ss->ssl3.hs.cert_status.type = siBuffer;
+    PORT_Memcpy(ss->ssl3.hs.cert_status.data, b, length);
 
-    PORT_Memcpy(ss->sec.ci.sid->peerCertStatus.items[0].data, b, length);
-    ss->sec.ci.sid->peerCertStatus.items[0].len = length;
-    ss->sec.ci.sid->peerCertStatus.items[0].type = siBuffer;
     return SECSuccess;
 
 format_loser:
-    return ssl3_DecodeError(ss);
-}
+    errCode = SSL_ERROR_BAD_CERT_STATUS_RESPONSE_ALERT;
+    desc = bad_certificate_status_response;
 
-static SECStatus ssl3_AuthCertificate(sslSocket *ss);
+alert_loser:
+    (void)SSL3_SendAlert(ss, alert_fatal, desc);
+    (void)ssl_MapLowLevelError(errCode);
+    return SECFailure;
+}
 
 /* Called from ssl3_HandleHandshakeMessage() when it has deciphered a complete
  * ssl3 Certificate message.
@@ -9470,6 +8767,7 @@ ssl3_HandleCertificate(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     PRInt32          size;
     SECStatus        rv;
     PRBool           isServer	= (PRBool)(!!ss->sec.isServer);
+    PRBool           trusted 	= PR_FALSE;
     PRBool           isTLS;
     SSL3AlertDescription desc;
     int              errCode    = SSL_ERROR_RX_MALFORMED_CERTIFICATE;
@@ -9512,10 +8810,8 @@ ssl3_HandleCertificate(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     }
 
     if (!remaining) {
-	if (!(isTLS && isServer)) {
-	    desc = bad_certificate;
+	if (!(isTLS && isServer))
 	    goto alert_loser;
-	}
     	/* This is TLS's version of a no_certificate alert. */
     	/* I'm a server. I've requested a client cert. He hasn't got one. */
 	rv = ssl3_HandleNoCertificate(ss);
@@ -9523,8 +8819,7 @@ ssl3_HandleCertificate(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	    errCode = PORT_GetError();
 	    goto loser;
 	}
-       ss->ssl3.hs.ws = wait_client_key;
-       return SECSuccess;
+	goto server_no_cert;
     }
 
     ss->ssl3.peerCertArena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
@@ -9589,6 +8884,9 @@ ssl3_HandleCertificate(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	    goto ambiguous_err;
 	}
 
+	if (c->cert->trust)
+	    trusted = PR_TRUE;
+
 	c->next = NULL;
 	if (lastCert) {
 	    lastCert->next = c;
@@ -9603,48 +8901,6 @@ ssl3_HandleCertificate(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 
     SECKEY_UpdateCertPQG(ss->sec.peerCert);
 
-    if (!isServer && ssl3_ExtensionNegotiated(ss, ssl_cert_status_xtn)) {
-       ss->ssl3.hs.ws = wait_certificate_status;
-       rv = SECSuccess;
-    } else {
-       rv = ssl3_AuthCertificate(ss); /* sets ss->ssl3.hs.ws */
-    }
-
-    return rv;
-
-ambiguous_err:
-    errCode = PORT_GetError();
-    switch (errCode) {
-    case PR_OUT_OF_MEMORY_ERROR:
-    case SEC_ERROR_BAD_DATABASE:
-    case SEC_ERROR_NO_MEMORY:
-       if (isTLS) {
-           desc = internal_error;
-           goto alert_loser;
-       }
-       goto loser;
-    }
-    ssl3_SendAlertForCertError(ss, errCode);
-    goto loser;
-
-decode_loser:
-    desc = isTLS ? decode_error : bad_certificate;
-
-alert_loser:
-    (void)SSL3_SendAlert(ss, alert_fatal, desc);
-
-loser:
-    (void)ssl_MapLowLevelError(errCode);
-    return SECFailure;
-}
-
-static SECStatus
-ssl3_AuthCertificate(sslSocket *ss)
-{
-    SECStatus        rv;
-    PRBool           isServer   = (PRBool)(!!ss->sec.isServer);
-    int              errCode;
-
     ss->ssl3.hs.authCertificatePending = PR_FALSE;
 
     /*
@@ -9742,6 +8998,7 @@ ssl3_AuthCertificate(sslSocket *ss)
 	    ss->ssl3.hs.ws = wait_server_key; /* allow server_key_exchange */
 	}
     } else {
+server_no_cert:
 	ss->ssl3.hs.ws = wait_client_key;
     }
 
@@ -9754,7 +9011,34 @@ ssl3_AuthCertificate(sslSocket *ss)
 
     return rv;
 
+ambiguous_err:
+    errCode = PORT_GetError();
+    switch (errCode) {
+    case PR_OUT_OF_MEMORY_ERROR:
+    case SEC_ERROR_BAD_DATABASE:
+    case SEC_ERROR_NO_MEMORY:
+	if (isTLS) {
+	    desc = internal_error;
+	    goto alert_loser;
+	}
+	goto loser;
+    }
+    ssl3_SendAlertForCertError(ss, errCode);
+    goto loser;
+
+decode_loser:
+    desc = isTLS ? decode_error : bad_certificate;
+
+alert_loser:
+    (void)SSL3_SendAlert(ss, alert_fatal, desc);
+
 loser:
+    ssl3_CleanupPeerCerts(ss);
+
+    if (ss->sec.peerCert != NULL) {
+	CERT_DestroyCertificate(ss->sec.peerCert);
+	ss->sec.peerCert = NULL;
+    }
     (void)ssl_MapLowLevelError(errCode);
     return SECFailure;
 }
@@ -9822,7 +9106,7 @@ done:
 static SECStatus
 ssl3_ComputeTLSFinished(ssl3CipherSpec *spec,
 			PRBool          isServer,
-                const   SSL3Hashes   *  hashes,
+                const   SSL3Finished *  hashes,
                         TLSFinished  *  tlsFinished)
 {
     const char * label;
@@ -9832,8 +9116,8 @@ ssl3_ComputeTLSFinished(ssl3CipherSpec *spec,
     label = isServer ? "server finished" : "client finished";
     len   = 15;
 
-    rv = ssl3_TLSPRFWithMasterSecret(spec, label, len, hashes->u.raw,
-	hashes->len, tlsFinished->verify_data,
+    rv = ssl3_TLSPRFWithMasterSecret(spec, label, len, hashes->md5,
+	sizeof *hashes, tlsFinished->verify_data,
 	sizeof tlsFinished->verify_data);
 
     return rv;
@@ -9851,16 +9135,12 @@ ssl3_TLSPRFWithMasterSecret(ssl3CipherSpec *spec, const char *label,
     SECStatus rv = SECSuccess;
 
     if (spec->master_secret && !spec->bypassCiphers) {
-	SECItem param = {siBuffer, NULL, 0};
-	CK_MECHANISM_TYPE mech = CKM_TLS_PRF_GENERAL;
-	PK11Context *prf_context;
+	SECItem      param       = {siBuffer, NULL, 0};
+	PK11Context *prf_context =
+	    PK11_CreateContextBySymKey(CKM_TLS_PRF_GENERAL, CKA_SIGN, 
+				       spec->master_secret, &param);
 	unsigned int retLen;
 
-	if (spec->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-	    mech = CKM_NSS_TLS_PRF_GENERAL_SHA256;
-	}
-	prf_context = PK11_CreateContextBySymKey(mech, CKA_SIGN,
-						 spec->master_secret, &param);
 	if (!prf_context)
 	    return SECFailure;
 
@@ -9886,12 +9166,7 @@ ssl3_TLSPRFWithMasterSecret(ssl3CipherSpec *spec, const char *label,
 	inData.len   = valLen;
 	outData.data = out;
 	outData.len  = outLen;
-	if (spec->version >= SSL_LIBRARY_VERSION_TLS_1_2) {
-	    rv = TLS_P_hash(HASH_AlgSHA256, &spec->msItem, label, &inData,
-			    &outData, isFIPS);
-	} else {
-	    rv = TLS_PRF(&spec->msItem, label, &inData, &outData, isFIPS);
-	}
+	rv = TLS_PRF(&spec->msItem, label, &inData, &outData, isFIPS);
 	PORT_Assert(rv != SECSuccess || outData.len == outLen);
 #endif
     }
@@ -10077,10 +9352,9 @@ ssl3_SendEncryptedExtensions(sslSocket *ss)
     pub_bytes = spki->data + sizeof(P256_SPKI_PREFIX);
 
     memcpy(signed_data, CHANNEL_ID_MAGIC, sizeof(CHANNEL_ID_MAGIC));
-    memcpy(signed_data + sizeof(CHANNEL_ID_MAGIC), hashes.u.raw, hashes.len);
+    memcpy(signed_data + sizeof(CHANNEL_ID_MAGIC), &hashes, sizeof(hashes));
 
-    rv = PK11_HashBuf(SEC_OID_SHA256, digest, signed_data,
-		      sizeof(CHANNEL_ID_MAGIC) + hashes.len);
+    rv = PK11_HashBuf(SEC_OID_SHA256, digest, signed_data, sizeof(signed_data));
     if (rv != SECSuccess)
 	goto loser;
 
@@ -10165,7 +9439,7 @@ ssl3_SendFinished(sslSocket *ss, PRInt32 flags)
     PRBool          isServer = ss->sec.isServer;
     SECStatus       rv;
     SSL3Sender      sender = isServer ? sender_server : sender_client;
-    SSL3Hashes      hashes;
+    SSL3Finished    hashes;
     TLSFinished     tlsFinished;
 
     SSL_TRC(3, ("%d: SSL3[%d]: send finished handshake", SSL_GETPID(), ss->fd));
@@ -10199,15 +9473,14 @@ ssl3_SendFinished(sslSocket *ss, PRInt32 flags)
 	    goto fail; 		/* err set by AppendHandshake. */
     } else {
 	if (isServer)
-	    ss->ssl3.hs.finishedMsgs.sFinished[1] = hashes.u.s;
+	    ss->ssl3.hs.finishedMsgs.sFinished[1] = hashes;
 	else
-	    ss->ssl3.hs.finishedMsgs.sFinished[0] = hashes.u.s;
-	PORT_Assert(hashes.len == sizeof hashes.u.s);
-	ss->ssl3.hs.finishedBytes = sizeof hashes.u.s;
-	rv = ssl3_AppendHandshakeHeader(ss, finished, sizeof hashes.u.s);
+	    ss->ssl3.hs.finishedMsgs.sFinished[0] = hashes;
+	ss->ssl3.hs.finishedBytes = sizeof hashes;
+	rv = ssl3_AppendHandshakeHeader(ss, finished, sizeof hashes);
 	if (rv != SECSuccess) 
 	    goto fail; 		/* err set by AppendHandshake. */
-	rv = ssl3_AppendHandshake(ss, &hashes.u.s, sizeof hashes.u.s);
+	rv = ssl3_AppendHandshake(ss, &hashes, sizeof hashes);
 	if (rv != SECSuccess) 
 	    goto fail; 		/* err set by AppendHandshake. */
     }
@@ -10356,19 +9629,18 @@ ssl3_HandleFinished(sslSocket *ss, SSL3Opaque *b, PRUint32 length,
 	    return SECFailure;
 	}
     } else {
-	if (length != sizeof(SSL3Finished)) {
+	if (length != sizeof(SSL3Hashes)) {
 	    (void)ssl3_IllegalParameter(ss);
 	    PORT_SetError(SSL_ERROR_RX_MALFORMED_FINISHED);
 	    return SECFailure;
 	}
 
 	if (!isServer)
-	    ss->ssl3.hs.finishedMsgs.sFinished[1] = hashes->u.s;
+	    ss->ssl3.hs.finishedMsgs.sFinished[1] = *hashes;
 	else
-	    ss->ssl3.hs.finishedMsgs.sFinished[0] = hashes->u.s;
-	PORT_Assert(hashes->len == sizeof hashes->u.s);
-	ss->ssl3.hs.finishedBytes = sizeof hashes->u.s;
-	if (0 != NSS_SecureMemcmp(&hashes->u.s, b, length)) {
+	    ss->ssl3.hs.finishedMsgs.sFinished[0] = *hashes;
+	ss->ssl3.hs.finishedBytes = sizeof *hashes;
+	if (0 != NSS_SecureMemcmp(hashes, b, length)) {
 	    (void)ssl3_HandshakeFailure(ss);
 	    PORT_SetError(SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE);
 	    return SECFailure;
@@ -10529,6 +9801,26 @@ ssl3_FinishHandshake(sslSocket * ss)
     return SECSuccess;
 }
 
+/* This function handles any pending Certificate messages. Certificate messages
+ * can be pending if we expect a possible CertificateStatus message to follow.
+ *
+ * This function must be called immediately after handling the
+ * CertificateStatus message, and before handling any ServerKeyExchange or
+ * CertificateRequest messages.
+ */
+static SECStatus
+ssl3_MaybeHandlePendingCertificateMessage(sslSocket *ss)
+{
+    SECStatus rv = SECSuccess;
+
+    if (ss->ssl3.hs.pending_cert_msg.data) {
+	rv = ssl3_HandleCertificate(ss, ss->ssl3.hs.pending_cert_msg.data,
+				    ss->ssl3.hs.pending_cert_msg.len);
+	SECITEM_FreeItem(&ss->ssl3.hs.pending_cert_msg, PR_FALSE);
+    }
+    return rv;
+}
+
 /* Called from ssl3_HandleHandshake() when it has gathered a complete ssl3
  * hanshake message.
  * Caller must hold Handshake and RecvBuf locks.
@@ -10565,6 +9857,10 @@ ssl3_HandleHandshakeMessage(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     }
     SSL_TRC(30,("%d: SSL3[%d]: handle handshake message: %s", SSL_GETPID(),
 		ss->fd, ssl3_DecodeHandshakeType(ss->ssl3.hs.msg_type)));
+    PRINT_BUF(60, (ss, "MD5 handshake hash:",
+    	      (unsigned char*)ss->ssl3.hs.md5_cx, MD5_LENGTH));
+    PRINT_BUF(95, (ss, "SHA handshake hash:",
+    	      (unsigned char*)ss->ssl3.hs.sha_cx, SHA1_LENGTH));
 
     hdr[0] = (PRUint8)ss->ssl3.hs.msg_type;
     hdr[1] = (PRUint8)(length >> 16);
@@ -10573,6 +9869,8 @@ ssl3_HandleHandshakeMessage(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 
     /* Start new handshake hashes when we start a new handshake */
     if (ss->ssl3.hs.msg_type == client_hello) {
+	SSL_TRC(30,("%d: SSL3[%d]: reset handshake hashes",
+		SSL_GETPID(), ss->fd ));
 	rv = ssl3_RestartHandshakeHashes(ss);
 	if (rv != SECSuccess) {
 	    return rv;
@@ -10612,35 +9910,6 @@ ssl3_HandleHandshakeMessage(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     }
 
     PORT_SetError(0);	/* each message starts with no error. */
-
-    /* The CertificateStatus message is optional. We process the message if we
-     * get one when it is allowed, but otherwise we just carry on.
-     */
-    if (ss->ssl3.hs.ws == wait_certificate_status) {
-        /* We must process any CertificateStatus message before we call
-         * ssl3_AuthCertificate, as ssl3_AuthCertificate needs any stapled
-         * OCSP response we get.
-         */
-        if (ss->ssl3.hs.msg_type == certificate_status) {
-            rv = ssl3_HandleCertificateStatus(ss, b, length);
-            if (rv != SECSuccess)
-                return rv;
-            if (IS_DTLS(ss)) {
-                /* Increment the expected sequence number */
-                ss->ssl3.hs.recvMessageSeq++;
-            }
-        }
-
-        /* Regardless of whether we got a CertificateStatus message, we must
-         * authenticate the cert before we handle any more handshake messages.
-         */
-        rv = ssl3_AuthCertificate(ss); /* sets ss->ssl3.hs.ws */
-        PORT_Assert(rv != SECWouldBlock);
-        if (rv != SECSuccess || ss->ssl3.hs.msg_type == certificate_status) {
-            return rv;
-        }
-    }
-
     switch (ss->ssl3.hs.msg_type) {
     case hello_request:
 	if (length != 0) {
@@ -10680,19 +9949,42 @@ ssl3_HandleHandshakeMessage(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	rv = dtls_HandleHelloVerifyRequest(ss, b, length);
 	break;
     case certificate:
+	if (ss->ssl3.hs.may_get_cert_status) {
+	    /* If we might get a CertificateStatus then we want to postpone the
+	     * processing of the Certificate message until after we have
+	     * processed the CertificateStatus */
+	    if (ss->ssl3.hs.pending_cert_msg.data ||
+		ss->ssl3.hs.ws != wait_server_cert) {
+		(void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
+		(void)ssl_MapLowLevelError(SSL_ERROR_RX_UNEXPECTED_CERTIFICATE);
+		return SECFailure;
+	    }
+	    if (SECITEM_AllocItem(NULL, &ss->ssl3.hs.pending_cert_msg,
+			          length) == NULL) {
+		return SECFailure;
+	    }
+	    ss->ssl3.hs.pending_cert_msg.type = siBuffer;
+	    PORT_Memcpy(ss->ssl3.hs.pending_cert_msg.data, b, length);
+	    break;
+	}
 	rv = ssl3_HandleCertificate(ss, b, length);
 	break;
     case certificate_status:
-	/* The good case is handled above */
-	(void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
-	PORT_SetError(SSL_ERROR_RX_UNEXPECTED_CERT_STATUS);
-	return SECFailure;
+	rv = ssl3_HandleCertificateStatus(ss, b, length);
+	if (rv != SECSuccess)
+	    break;
+	PORT_Assert(ss->ssl3.hs.pending_cert_msg.data);
+	rv = ssl3_MaybeHandlePendingCertificateMessage(ss);
+	break;
     case server_key_exchange:
 	if (ss->sec.isServer) {
 	    (void)SSL3_SendAlert(ss, alert_fatal, unexpected_message);
 	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_SERVER_KEY_EXCH);
 	    return SECFailure;
 	}
+	rv = ssl3_MaybeHandlePendingCertificateMessage(ss);
+	if (rv != SECSuccess)
+	    break;
 	rv = ssl3_HandleServerKeyExchange(ss, b, length);
 	break;
     case certificate_request:
@@ -10701,6 +9993,9 @@ ssl3_HandleHandshakeMessage(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_CERT_REQUEST);
 	    return SECFailure;
 	}
+	rv = ssl3_MaybeHandlePendingCertificateMessage(ss);
+	if (rv != SECSuccess)
+	    break;
 	rv = ssl3_HandleCertificateRequest(ss, b, length);
 	break;
     case server_hello_done:
@@ -10714,6 +10009,9 @@ ssl3_HandleHandshakeMessage(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	    PORT_SetError(SSL_ERROR_RX_UNEXPECTED_HELLO_DONE);
 	    return SECFailure;
 	}
+	rv = ssl3_MaybeHandlePendingCertificateMessage(ss);
+	if (rv != SECSuccess)
+	    break;
 	rv = ssl3_HandleServerHelloDone(ss);
 	break;
     case certificate_verify:
@@ -10888,41 +10186,36 @@ ssl3_HandleHandshake(sslSocket *ss, sslBuffer *origBuf)
 #define DUPLICATE_MSB_TO_ALL(x) ( (unsigned)( (int)(x) >> (sizeof(int)*8-1) ) )
 #define DUPLICATE_MSB_TO_ALL_8(x) ((unsigned char)(DUPLICATE_MSB_TO_ALL(x)))
 
-/* SECStatusToMask returns, in constant time, a mask value of all ones if
- * rv == SECSuccess.  Otherwise it returns zero. */
-static unsigned int
-SECStatusToMask(SECStatus rv)
+/* SECStatusToMask returns, in constant time, a mask value of all ones if rv ==
+ * SECSuccess.  Otherwise it returns zero. */
+static unsigned SECStatusToMask(SECStatus rv)
 {
     unsigned int good;
-    /* rv ^ SECSuccess is zero iff rv == SECSuccess. Subtracting one results
-     * in the MSB being set to one iff it was zero before. */
+    /* rv ^ SECSuccess is zero iff rv == SECSuccess. Subtracting one results in
+     * the MSB being set to one iff it was zero before. */
     good = rv ^ SECSuccess;
     good--;
     return DUPLICATE_MSB_TO_ALL(good);
 }
 
 /* ssl_ConstantTimeGE returns 0xff if a>=b and 0x00 otherwise. */
-static unsigned char
-ssl_ConstantTimeGE(unsigned int a, unsigned int b)
+static unsigned char ssl_ConstantTimeGE(unsigned a, unsigned b)
 {
     a -= b;
     return DUPLICATE_MSB_TO_ALL(~a);
 }
 
 /* ssl_ConstantTimeEQ8 returns 0xff if a==b and 0x00 otherwise. */
-static unsigned char
-ssl_ConstantTimeEQ8(unsigned char a, unsigned char b)
+static unsigned char ssl_ConstantTimeEQ8(unsigned char a, unsigned char b)
 {
-    unsigned int c = a ^ b;
+    unsigned c = a ^ b;
     c--;
     return DUPLICATE_MSB_TO_ALL_8(c);
 }
 
-static SECStatus
-ssl_RemoveSSLv3CBCPadding(sslBuffer *plaintext,
-			  unsigned int blockSize,
-			  unsigned int macSize)
-{
+static SECStatus ssl_RemoveSSLv3CBCPadding(sslBuffer *plaintext,
+					   unsigned blockSize,
+					   unsigned macSize) {
     unsigned int paddingLength, good, t;
     const unsigned int overhead = 1 /* padding length byte */ + macSize;
 
@@ -10945,9 +10238,9 @@ ssl_RemoveSSLv3CBCPadding(sslBuffer *plaintext,
     return (good & SECSuccess) | (~good & SECFailure);
 }
 
-static SECStatus
-ssl_RemoveTLSCBCPadding(sslBuffer *plaintext, unsigned int macSize)
-{
+
+static SECStatus ssl_RemoveTLSCBCPadding(sslBuffer *plaintext,
+					 unsigned macSize) {
     unsigned int paddingLength, good, t, toCheck, i;
     const unsigned int overhead = 1 /* padding length byte */ + macSize;
 
@@ -11007,15 +10300,12 @@ ssl_RemoveTLSCBCPadding(sslBuffer *plaintext, unsigned int macSize)
  *   macSize <= MAX_MAC_LENGTH
  *   plaintext->len >= macSize
  */
-static void
-ssl_CBCExtractMAC(sslBuffer *plaintext,
-		  unsigned int originalLength,
-		  SSL3Opaque* out,
-		  unsigned int macSize)
-{
+static void ssl_CBCExtractMAC(sslBuffer *plaintext,
+			      unsigned int originalLength,
+			      SSL3Opaque* out,
+			      unsigned int macSize) {
     unsigned char rotatedMac[MAX_MAC_LENGTH];
-    /* macEnd is the index of |plaintext->buf| just after the end of the
-     * MAC. */
+    /* macEnd is the index of |plaintext->buf| just after the end of the MAC. */
     unsigned macEnd = plaintext->len;
     unsigned macStart = macEnd - macSize;
     /* scanStart contains the number of bytes that we can ignore because
@@ -11049,12 +10339,11 @@ ssl_CBCExtractMAC(sslBuffer *plaintext,
 	}
     }
 
-    /* Now rotate the MAC. If we knew that the MAC fit into a CPU cache line
-     * we could line-align |rotatedMac| and rotate in place. */
+    /* Now rotate the MAC. If we knew that the MAC fit into a CPU cache line we
+     * could line-align |rotatedMac| and rotate in place. */
     memset(out, 0, macSize);
     for (i = 0; i < macSize; i++) {
-	unsigned char offset =
-	    (divSpoiler + macSize - rotateOffset + i) % macSize;
+	unsigned char offset = (divSpoiler + macSize - rotateOffset + i) % macSize;
 	for (j = 0; j < macSize; j++) {
 	    out[j] |= rotatedMac[i] & ssl_ConstantTimeEQ8(j, offset);
 	}
@@ -11525,6 +10814,8 @@ ssl3_InitCipherSpec(sslSocket *ss, ssl3CipherSpec *spec)
 /* Called from:	ssl3_SendRecord
 **		ssl3_StartHandshakeHash() <- ssl2_BeginClientHandshake()
 **		ssl3_SendClientHello()
+**		ssl3_HandleServerHello()
+**		ssl3_HandleClientHello()
 **		ssl3_HandleV2ClientHello()
 **		ssl3_HandleRecord()
 **
@@ -11535,6 +10826,7 @@ ssl3_InitCipherSpec(sslSocket *ss, ssl3CipherSpec *spec)
 static SECStatus
 ssl3_InitState(sslSocket *ss)
 {
+    SECStatus    rv;
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));
 
     if (ss->ssl3.initialized)
@@ -11551,7 +10843,7 @@ ssl3_InitState(sslSocket *ss)
 
     ss->ssl3.hs.ws = (ss->sec.isServer) ? wait_client_hello : wait_server_hello;
 #ifdef NSS_ENABLE_ECC
-    ss->ssl3.hs.negotiatedECCurves = ssl3_GetSupportedECCCurveMask(ss);
+    ss->ssl3.hs.negotiatedECCurves = SSL3_SUPPORTED_CURVES_MASK;
 #endif
     ssl_ReleaseSpecWriteLock(ss);
 
@@ -11567,12 +10859,12 @@ ssl3_InitState(sslSocket *ss)
 	dtls_SetMTU(ss, 0); /* Set the MTU to the highest plateau */
     }
 
-    PORT_Assert(!ss->ssl3.hs.messages.buf && !ss->ssl3.hs.messages.space);
-    ss->ssl3.hs.messages.buf = NULL;
-    ss->ssl3.hs.messages.space = 0;
+    rv = ssl3_NewHandshakeHashes(ss);
+    if (rv == SECSuccess) {
+	ss->ssl3.initialized = PR_TRUE;
+    }
 
-    ss->ssl3.initialized = PR_TRUE;
-    return SECSuccess;
+    return rv;
 }
 
 /* Returns a reference counted object that contains a key pair.
@@ -11938,12 +11230,8 @@ ssl3_DestroySSL3Info(sslSocket *ss)
     /* clean up handshake */
 #ifndef NO_PKCS11_BYPASS
     if (ss->opt.bypassPKCS11) {
-	if (ss->ssl3.hs.hashType == handshake_hash_combo) {
-	    SHA1_DestroyContext((SHA1Context *)ss->ssl3.hs.sha_cx, PR_FALSE);
-	    MD5_DestroyContext((MD5Context *)ss->ssl3.hs.md5_cx, PR_FALSE);
-	} else if (ss->ssl3.hs.hashType == handshake_hash_single) {
-	    ss->ssl3.hs.sha_obj->destroy(ss->ssl3.hs.sha_cx, PR_FALSE);
-	}
+	SHA1_DestroyContext((SHA1Context *)ss->ssl3.hs.sha_cx, PR_FALSE);
+	MD5_DestroyContext((MD5Context *)ss->ssl3.hs.md5_cx, PR_FALSE);
     } 
 #endif
     if (ss->ssl3.hs.md5) {
@@ -11952,15 +11240,18 @@ ssl3_DestroySSL3Info(sslSocket *ss)
     if (ss->ssl3.hs.sha) {
 	PK11_DestroyContext(ss->ssl3.hs.sha,PR_TRUE);
     }
-    if (ss->ssl3.hs.clientSigAndHash) {
-	PORT_Free(ss->ssl3.hs.clientSigAndHash);
-    }
     if (ss->ssl3.hs.messages.buf) {
     	PORT_Free(ss->ssl3.hs.messages.buf);
 	ss->ssl3.hs.messages.buf = NULL;
 	ss->ssl3.hs.messages.len = 0;
 	ss->ssl3.hs.messages.space = 0;
     }
+    if (ss->ssl3.hs.pending_cert_msg.data) {
+	SECITEM_FreeItem(&ss->ssl3.hs.pending_cert_msg, PR_FALSE);
+    }
+    if (ss->ssl3.hs.cert_status.data) {
+	SECITEM_FreeItem(&ss->ssl3.hs.cert_status, PR_FALSE);
+    }
 
     /* free the SSL3Buffer (msg_body) */
     PORT_Free(ss->ssl3.hs.msg_body.buf);
diff --git a/src/net/third_party/nss/ssl/ssl3ecc.c b/src/net/third_party/nss/ssl/ssl3ecc.c
index 277ed4f..a5619f8 100644
--- a/src/net/third_party/nss/ssl/ssl3ecc.c
+++ b/src/net/third_party/nss/ssl/ssl3ecc.c
@@ -6,7 +6,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* ECC code moved here from ssl3con.c */
-/* $Id$ */
+/* $Id: ssl3ecc.c,v 1.29 2012/06/11 02:38:30 emaldona%redhat.com Exp $ */
 
 #include "nss.h"
 #include "cert.h"
@@ -31,12 +31,6 @@
 
 #include <stdio.h>
 
-/* This is a bodge to allow this code to be compiled against older NSS headers
- * that don't contain the TLS 1.2 changes. */
-#ifndef CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256
-#define CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256 (CKM_NSS + 24)
-#endif
-
 #ifdef NSS_ENABLE_ECC
 
 /*
@@ -223,10 +217,9 @@ params2ecName(SECKEYECParams * params)
 
 /* Caller must set hiLevel error code. */
 static SECStatus
-ssl3_ComputeECDHKeyHash(SECOidTag hashAlg,
-			SECItem ec_params, SECItem server_ecpoint,
-			SSL3Random *client_rand, SSL3Random *server_rand,
-			SSL3Hashes *hashes, PRBool bypassPKCS11)
+ssl3_ComputeECDHKeyHash(SECItem ec_params, SECItem server_ecpoint,
+			     SSL3Random *client_rand, SSL3Random *server_rand,
+			     SSL3Hashes *hashes, PRBool bypassPKCS11)
 {
     PRUint8     * hashBuf;
     PRUint8     * pBuf;
@@ -262,14 +255,11 @@ ssl3_ComputeECDHKeyHash(SECOidTag hashAlg,
     	pBuf += server_ecpoint.len;
     PORT_Assert((unsigned int)(pBuf - hashBuf) == bufLen);
 
-    rv = ssl3_ComputeCommonKeyHash(hashAlg, hashBuf, bufLen, hashes,
-				   bypassPKCS11);
+    rv = ssl3_ComputeCommonKeyHash(hashBuf, bufLen, hashes, bypassPKCS11);
 
     PRINT_BUF(95, (NULL, "ECDHkey hash: ", hashBuf, bufLen));
-    PRINT_BUF(95, (NULL, "ECDHkey hash: MD5 result",
-	      hashes->u.s.md5, MD5_LENGTH));
-    PRINT_BUF(95, (NULL, "ECDHkey hash: SHA1 result",
-	      hashes->u.s.sha, SHA1_LENGTH));
+    PRINT_BUF(95, (NULL, "ECDHkey hash: MD5 result", hashes->md5, MD5_LENGTH));
+    PRINT_BUF(95, (NULL, "ECDHkey hash: SHA1 result", hashes->sha, SHA1_LENGTH));
 
     if (hashBuf != buf)
     	PORT_Free(hashBuf);
@@ -283,7 +273,7 @@ ssl3_SendECDHClientKeyExchange(sslSocket * ss, SECKEYPublicKey * svrPubKey)
 {
     PK11SymKey *	pms 		= NULL;
     SECStatus           rv    		= SECFailure;
-    PRBool              isTLS, isTLS12;
+    PRBool              isTLS;
     CK_MECHANISM_TYPE	target;
     SECKEYPublicKey	*pubKey = NULL;		/* Ephemeral ECDH key */
     SECKEYPrivateKey	*privKey = NULL;	/* Ephemeral ECDH key */
@@ -292,7 +282,6 @@ ssl3_SendECDHClientKeyExchange(sslSocket * ss, SECKEYPublicKey * svrPubKey)
     PORT_Assert( ss->opt.noLocks || ssl_HaveXmitBufLock(ss));
 
     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
 
     /* Generate ephemeral EC keypair */
     if (svrPubKey->keyType != ecKey) {
@@ -311,13 +300,8 @@ ssl3_SendECDHClientKeyExchange(sslSocket * ss, SECKEYPublicKey * svrPubKey)
 					pubKey->u.ec.publicValue.data,
 					pubKey->u.ec.publicValue.len));
 
-    if (isTLS12) {
-	target = CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256;
-    } else if (isTLS) {
-	target = CKM_TLS_MASTER_KEY_DERIVE_DH;
-    } else {
-	target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
-    }
+    if (isTLS) target = CKM_TLS_MASTER_KEY_DERIVE_DH;
+    else target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
 
     /*  Determine the PMS */
     pms = PK11_PubDeriveWithKDF(privKey, svrPubKey, PR_FALSE, NULL, NULL,
@@ -381,7 +365,7 @@ ssl3_HandleECDHClientKeyExchange(sslSocket *ss, SSL3Opaque *b,
     SECStatus         rv;
     SECKEYPublicKey   clntPubKey;
     CK_MECHANISM_TYPE	target;
-    PRBool isTLS, isTLS12;
+    PRBool isTLS;
 
     PORT_Assert( ss->opt.noLocks || ssl_HaveRecvBufLock(ss) );
     PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss) );
@@ -400,15 +384,9 @@ ssl3_HandleECDHClientKeyExchange(sslSocket *ss, SSL3Opaque *b,
     }
 
     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
 
-    if (isTLS12) {
-	target = CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256;
-    } else if (isTLS) {
-	target = CKM_TLS_MASTER_KEY_DERIVE_DH;
-    } else {
-	target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
-    }
+    if (isTLS) target = CKM_TLS_MASTER_KEY_DERIVE_DH;
+    else target = CKM_SSL3_MASTER_KEY_DERIVE_DH;
 
     /*  Determine the PMS */
     pms = PK11_PubDeriveWithKDF(srvrPrivKey, &clntPubKey, PR_FALSE, NULL, NULL,
@@ -604,7 +582,7 @@ ssl3_HandleECDHServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 {
     PRArenaPool *    arena     = NULL;
     SECKEYPublicKey *peerKey   = NULL;
-    PRBool           isTLS, isTLS12;
+    PRBool           isTLS;
     SECStatus        rv;
     int              errCode   = SSL_ERROR_RX_MALFORMED_SERVER_KEY_EXCH;
     SSL3AlertDescription desc  = illegal_parameter;
@@ -614,12 +592,8 @@ ssl3_HandleECDHServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     SECItem          ec_params = {siBuffer, NULL, 0};
     SECItem          ec_point  = {siBuffer, NULL, 0};
     unsigned char    paramBuf[3]; /* only for curve_type == named_curve */
-    SSL3SignatureAndHashAlgorithm sigAndHash;
-
-    sigAndHash.hashAlg = SEC_OID_UNKNOWN;
 
     isTLS = (PRBool)(ss->ssl3.prSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.prSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
 
     /* XXX This works only for named curves, revisit this when
      * we support generic curves.
@@ -651,19 +625,6 @@ ssl3_HandleECDHServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
 	    goto alert_loser;
     }
 
-    if (isTLS12) {
-	rv = ssl3_ConsumeSignatureAndHashAlgorithm(ss, &b, &length,
-						   &sigAndHash);
-	if (rv != SECSuccess) {
-	    goto loser;		/* malformed or unsupported. */
-	}
-	rv = ssl3_CheckSignatureAndHashAlgorithmConsistency(
-		&sigAndHash, ss->sec.peerCert);
-	if (rv != SECSuccess) {
-	    goto loser;
-	}
-    }
-
     rv = ssl3_ConsumeHandshakeVariable(ss, &signature, 2, &b, &length);
     if (rv != SECSuccess) {
 	goto loser;		/* malformed. */
@@ -686,10 +647,10 @@ ssl3_HandleECDHServerKeyExchange(sslSocket *ss, SSL3Opaque *b, PRUint32 length)
     /*
      *  check to make sure the hash is signed by right guy
      */
-    rv = ssl3_ComputeECDHKeyHash(sigAndHash.hashAlg, ec_params, ec_point,
-				 &ss->ssl3.hs.client_random,
-				 &ss->ssl3.hs.server_random, 
-				 &hashes, ss->opt.bypassPKCS11);
+    rv = ssl3_ComputeECDHKeyHash(ec_params, ec_point,
+				      &ss->ssl3.hs.client_random,
+				      &ss->ssl3.hs.server_random, 
+				      &hashes, ss->opt.bypassPKCS11);
 
     if (rv != SECSuccess) {
 	errCode =
@@ -753,14 +714,12 @@ no_memory:	/* no-memory error has already been set. */
 }
 
 SECStatus
-ssl3_SendECDHServerKeyExchange(
-    sslSocket *ss,
-    const SSL3SignatureAndHashAlgorithm *sigAndHash)
+ssl3_SendECDHServerKeyExchange(sslSocket *ss)
 {
-    const ssl3KEADef * kea_def     = ss->ssl3.hs.kea_def;
+const ssl3KEADef *     kea_def     = ss->ssl3.hs.kea_def;
     SECStatus          rv          = SECFailure;
     int                length;
-    PRBool             isTLS, isTLS12;
+    PRBool             isTLS;
     SECItem            signed_hash = {siBuffer, NULL, 0};
     SSL3Hashes         hashes;
 
@@ -770,6 +729,7 @@ ssl3_SendECDHServerKeyExchange(
     ECName             curve;
     SSL3KEAType        certIndex;
 
+
     /* Generate ephemeral ECDH key pair and send the public key */
     curve = ssl3_GetCurveNameForServerSocket(ss);
     if (curve == ec_noName) {
@@ -798,19 +758,16 @@ ssl3_SendECDHServerKeyExchange(
 	goto loser;
     }		
 
-    rv = ssl3_ComputeECDHKeyHash(sigAndHash->hashAlg,
-				 ec_params,
-				 ecdhePub->u.ec.publicValue,
-				 &ss->ssl3.hs.client_random,
-				 &ss->ssl3.hs.server_random,
-				 &hashes, ss->opt.bypassPKCS11);
+    rv = ssl3_ComputeECDHKeyHash(ec_params, ecdhePub->u.ec.publicValue,
+				      &ss->ssl3.hs.client_random,
+				      &ss->ssl3.hs.server_random,
+				      &hashes, ss->opt.bypassPKCS11);
     if (rv != SECSuccess) {
 	ssl_MapLowLevelError(SSL_ERROR_SERVER_KEY_EXCHANGE_FAILURE);
 	goto loser;
     }
 
     isTLS = (PRBool)(ss->ssl3.pwSpec->version > SSL_LIBRARY_VERSION_3_0);
-    isTLS12 = (PRBool)(ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_2);
 
     /* XXX SSLKEAType isn't really a good choice for 
      * indexing certificates but that's all we have
@@ -834,7 +791,7 @@ ssl3_SendECDHServerKeyExchange(
 
     length = ec_params.len + 
 	     1 + ecdhePub->u.ec.publicValue.len + 
-	     (isTLS12 ? 2 : 0) + 2 + signed_hash.len;
+	     2 + signed_hash.len;
 
     rv = ssl3_AppendHandshakeHeader(ss, server_key_exchange, length);
     if (rv != SECSuccess) {
@@ -852,13 +809,6 @@ ssl3_SendECDHServerKeyExchange(
 	goto loser; 	/* err set by AppendHandshake. */
     }
 
-    if (isTLS12) {
-	rv = ssl3_AppendSignatureAndHashAlgorithm(ss, sigAndHash);
-	if (rv != SECSuccess) {
-	    goto loser; 	/* err set by AppendHandshake. */
-	}
-    }
-
     rv = ssl3_AppendHandshakeVariable(ss, signed_hash.data,
 				      signed_hash.len, 2);
     if (rv != SECSuccess) {
@@ -911,7 +861,6 @@ static const ssl3CipherSuite ecdh_rsa_suites[] = {
 static const ssl3CipherSuite ecdhe_ecdsa_suites[] = {
     TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
     TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
     TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
     TLS_ECDHE_ECDSA_WITH_NULL_SHA,
     TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
@@ -921,7 +870,6 @@ static const ssl3CipherSuite ecdhe_ecdsa_suites[] = {
 static const ssl3CipherSuite ecdhe_rsa_suites[] = {
     TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
     TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
     TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
     TLS_ECDHE_RSA_WITH_NULL_SHA,
     TLS_ECDHE_RSA_WITH_RC4_128_SHA,
@@ -932,13 +880,11 @@ static const ssl3CipherSuite ecdhe_rsa_suites[] = {
 static const ssl3CipherSuite ecSuites[] = {
     TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
     TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
     TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
     TLS_ECDHE_ECDSA_WITH_NULL_SHA,
     TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
     TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
     TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
     TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
     TLS_ECDHE_RSA_WITH_NULL_SHA,
     TLS_ECDHE_RSA_WITH_RC4_128_SHA,
@@ -1023,16 +969,7 @@ PRBool
 ssl3_IsECCEnabled(sslSocket * ss)
 {
     const ssl3CipherSuite * suite;
-    PK11SlotInfo *slot;
-
-    /* make sure we can do ECC */
-    slot = PK11_GetBestSlot(CKM_ECDH1_DERIVE,  ss->pkcs11PinArg);
-    if (!slot) {
-	return PR_FALSE;
-    }
-    PK11_FreeSlot(slot);
 
-    /* make sure an ECC cipher is enabled */
     for (suite = ecSuites; *suite; ++suite) {
 	PRBool    enabled = PR_FALSE;
 	SECStatus rv      = ssl3_CipherPrefGet(ss, *suite, &enabled);
@@ -1046,20 +983,21 @@ ssl3_IsECCEnabled(sslSocket * ss)
 
 #define BE(n) 0, n
 
+#ifndef NSS_ECC_MORE_THAN_SUITE_B
 /* Prefabricated TLS client hello extension, Elliptic Curves List,
  * offers only 3 curves, the Suite B curves, 23-25 
  */
-static const PRUint8 suiteBECList[12] = {
+static const PRUint8 EClist[12] = {
     BE(10),         /* Extension type */
     BE( 8),         /* octets that follow ( 3 pairs + 1 length pair) */
     BE( 6),         /* octets that follow ( 3 pairs) */
     BE(23), BE(24), BE(25)
 };
-
+#else
 /* Prefabricated TLS client hello extension, Elliptic Curves List,
  * offers curves 1-25.
  */
-static const PRUint8 tlsECList[56] = {
+static const PRUint8 EClist[56] = {
     BE(10),         /* Extension type */
     BE(52),         /* octets that follow (25 pairs + 1 length pair) */
     BE(50),         /* octets that follow (25 pairs) */
@@ -1068,6 +1006,7 @@ static const PRUint8 tlsECList[56] = {
     BE(16), BE(17), BE(18), BE(19), BE(20), BE(21), BE(22), BE(23), 
     BE(24), BE(25)
 };
+#endif
 
 static const PRUint8 ECPtFmt[6] = {
     BE(11),         /* Extension type */
@@ -1076,33 +1015,6 @@ static const PRUint8 ECPtFmt[6] = {
                  0  /* uncompressed type only */
 };
 
-/* This function already presumes we can do ECC, ssl_IsECCEnabled must be
- * called before this function. It looks to see if we have a token which
- * is capable of doing smaller than SuiteB curves. If the token can, we
- * presume the token can do the whole SSL suite of curves. If it can't we
- * presume the token that allowed ECC to be enabled can only do suite B
- * curves. */
-static PRBool
-ssl3_SuiteBOnly(sslSocket *ss)
-{
-#if 0
-    /* look to see if we can handle certs less than 163 bits */
-    PK11SlotInfo *slot =
-	PK11_GetBestSlotWithAttributes(CKM_ECDH1_DERIVE, 0, 163,
-					ss ? ss->pkcs11PinArg : NULL);
-
-    if (!slot) {
-	/* nope, presume we can only do suite B */
-	return PR_TRUE;
-    }
-    /* we can, presume we can do all curves */
-    PK11_FreeSlot(slot);
-    return PR_FALSE;
-#else
-    return PR_TRUE;
-#endif
-}
-
 /* Send our "canned" (precompiled) Supported Elliptic Curves extension,
  * which says that we support all TLS-defined named curves.
  */
@@ -1112,22 +1024,10 @@ ssl3_SendSupportedCurvesXtn(
 			PRBool      append,
 			PRUint32    maxBytes)
 {
-    int ECListSize = 0;
-    const PRUint8 *ECList = NULL;
-
     if (!ss || !ssl3_IsECCEnabled(ss))
     	return 0;
-
-    if (ssl3_SuiteBOnly(ss)) {
-	ECListSize = sizeof (suiteBECList);
-	ECList = suiteBECList;
-    } else {
-	ECListSize = sizeof (tlsECList);
-	ECList = tlsECList;
-    }
- 
-    if (append && maxBytes >= ECListSize) {
-	SECStatus rv = ssl3_AppendHandshake(ss, ECList, ECListSize);
+    if (append && maxBytes >= (sizeof EClist)) {
+	SECStatus rv = ssl3_AppendHandshake(ss, EClist, (sizeof EClist));
 	if (rv != SECSuccess)
 	    return -1;
 	if (!ss->sec.isServer) {
@@ -1136,16 +1036,7 @@ ssl3_SendSupportedCurvesXtn(
 		ssl_elliptic_curves_xtn;
 	}
     }
-    return ECListSize;
-}
-
-PRInt32
-ssl3_GetSupportedECCCurveMask(sslSocket *ss)
-{
-    if (ssl3_SuiteBOnly(ss)) {
-	return SSL3_SUITE_B_SUPPORTED_CURVES_MASK;
-    }
-    return SSL3_ALL_SUPPORTED_CURVES_MASK;
+    return (sizeof EClist);
 }
 
 /* Send our "canned" (precompiled) Supported Point Formats extension,
diff --git a/src/net/third_party/nss/ssl/ssl3ext.c b/src/net/third_party/nss/ssl/ssl3ext.c
index c0ce548..23bb44b 100644
--- a/src/net/third_party/nss/ssl/ssl3ext.c
+++ b/src/net/third_party/nss/ssl/ssl3ext.c
@@ -6,7 +6,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* TLS extension code moved here from ssl3ecc.c */
-/* $Id$ */
+/* $Id: ssl3ext.c,v 1.28 2012/09/21 00:28:05 wtc%google.com Exp $ */
 
 #include "nssrenam.h"
 #include "nss.h"
@@ -65,19 +65,6 @@ static SECStatus ssl3_ClientHandleChannelIDXtn(sslSocket *ss,
     PRUint16 ex_type, SECItem *data);
 static PRInt32 ssl3_ClientSendChannelIDXtn(sslSocket *ss, PRBool append,
     PRUint32 maxBytes);
-static SECStatus ssl3_ServerSendStatusRequestXtn(sslSocket * ss,
-    PRBool      append, PRUint32    maxBytes);
-static SECStatus ssl3_ServerHandleStatusRequestXtn(sslSocket *ss,
-    PRUint16 ex_type, SECItem *data);
-static SECStatus ssl3_ClientHandleStatusRequestXtn(sslSocket *ss,
-                                                  PRUint16 ex_type,
-                                                  SECItem *data);
-static PRInt32 ssl3_ClientSendStatusRequestXtn(sslSocket * ss, PRBool append,
-                                              PRUint32 maxBytes);
-static PRInt32 ssl3_ClientSendSigAlgsXtn(sslSocket *ss, PRBool append,
-                                         PRUint32 maxBytes);
-static SECStatus ssl3_ServerHandleSigAlgsXtn(sslSocket *ss, PRUint16 ex_type,
-                                             SECItem *data);
 
 /*
  * Write bytes.  Using this function means the SECItem structure
@@ -239,8 +226,6 @@ static const ssl3HelloExtensionHandler clientHelloHandlers[] = {
     { ssl_renegotiation_info_xtn, &ssl3_HandleRenegotiationInfoXtn },
     { ssl_next_proto_nego_xtn,    &ssl3_ServerHandleNextProtoNegoXtn },
     { ssl_use_srtp_xtn,           &ssl3_HandleUseSRTPXtn },
-    { ssl_cert_status_xtn,        &ssl3_ServerHandleStatusRequestXtn },
-    { ssl_signature_algorithms_xtn, &ssl3_ServerHandleSigAlgsXtn },
     { -1, NULL }
 };
 
@@ -281,8 +266,7 @@ ssl3HelloExtensionSender clientHelloSendersTLS[SSL_MAX_EXTENSIONS] = {
     { ssl_next_proto_nego_xtn,    &ssl3_ClientSendNextProtoNegoXtn },
     { ssl_use_srtp_xtn,           &ssl3_SendUseSRTPXtn },
     { ssl_channel_id_xtn,         &ssl3_ClientSendChannelIDXtn },
-    { ssl_cert_status_xtn,        &ssl3_ClientSendStatusRequestXtn },
-    { ssl_signature_algorithms_xtn, &ssl3_ClientSendSigAlgsXtn }
+    { ssl_cert_status_xtn,        &ssl3_ClientSendStatusRequestXtn }
     /* any extra entries will appear as { 0, NULL }    */
 };
 
@@ -718,13 +702,19 @@ loser:
     return -1;
 }
 
-static SECStatus
+SECStatus
 ssl3_ClientHandleStatusRequestXtn(sslSocket *ss, PRUint16 ex_type,
-                                 SECItem *data)
+				  SECItem *data)
 {
+    /* If we didn't request this extension, then the server may not echo it. */
+    if (!ss->opt.enableOCSPStapling)
+	return SECFailure;
+
     /* The echoed extension must be empty. */
     if (data->len != 0)
-       return SECFailure;
+	return SECFailure;
+
+    ss->ssl3.hs.may_get_cert_status = PR_TRUE;
 
     /* Keep track of negotiated extensions. */
     ss->xtnData.negotiated[ss->xtnData.numNegotiated++] = ex_type;
@@ -732,43 +722,16 @@ ssl3_ClientHandleStatusRequestXtn(sslSocket *ss, PRUint16 ex_type,
     return SECSuccess;
 }
 
-static PRInt32
-ssl3_ServerSendStatusRequestXtn(
-			sslSocket * ss,
-			PRBool      append,
-			PRUint32    maxBytes)
-{
-    PRInt32 extension_length;
-    SECStatus rv;
-
-    if (!ss->certStatusArray)
-	return 0;
-
-    extension_length = 2 + 2;
-    if (append && maxBytes >= extension_length) {
-	/* extension_type */
-	rv = ssl3_AppendHandshakeNumber(ss, ssl_cert_status_xtn, 2);
-	if (rv != SECSuccess)
-	    return -1;
-	/* length of extension_data */
-	rv = ssl3_AppendHandshakeNumber(ss, 0, 2);
-	if (rv != SECSuccess)
-	    return -1;
-    }
-
-    return extension_length;
-}
-
 /* ssl3_ClientSendStatusRequestXtn builds the status_request extension on the
  * client side. See RFC 4366 section 3.6. */
-static PRInt32
+PRInt32
 ssl3_ClientSendStatusRequestXtn(sslSocket * ss, PRBool append,
-                               PRUint32 maxBytes)
+				PRUint32 maxBytes)
 {
     PRInt32 extension_length;
 
     if (!ss->opt.enableOCSPStapling)
-       return 0;
+	return 0;
 
     /* extension_type (2-bytes) +
      * length(extension_data) (2-bytes) +
@@ -779,36 +742,36 @@ ssl3_ClientSendStatusRequestXtn(sslSocket * ss, PRBool append,
     extension_length = 9;
 
     if (append && maxBytes >= extension_length) {
-       SECStatus rv;
-       TLSExtensionData *xtnData;
-
-       /* extension_type */
-       rv = ssl3_AppendHandshakeNumber(ss, ssl_cert_status_xtn, 2);
-       if (rv != SECSuccess)
-           return -1;
-       rv = ssl3_AppendHandshakeNumber(ss, extension_length - 4, 2);
-       if (rv != SECSuccess)
-           return -1;
-       rv = ssl3_AppendHandshakeNumber(ss, 1 /* status_type ocsp */, 1);
-       if (rv != SECSuccess)
-           return -1;
-       /* A zero length responder_id_list means that the responders are
-        * implicitly known to the server. */
-       rv = ssl3_AppendHandshakeNumber(ss, 0, 2);
-       if (rv != SECSuccess)
-           return -1;
-       /* A zero length request_extensions means that there are no extensions.
-        * Specifically, we don't set the id-pkix-ocsp-nonce extension. This
-        * means that the server can replay a cached OCSP response to us. */
-       rv = ssl3_AppendHandshakeNumber(ss, 0, 2);
-       if (rv != SECSuccess)
-           return -1;
-
-       xtnData = &ss->xtnData;
-       xtnData->advertised[xtnData->numAdvertised++] = ssl_cert_status_xtn;
+	SECStatus rv;
+	TLSExtensionData *xtnData;
+
+	/* extension_type */
+	rv = ssl3_AppendHandshakeNumber(ss, ssl_cert_status_xtn, 2);
+	if (rv != SECSuccess)
+	    return -1;
+	rv = ssl3_AppendHandshakeNumber(ss, extension_length - 4, 2);
+	if (rv != SECSuccess)
+	    return -1;
+	rv = ssl3_AppendHandshakeNumber(ss, 1 /* status_type ocsp */, 1);
+	if (rv != SECSuccess)
+	    return -1;
+	/* A zero length responder_id_list means that the responders are
+	 * implicitly known to the server. */
+	rv = ssl3_AppendHandshakeNumber(ss, 0, 2);
+	if (rv != SECSuccess)
+	    return -1;
+	/* A zero length request_extensions means that there are no extensions.
+	 * Specifically, we don't set the id-pkix-ocsp-nonce extension. This
+	 * means that the server can replay a cached OCSP response to us. */
+	rv = ssl3_AppendHandshakeNumber(ss, 0, 2);
+	if (rv != SECSuccess)
+	    return -1;
+
+	xtnData = &ss->xtnData;
+	xtnData->advertised[xtnData->numAdvertised++] = ssl_cert_status_xtn;
     } else if (maxBytes < extension_length) {
-       PORT_Assert(0);
-       return 0;
+	PORT_Assert(0);
+	return 0;
     }
     return extension_length;
 }
@@ -1249,7 +1212,7 @@ ssl3_ServerHandleSessionTicketXtn(sslSocket *ss, PRUint16 ex_type,
 		&mac_key, &mac_key_length);
 	} else 
 #endif
-	{
+    {
 	    rv = ssl3_GetSessionTicketKeysPKCS11(ss, &aes_key_pkcs11,
 		&mac_key_pkcs11);
 	}
@@ -1287,7 +1250,7 @@ ssl3_ServerHandleSessionTicketXtn(sslSocket *ss, PRUint16 ex_type,
 		goto no_ticket;
 	} else 
 #endif
-	{
+    {
 	    SECItem macParam;
 	    macParam.data = NULL;
 	    macParam.len = 0;
@@ -1351,7 +1314,7 @@ ssl3_ServerHandleSessionTicketXtn(sslSocket *ss, PRUint16 ex_type,
 		goto no_ticket;
 	} else 
 #endif
-	{
+    {
 	    SECItem ivItem;
 	    ivItem.data = enc_session_ticket.iv;
 	    ivItem.len = AES_BLOCK_SIZE;
@@ -1795,22 +1758,6 @@ ssl3_SendRenegotiationInfoXtn(
     return needed;
 }
 
-static SECStatus
-ssl3_ServerHandleStatusRequestXtn(sslSocket *ss, PRUint16 ex_type,
-				  SECItem *data)
-{
-    SECStatus rv = SECSuccess;
-    PRUint32 len = 0;
-
-    /* remember that we got this extension. */
-    ss->xtnData.negotiated[ss->xtnData.numNegotiated++] = ex_type;
-    PORT_Assert(ss->sec.isServer);
-    /* prepare to send back the appropriate response */
-    rv = ssl3_RegisterServerHelloExtensionSender(ss, ex_type,
-					    ssl3_ServerSendStatusRequestXtn);
-    return rv;
-}
-
 /* This function runs in both the client and server.  */
 static SECStatus
 ssl3_HandleRenegotiationInfoXtn(sslSocket *ss, PRUint16 ex_type, SECItem *data)
@@ -2045,115 +1992,3 @@ ssl3_HandleUseSRTPXtn(sslSocket * ss, PRUint16 ex_type, SECItem *data)
     return ssl3_RegisterServerHelloExtensionSender(ss, ssl_use_srtp_xtn,
 						   ssl3_SendUseSRTPXtn);
 }
-
-/* ssl3_ServerHandleSigAlgsXtn handles the signature_algorithms extension
- * from a client.
- * See https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-static SECStatus
-ssl3_ServerHandleSigAlgsXtn(sslSocket * ss, PRUint16 ex_type, SECItem *data)
-{
-    SECStatus rv;
-    SECItem algorithms;
-    const unsigned char *b;
-    unsigned int numAlgorithms, i;
-
-    /* Ignore this extension if we aren't doing TLS 1.2 or greater. */
-    if (ss->version < SSL_LIBRARY_VERSION_TLS_1_2) {
-	return SECSuccess;
-    }
-
-    /* Keep track of negotiated extensions. */
-    ss->xtnData.negotiated[ss->xtnData.numNegotiated++] = ex_type;
-
-    rv = ssl3_ConsumeHandshakeVariable(ss, &algorithms, 2, &data->data,
-				       &data->len);
-    if (rv != SECSuccess) {
-	return SECFailure;
-    }
-    /* Trailing data, empty value, or odd-length value is invalid. */
-    if (data->len != 0 || algorithms.len == 0 || (algorithms.len & 1) != 0) {
-	PORT_SetError(SSL_ERROR_RX_MALFORMED_CLIENT_HELLO);
-	return SECFailure;
-    }
-
-    numAlgorithms = algorithms.len/2;
-
-    /* We don't care to process excessive numbers of algorithms. */
-    if (numAlgorithms > 512) {
-	numAlgorithms = 512;
-    }
-
-    ss->ssl3.hs.clientSigAndHash =
-	    PORT_NewArray(SSL3SignatureAndHashAlgorithm, numAlgorithms);
-    if (!ss->ssl3.hs.clientSigAndHash) {
-	return SECFailure;
-    }
-    ss->ssl3.hs.numClientSigAndHash = 0;
-
-    b = algorithms.data;
-    for (i = 0; i < numAlgorithms; i++) {
-	unsigned char tls_hash = *(b++);
-	unsigned char tls_sig = *(b++);
-	SECOidTag hash = ssl3_TLSHashAlgorithmToOID(tls_hash);
-
-	if (hash == SEC_OID_UNKNOWN) {
-	    /* We ignore formats that we don't understand. */
-	    continue;
-	}
-	/* tls_sig support will be checked later in
-	 * ssl3_PickSignatureHashAlgorithm. */
-	ss->ssl3.hs.clientSigAndHash[i].hashAlg = hash;
-	ss->ssl3.hs.clientSigAndHash[i].sigAlg = tls_sig;
-	ss->ssl3.hs.numClientSigAndHash++;
-    }
-
-    if (!ss->ssl3.hs.numClientSigAndHash) {
-	/* We didn't understand any of the client's requested signature
-	 * formats. We'll use the defaults. */
-	PORT_Free(ss->ssl3.hs.clientSigAndHash);
-	ss->ssl3.hs.clientSigAndHash = NULL;
-    }
-
-    return SECSuccess;
-}
-
-/* ssl3_ClientSendSigAlgsXtn sends the signature_algorithm extension for TLS
- * 1.2 ClientHellos. */
-static PRInt32
-ssl3_ClientSendSigAlgsXtn(sslSocket * ss, PRBool append, PRUint32 maxBytes)
-{
-    PRInt32 extension_length;
-
-    if (ss->version < SSL_LIBRARY_VERSION_TLS_1_2) {
-	return 0;
-    }
-
-    extension_length =
-	2 /* extension type */ +
-	2 /* extension length */ +
-	2 /* supported_signature_algorithms length */ +
-	ssl3_SizeOfSupportedSignatureAlgorithms();
-
-    if (append && maxBytes >= extension_length) {
-	SECStatus rv;
-	rv = ssl3_AppendHandshakeNumber(ss, ssl_signature_algorithms_xtn, 2);
-	if (rv != SECSuccess)
-	    goto loser;
-	rv = ssl3_AppendHandshakeNumber(ss, extension_length - 4, 2);
-	if (rv != SECSuccess)
-	    goto loser;
-	rv = ssl3_AppendSupportedSignatureAlgorithms(ss);
-	if (rv != SECSuccess)
-	    goto loser;
-	ss->xtnData.advertised[ss->xtnData.numAdvertised++] =
-		ssl_signature_algorithms_xtn;
-    } else if (maxBytes < extension_length) {
-	PORT_Assert(0);
-	return 0;
-    }
-
-    return extension_length;
-
-loser:
-    return -1;
-}
diff --git a/src/net/third_party/nss/ssl/ssl3gthr.c b/src/net/third_party/nss/ssl/ssl3gthr.c
index 48886e1..09120ee 100644
--- a/src/net/third_party/nss/ssl/ssl3gthr.c
+++ b/src/net/third_party/nss/ssl/ssl3gthr.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: ssl3gthr.c,v 1.14 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "cert.h"
 #include "ssl.h"
diff --git a/src/net/third_party/nss/ssl/ssl3prot.h b/src/net/third_party/nss/ssl/ssl3prot.h
index 835a675..f6e733a 100644
--- a/src/net/third_party/nss/ssl/ssl3prot.h
+++ b/src/net/third_party/nss/ssl/ssl3prot.h
@@ -5,7 +5,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: ssl3prot.h,v 1.22 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #ifndef __ssl3proto_h_
 #define __ssl3proto_h_
@@ -129,7 +129,7 @@ typedef enum {
     certificate_verify	= 15, 
     client_key_exchange	= 16, 
     finished		= 20,
-    certificate_status  = 22,
+    certificate_status	= 22,
     next_proto		= 67,
     encrypted_extensions= 203
 } SSL3HandshakeType;
@@ -212,51 +212,11 @@ typedef struct {
     } u;
 } SSL3ServerParams;
 
-/* This enum reflects HashAlgorithm enum from
- * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
- *
- * When updating, be sure to also update ssl3_TLSHashAlgorithmToOID. */
-enum {
-    tls_hash_md5 = 1,
-    tls_hash_sha1 = 2,
-    tls_hash_sha224 = 3,
-    tls_hash_sha256 = 4,
-    tls_hash_sha384 = 5,
-    tls_hash_sha512 = 6
-};
-
-/* This enum reflects SignatureAlgorithm enum from
- * https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1 */
-typedef enum {
-    tls_sig_rsa = 1,
-    tls_sig_dsa = 2,
-    tls_sig_ecdsa = 3
-} TLSSignatureAlgorithm;
-
-typedef struct {
-    SECOidTag hashAlg;
-    TLSSignatureAlgorithm sigAlg;
-} SSL3SignatureAndHashAlgorithm;
-
-/* SSL3HashesIndividually contains a combination MD5/SHA1 hash, as used in TLS
- * prior to 1.2. */
 typedef struct {
     uint8 md5[16];
     uint8 sha[20];
-} SSL3HashesIndividually;
-
-/* SSL3Hashes contains an SSL hash value. The digest is contained in |u.raw|
- * which, if |hashAlg==SEC_OID_UNKNOWN| is also a SSL3HashesIndividually
- * struct. */
-typedef struct {
-    unsigned int len;
-    SECOidTag hashAlg;
-    union {
-	PRUint8 raw[64];
-	SSL3HashesIndividually s;
-    } u;
 } SSL3Hashes;
-
+     
 typedef struct {
     union {
 	SSL3Opaque anonymous;
@@ -314,7 +274,7 @@ typedef enum {
     sender_server = 0x53525652
 } SSL3Sender;
 
-typedef SSL3HashesIndividually SSL3Finished;   
+typedef SSL3Hashes SSL3Finished;   
 
 typedef struct {
     SSL3Opaque verify_data[12];
diff --git a/src/net/third_party/nss/ssl/sslauth.c b/src/net/third_party/nss/ssl/sslauth.c
index cb07d5c..229d890 100644
--- a/src/net/third_party/nss/ssl/sslauth.c
+++ b/src/net/third_party/nss/ssl/sslauth.c
@@ -1,14 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslauth.c,v 1.18 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 #include "cert.h"
 #include "secitem.h"
 #include "ssl.h"
 #include "sslimpl.h"
 #include "sslproto.h"
 #include "pk11func.h"
-#include "ocsp.h"
 
 /* NEED LOCKS IN HERE.  */
 CERTCertificate *
@@ -290,9 +289,6 @@ SSL_AuthCertificate(void *arg, PRFileDesc *fd, PRBool checkSig, PRBool isServer)
     sslSocket *        ss;
     SECCertUsage       certUsage;
     const char *             hostname    = NULL;
-    PRTime             now = PR_Now();
-    SECItemArray *certStatusArray;
-    unsigned int i;
     
     ss = ssl_FindSocket(fd);
     PORT_Assert(ss != NULL);
@@ -301,18 +297,12 @@ SSL_AuthCertificate(void *arg, PRFileDesc *fd, PRBool checkSig, PRBool isServer)
     }
 
     handle = (CERTCertDBHandle *)arg;
-    certStatusArray = &ss->sec.ci.sid->peerCertStatus;
-
-    for (i = 0; i < certStatusArray->len; ++i) {
-        CERT_CacheOCSPResponseFromSideChannel(handle, ss->sec.peerCert,
-					now, &certStatusArray->items[i], arg);
-    }
 
     /* this may seem backwards, but isn't. */
     certUsage = isServer ? certUsageSSLClient : certUsageSSLServer;
 
-    rv = CERT_VerifyCert(handle, ss->sec.peerCert, checkSig, certUsage,
-			 now, ss->pkcs11PinArg, NULL);
+    rv = CERT_VerifyCertNow(handle, ss->sec.peerCert, checkSig, certUsage,
+			    ss->pkcs11PinArg);
 
     if ( rv != SECSuccess || isServer )
 	return rv;
diff --git a/src/net/third_party/nss/ssl/sslcon.c b/src/net/third_party/nss/ssl/sslcon.c
index 419366e..3a0d959 100644
--- a/src/net/third_party/nss/ssl/sslcon.c
+++ b/src/net/third_party/nss/ssl/sslcon.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslcon.c,v 1.52 2012/07/17 14:43:11 kaie%kuix.de Exp $ */
 
 #include "nssrenam.h"
 #include "cert.h"
@@ -3102,7 +3102,7 @@ ssl2_BeginClientHandshake(sslSocket *ss)
 
 	return rv;
     }
-#if defined(NSS_ENABLE_ECC)
+#if defined(NSS_ENABLE_ECC) && !defined(NSS_ECC_MORE_THAN_SUITE_B)
     /* ensure we don't neogtiate ECC cipher suites with SSL2 hello */
     ssl3_DisableECCSuites(ss, NULL); /* disable all ECC suites */
     if (ss->cipherSpecs != NULL) {
diff --git a/src/net/third_party/nss/ssl/ssldef.c b/src/net/third_party/nss/ssl/ssldef.c
index e4aafe3..a6613d9 100644
--- a/src/net/third_party/nss/ssl/ssldef.c
+++ b/src/net/third_party/nss/ssl/ssldef.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: ssldef.c,v 1.13 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "cert.h"
 #include "ssl.h"
diff --git a/src/net/third_party/nss/ssl/sslenum.c b/src/net/third_party/nss/ssl/sslenum.c
index 1e0f654..3fc99a7 100644
--- a/src/net/third_party/nss/ssl/sslenum.c
+++ b/src/net/third_party/nss/ssl/sslenum.c
@@ -5,7 +5,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslenum.c,v 1.19 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "ssl.h"
 #include "sslproto.h"
@@ -26,8 +26,6 @@
  *
  * If new ECC cipher suites are added, also update the ssl3CipherSuite arrays
  * in ssl3ecc.c.
- *
- * Finally, update the ssl_V3_SUITES_IMPLEMENTED macro in sslimpl.h.
  */
 const PRUint16 SSL_ImplementedCiphers[] = {
     /* 256-bit */
@@ -38,7 +36,6 @@ const PRUint16 SSL_ImplementedCiphers[] = {
     TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,
     TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,
     TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
-    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
     TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
 #ifdef NSS_ENABLE_ECC
     TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,
@@ -46,22 +43,18 @@ const PRUint16 SSL_ImplementedCiphers[] = {
 #endif /* NSS_ENABLE_ECC */
     TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,
     TLS_RSA_WITH_AES_256_CBC_SHA,
-    TLS_RSA_WITH_AES_256_CBC_SHA256,
 
     /* 128-bit */
 #ifdef NSS_ENABLE_ECC
     TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
     TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
-    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
     TLS_ECDHE_RSA_WITH_RC4_128_SHA,
     TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
 #endif /* NSS_ENABLE_ECC */
     TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,
     TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,
     TLS_DHE_DSS_WITH_RC4_128_SHA,
     TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
     TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
 #ifdef NSS_ENABLE_ECC
     TLS_ECDH_RSA_WITH_RC4_128_SHA,
@@ -74,7 +67,6 @@ const PRUint16 SSL_ImplementedCiphers[] = {
     SSL_RSA_WITH_RC4_128_SHA,
     SSL_RSA_WITH_RC4_128_MD5,
     TLS_RSA_WITH_AES_128_CBC_SHA,
-    TLS_RSA_WITH_AES_128_CBC_SHA256,
 
     /* 112-bit 3DES */
 #ifdef NSS_ENABLE_ECC
@@ -112,7 +104,6 @@ const PRUint16 SSL_ImplementedCiphers[] = {
     TLS_ECDH_ECDSA_WITH_NULL_SHA,
 #endif /* NSS_ENABLE_ECC */
     SSL_RSA_WITH_NULL_SHA,
-    TLS_RSA_WITH_NULL_SHA256,
     SSL_RSA_WITH_NULL_MD5,
 
     /* SSL2 cipher suites. */
diff --git a/src/net/third_party/nss/ssl/sslerr.c b/src/net/third_party/nss/ssl/sslerr.c
index 0afdb18..89f3c3b 100644
--- a/src/net/third_party/nss/ssl/sslerr.c
+++ b/src/net/third_party/nss/ssl/sslerr.c
@@ -5,7 +5,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslerr.c,v 1.5 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "prerror.h"
 #include "secerr.h"
diff --git a/src/net/third_party/nss/ssl/sslerr.h b/src/net/third_party/nss/ssl/sslerr.h
index 4f8627c..7b93568 100644
--- a/src/net/third_party/nss/ssl/sslerr.h
+++ b/src/net/third_party/nss/ssl/sslerr.h
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslerr.h,v 1.25 2012/07/13 00:51:57 wtc%google.com Exp $ */
 #ifndef __SSL_ERR_H_
 #define __SSL_ERR_H_
 
@@ -194,10 +194,6 @@ SSL_ERROR_BAD_CHANNEL_ID_DATA = (SSL_ERROR_BASE + 126),
 SSL_ERROR_INVALID_CHANNEL_ID_KEY = (SSL_ERROR_BASE + 127),
 SSL_ERROR_GET_CHANNEL_ID_FAILED = (SSL_ERROR_BASE + 128),
 
-SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM = (SSL_ERROR_BASE + 129),
-SSL_ERROR_DIGEST_FAILURE = (SSL_ERROR_BASE + 130),
-SSL_ERROR_INCORRECT_SIGNATURE_ALGORITHM = (SSL_ERROR_BASE + 131),
-
 SSL_ERROR_END_OF_LIST	/* let the c compiler determine the value of this. */
 } SSLErrorCodes;
 #endif /* NO_SECURITY_ERROR_ENUM */
diff --git a/src/net/third_party/nss/ssl/sslgathr.c b/src/net/third_party/nss/ssl/sslgathr.c
index 4dd2dc9..5b112fe 100644
--- a/src/net/third_party/nss/ssl/sslgathr.c
+++ b/src/net/third_party/nss/ssl/sslgathr.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslgathr.c,v 1.15 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 #include "cert.h"
 #include "ssl.h"
 #include "sslimpl.h"
diff --git a/src/net/third_party/nss/ssl/sslimpl.h b/src/net/third_party/nss/ssl/sslimpl.h
index 24a83df..d6d9ad1 100644
--- a/src/net/third_party/nss/ssl/sslimpl.h
+++ b/src/net/third_party/nss/ssl/sslimpl.h
@@ -5,7 +5,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslimpl.h,v 1.108 2012/09/28 01:46:45 wtc%google.com Exp $ */
 
 #ifndef __sslimpl_h_
 #define __sslimpl_h_
@@ -71,7 +71,6 @@ typedef SSLSignType     SSL3SignType;
 #define mac_sha 	ssl_mac_sha
 #define hmac_md5	ssl_hmac_md5
 #define hmac_sha	ssl_hmac_sha
-#define hmac_sha256	ssl_hmac_sha256
 
 #define SET_ERROR_CODE		/* reminder */
 #define SEND_ALERT		/* reminder */
@@ -152,9 +151,11 @@ typedef enum { SSLAppOpRead = 0,
 #define NUM_MIXERS                      9
 
 /* Mask of the 25 named curves we support. */
-#define SSL3_ALL_SUPPORTED_CURVES_MASK 0x3fffffe
-/* only 3 curves, suite B*/
-#define SSL3_SUITE_B_SUPPORTED_CURVES_MASK 0x3800000
+#ifndef NSS_ECC_MORE_THAN_SUITE_B
+#define SSL3_SUPPORTED_CURVES_MASK 0x3800000	/* only 3 curves, suite B*/
+#else
+#define SSL3_SUPPORTED_CURVES_MASK 0x3fffffe
+#endif
 
 #ifndef BPB
 #define BPB 8 /* Bits Per Byte */
@@ -291,9 +292,9 @@ typedef struct {
 } ssl3CipherSuiteCfg;
 
 #ifdef NSS_ENABLE_ECC
-#define ssl_V3_SUITES_IMPLEMENTED 57
+#define ssl_V3_SUITES_IMPLEMENTED 50
 #else
-#define ssl_V3_SUITES_IMPLEMENTED 35
+#define ssl_V3_SUITES_IMPLEMENTED 30
 #endif /* NSS_ENABLE_ECC */
 
 #define MAX_DTLS_SRTP_CIPHER_SUITES 4
@@ -506,9 +507,7 @@ typedef PRUint16 DTLSEpoch;
 
 typedef void (*DTLSTimerCb)(sslSocket *);
 
-#define MAX_MAC_CONTEXT_BYTES 400  /* 400 is large enough for MD5, SHA-1, and
-                                    * SHA-256. For SHA-384 support, increase
-                                    * it to 712. */
+#define MAX_MAC_CONTEXT_BYTES 400
 #define MAX_MAC_CONTEXT_LLONGS (MAX_MAC_CONTEXT_BYTES / 8)
 
 #define MAX_CIPHER_CONTEXT_BYTES 2080
@@ -598,7 +597,6 @@ struct sslSessionIDStr {
 
     CERTCertificate *     peerCert;
     CERTCertificate *     peerCertChain[MAX_PEER_CERT_CHAIN_SIZE];
-    SECItemArray          peerCertStatus; /* client only */
     const char *          peerID;     /* client only */
     const char *          urlSvrName; /* client only */
     CERTCertificate *     localCert;
@@ -741,7 +739,6 @@ typedef enum {
     wait_change_cipher, 
     wait_finished,
     wait_server_hello, 
-    wait_certificate_status,
     wait_server_cert, 
     wait_server_key,
     wait_cert_request, 
@@ -790,12 +787,6 @@ typedef struct DTLSQueuedMessageStr {
     PRUint16 len;         /* The data length */
 } DTLSQueuedMessage;
 
-typedef enum {
-    handshake_hash_unknown = 0,
-    handshake_hash_combo = 1,  /* The MD5/SHA-1 combination */
-    handshake_hash_single = 2  /* A single hash */
-} SSL3HandshakeHashType;
-
 /*
 ** This is the "hs" member of the "ssl3" struct.
 ** This entire struct is protected by ssl3HandshakeLock
@@ -804,31 +795,10 @@ typedef struct SSL3HandshakeStateStr {
     SSL3Random            server_random;
     SSL3Random            client_random;
     SSL3WaitState         ws;
-
-    /* This group of members is used for handshake running hashes. */
-    SSL3HandshakeHashType hashType;
-    sslBuffer             messages;    /* Accumulated handshake messages */
-#ifndef NO_PKCS11_BYPASS
-    /* Bypass mode:
-     * SSL 3.0 - TLS 1.1 use both |md5_cx| and |sha_cx|. |md5_cx| is used for
-     * MD5 and |sha_cx| for SHA-1.
-     * TLS 1.2 and later use only |sha_cx|, for SHA-256. NOTE: When we support
-     * SHA-384, increase MAX_MAC_CONTEXT_BYTES to 712. */
     PRUint64              md5_cx[MAX_MAC_CONTEXT_LLONGS];
     PRUint64              sha_cx[MAX_MAC_CONTEXT_LLONGS];
-    const SECHashObject * sha_obj;
-    /* The function prototype of sha_obj->clone() does not match the prototype
-     * of the freebl <HASH>_Clone functions, so we need a dedicated function
-     * pointer for the <HASH>_Clone function. */
-    void (*sha_clone)(void *dest, void *src);
-#endif
-    /* PKCS #11 mode:
-     * SSL 3.0 - TLS 1.1 use both |md5| and |sha|. |md5| is used for MD5 and
-     * |sha| for SHA-1.
-     * TLS 1.2 and later use only |sha|, for SHA-256. */
-    PK11Context *         md5;
+    PK11Context *         md5;            /* handshake running hashes */
     PK11Context *         sha;
-
 const ssl3KEADef *        kea_def;
     ssl3CipherSuite       cipher_suite;
 const ssl3CipherSuiteDef *suite_def;
@@ -844,12 +814,21 @@ const ssl3CipherSuiteDef *suite_def;
     PRBool                isResuming;  /* are we resuming a session */
     PRBool                usedStepDownKey;  /* we did a server key exchange. */
     PRBool                sendingSCSV; /* instead of empty RI */
+    PRBool                may_get_cert_status; /* the server echoed a
+                                                * status_request extension so
+                                                * may send a CertificateStatus
+                                                * handshake message. */
+    SECItem               pending_cert_msg; /* a Certificate message which we
+                                             * save temporarily if we may get
+                                             * a CertificateStatus message */
+    SECItem               cert_status; /* an OCSP response */
     sslBuffer             msgState;    /* current state for handshake messages*/
                                        /* protected by recvBufLock */
+    sslBuffer             messages;    /* Accumulated handshake messages */
     PRUint16              finishedBytes; /* size of single finished below */
     union {
 	TLSFinished       tFinished[2]; /* client, then server */
-	SSL3Finished      sFinished[2];
+	SSL3Hashes        sFinished[2];
 	SSL3Opaque        data[72];
     }                     finishedMsgs;
 #ifdef NSS_ENABLE_ECC
@@ -864,12 +843,6 @@ const ssl3CipherSuiteDef *suite_def;
     /* Shared state between ssl3_HandleFinished and ssl3_FinishHandshake */
     PRBool                cacheSID;
 
-    /* clientSigAndHash contains the contents of the signature_algorithms
-     * extension (if any) from the client. This is only valid for TLS 1.2
-     * or later. */
-    SSL3SignatureAndHashAlgorithm *clientSigAndHash;
-    unsigned int          numClientSigAndHash;
-
     /* This group of values is used for DTLS */
     PRUint16              sendMessageSeq;  /* The sending message sequence
 					    * number */
@@ -1249,7 +1222,6 @@ const unsigned char *  preferredCipher;
     /* Configuration state for server sockets */
     /* server cert and key for each KEA type */
     sslServerCerts        serverCerts[kt_kea_size];
-    SECItemArray *        certStatusArray;
 
     ssl3CipherSuiteCfg cipherSuites[ssl_V3_SUITES_IMPLEMENTED];
     ssl3KeyPair *         ephemeralECDHKeyPair; /* for ECDHE-* handshake */
@@ -1293,15 +1265,6 @@ extern sslSessionIDUncacheFunc ssl_sid_uncache;
 
 SEC_BEGIN_PROTOS
 
-/* Functions for handling SECItemArrays, added in NSS 3.15 */
-extern SECItemArray *SECITEM_AllocArray(PLArenaPool *arena,
-                                        SECItemArray *array,
-                                        unsigned int len);
-extern SECItemArray *SECITEM_DupArray(PLArenaPool *arena,
-                                      const SECItemArray *from);
-extern void SECITEM_FreeArray(SECItemArray *array, PRBool freeit);
-extern void SECITEM_ZfreeArray(SECItemArray *array, PRBool freeit);
-
 /* Internal initialization and installation of the SSL error tables */
 extern SECStatus ssl_Init(void);
 extern SECStatus ssl_InitializePRErrorTable(void);
@@ -1508,7 +1471,7 @@ extern PRInt32   ssl3_SendRecord(sslSocket *ss, DTLSEpoch epoch,
  * runtime to determine which versions are supported by the version of libssl
  * in use.
  */
-#define SSL_LIBRARY_VERSION_MAX_SUPPORTED SSL_LIBRARY_VERSION_TLS_1_2
+#define SSL_LIBRARY_VERSION_MAX_SUPPORTED SSL_LIBRARY_VERSION_TLS_1_1
 
 /* Rename this macro SSL_ALL_VERSIONS_DISABLED when SSL 2.0 is removed. */
 #define SSL3_ALL_VERSIONS_DISABLED(vrange) \
@@ -1579,8 +1542,6 @@ extern void      ssl3_FilterECCipherSuitesByServerCerts(sslSocket *ss);
 extern PRBool    ssl3_IsECCEnabled(sslSocket *ss);
 extern SECStatus ssl3_DisableECCSuites(sslSocket * ss, 
                                        const ssl3CipherSuite * suite);
-extern PRInt32   ssl3_GetSupportedECCCurveMask(sslSocket *ss);
-
 
 /* Macro for finding a curve equivalent in strength to RSA key's */
 #define SSL_RSASTRENGTH_TO_ECSTRENGTH(s) \
@@ -1674,12 +1635,10 @@ extern SECStatus ssl3_HandleECDHClientKeyExchange(sslSocket *ss,
 				     SSL3Opaque *b, PRUint32 length,
                                      SECKEYPublicKey *srvrPubKey,
                                      SECKEYPrivateKey *srvrPrivKey);
-extern SECStatus ssl3_SendECDHServerKeyExchange(sslSocket *ss,
-			const SSL3SignatureAndHashAlgorithm *sigAndHash);
+extern SECStatus ssl3_SendECDHServerKeyExchange(sslSocket *ss);
 #endif
 
-extern SECStatus ssl3_ComputeCommonKeyHash(SECOidTag hashAlg,
-				PRUint8 * hashBuf,
+extern SECStatus ssl3_ComputeCommonKeyHash(PRUint8 * hashBuf, 
 				unsigned int bufLen, SSL3Hashes *hashes, 
 				PRBool bypassPKCS11);
 extern void ssl3_DestroyCipherSpec(ssl3CipherSpec *spec, PRBool freeSrvName);
@@ -1692,23 +1651,12 @@ extern SECStatus ssl3_AppendHandshakeNumber(sslSocket *ss, PRInt32 num,
 			PRInt32 lenSize);
 extern SECStatus ssl3_AppendHandshakeVariable( sslSocket *ss, 
 			const SSL3Opaque *src, PRInt32 bytes, PRInt32 lenSize);
-extern SECStatus ssl3_AppendSignatureAndHashAlgorithm(sslSocket *ss,
-			const SSL3SignatureAndHashAlgorithm* sigAndHash);
-extern SECStatus ssl3_AppendSupportedSignatureAlgorithms(sslSocket *ss);
-extern unsigned int ssl3_SizeOfSupportedSignatureAlgorithms(void);
 extern SECStatus ssl3_ConsumeHandshake(sslSocket *ss, void *v, PRInt32 bytes, 
 			SSL3Opaque **b, PRUint32 *length);
 extern PRInt32   ssl3_ConsumeHandshakeNumber(sslSocket *ss, PRInt32 bytes, 
 			SSL3Opaque **b, PRUint32 *length);
 extern SECStatus ssl3_ConsumeHandshakeVariable(sslSocket *ss, SECItem *i, 
 			PRInt32 bytes, SSL3Opaque **b, PRUint32 *length);
-extern SECOidTag ssl3_TLSHashAlgorithmToOID(int hashFunc);
-extern SECStatus ssl3_CheckSignatureAndHashAlgorithmConsistency(
-			const SSL3SignatureAndHashAlgorithm *sigAndHash,
-			CERTCertificate* cert);
-extern SECStatus ssl3_ConsumeSignatureAndHashAlgorithm(sslSocket *ss,
-			SSL3Opaque **b, PRUint32 *length,
-			SSL3SignatureAndHashAlgorithm *out);
 extern SECStatus ssl3_SignHashes(SSL3Hashes *hash, SECKEYPrivateKey *key, 
 			SECItem *buf, PRBool isTLS);
 extern SECStatus ssl3_VerifySignedHashes(SSL3Hashes *hash, 
@@ -1727,6 +1675,8 @@ extern SECStatus ssl3_HandleSupportedPointFormatsXtn(sslSocket * ss,
 			PRUint16 ex_type, SECItem *data);
 extern SECStatus ssl3_ClientHandleSessionTicketXtn(sslSocket *ss,
 			PRUint16 ex_type, SECItem *data);
+extern SECStatus ssl3_ClientHandleStatusRequestXtn(sslSocket *ss,
+			PRUint16 ex_type, SECItem *data);
 extern SECStatus ssl3_ServerHandleSessionTicketXtn(sslSocket *ss,
 			PRUint16 ex_type, SECItem *data);
 
@@ -1736,6 +1686,8 @@ extern SECStatus ssl3_ServerHandleSessionTicketXtn(sslSocket *ss,
  */
 extern PRInt32 ssl3_SendSessionTicketXtn(sslSocket *ss, PRBool append,
 			PRUint32 maxBytes);
+extern PRInt32 ssl3_ClientSendStatusRequestXtn(sslSocket *ss, PRBool append,
+			PRUint32 maxBytes);
 
 /* ClientHello and ServerHello extension senders.
  * The code is in ssl3ext.c.
@@ -1920,6 +1872,8 @@ SEC_END_PROTOS
 
 #if defined(XP_UNIX) || defined(XP_OS2) || defined(XP_BEOS)
 #define SSL_GETPID getpid
+#elif defined(_WIN32_WCE)
+#define SSL_GETPID GetCurrentProcessId
 #elif defined(WIN32)
 extern int __cdecl _getpid(void);
 #define SSL_GETPID _getpid
diff --git a/src/net/third_party/nss/ssl/sslinfo.c b/src/net/third_party/nss/ssl/sslinfo.c
index f0a6952..3dcb6db 100644
--- a/src/net/third_party/nss/ssl/sslinfo.c
+++ b/src/net/third_party/nss/ssl/sslinfo.c
@@ -1,7 +1,7 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslinfo.c,v 1.31 2012/08/03 23:54:31 wtc%google.com Exp $ */
 #include "ssl.h"
 #include "sslimpl.h"
 #include "sslproto.h"
@@ -128,7 +128,6 @@ SSL_GetChannelInfo(PRFileDesc *fd, SSLChannelInfo *info, PRUintn len)
 #define B_40    128,  40,  40
 #define B_0  	  0,   0,   0
 
-#define M_SHA256 "SHA256", ssl_hmac_sha256, 256
 #define M_SHA	"SHA1", ssl_mac_sha, 160
 #define M_MD5	"MD5",  ssl_mac_md5, 128
 
@@ -136,24 +135,20 @@ static const SSLCipherSuiteInfo suiteInfo[] = {
 /* <------ Cipher suite --------------------> <auth> <KEA>  <bulk cipher> <MAC> <FIPS> */
 {0,CS(TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA), S_RSA, K_DHE, C_CAMELLIA, B_256, M_SHA, 0, 0, 0, },
 {0,CS(TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA), S_DSA, K_DHE, C_CAMELLIA, B_256, M_SHA, 0, 0, 0, },
-{0,CS(TLS_DHE_RSA_WITH_AES_256_CBC_SHA256),   S_RSA, K_DHE, C_AES, B_256, M_SHA256, 1, 0, 0, },
 {0,CS(TLS_DHE_RSA_WITH_AES_256_CBC_SHA),      S_RSA, K_DHE, C_AES, B_256, M_SHA, 1, 0, 0, },
 {0,CS(TLS_DHE_DSS_WITH_AES_256_CBC_SHA),      S_DSA, K_DHE, C_AES, B_256, M_SHA, 1, 0, 0, },
 {0,CS(TLS_RSA_WITH_CAMELLIA_256_CBC_SHA),     S_RSA, K_RSA, C_CAMELLIA, B_256, M_SHA, 0, 0, 0, },
-{0,CS(TLS_RSA_WITH_AES_256_CBC_SHA256),       S_RSA, K_RSA, C_AES, B_256, M_SHA256, 1, 0, 0, },
 {0,CS(TLS_RSA_WITH_AES_256_CBC_SHA),          S_RSA, K_RSA, C_AES, B_256, M_SHA, 1, 0, 0, },
 
 {0,CS(TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA), S_RSA, K_DHE, C_CAMELLIA, B_128, M_SHA, 0, 0, 0, },
 {0,CS(TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA), S_DSA, K_DHE, C_CAMELLIA, B_128, M_SHA, 0, 0, 0, },
 {0,CS(TLS_DHE_DSS_WITH_RC4_128_SHA),          S_DSA, K_DHE, C_RC4, B_128, M_SHA, 0, 0, 0, },
-{0,CS(TLS_DHE_RSA_WITH_AES_128_CBC_SHA256),   S_RSA, K_DHE, C_AES, B_128, M_SHA256, 1, 0, 0, },
 {0,CS(TLS_DHE_RSA_WITH_AES_128_CBC_SHA),      S_RSA, K_DHE, C_AES, B_128, M_SHA, 1, 0, 0, },
 {0,CS(TLS_DHE_DSS_WITH_AES_128_CBC_SHA),      S_DSA, K_DHE, C_AES, B_128, M_SHA, 1, 0, 0, },
 {0,CS(TLS_RSA_WITH_SEED_CBC_SHA),             S_RSA, K_RSA, C_SEED,B_128, M_SHA, 1, 0, 0, },
 {0,CS(TLS_RSA_WITH_CAMELLIA_128_CBC_SHA),     S_RSA, K_RSA, C_CAMELLIA, B_128, M_SHA, 0, 0, 0, },
 {0,CS(SSL_RSA_WITH_RC4_128_SHA),              S_RSA, K_RSA, C_RC4, B_128, M_SHA, 0, 0, 0, },
 {0,CS(SSL_RSA_WITH_RC4_128_MD5),              S_RSA, K_RSA, C_RC4, B_128, M_MD5, 0, 0, 0, },
-{0,CS(TLS_RSA_WITH_AES_128_CBC_SHA256),       S_RSA, K_RSA, C_AES, B_128, M_SHA256, 1, 0, 0, },
 {0,CS(TLS_RSA_WITH_AES_128_CBC_SHA),          S_RSA, K_RSA, C_AES, B_128, M_SHA, 1, 0, 0, },
 
 {0,CS(SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA),     S_RSA, K_DHE, C_3DES,B_3DES,M_SHA, 1, 0, 0, },
@@ -170,7 +165,6 @@ static const SSLCipherSuiteInfo suiteInfo[] = {
 {0,CS(TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA),   S_RSA, K_RSA, C_DES, B_DES, M_SHA, 0, 1, 0, },
 {0,CS(SSL_RSA_EXPORT_WITH_RC4_40_MD5),        S_RSA, K_RSA, C_RC4, B_40,  M_MD5, 0, 1, 0, },
 {0,CS(SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5),    S_RSA, K_RSA, C_RC2, B_40,  M_MD5, 0, 1, 0, },
-{0,CS(TLS_RSA_WITH_NULL_SHA256),              S_RSA, K_RSA, C_NULL,B_0,   M_SHA256, 0, 1, 0, },
 {0,CS(SSL_RSA_WITH_NULL_SHA),                 S_RSA, K_RSA, C_NULL,B_0,   M_SHA, 0, 1, 0, },
 {0,CS(SSL_RSA_WITH_NULL_MD5),                 S_RSA, K_RSA, C_NULL,B_0,   M_MD5, 0, 1, 0, },
 
@@ -186,7 +180,6 @@ static const SSLCipherSuiteInfo suiteInfo[] = {
 {0,CS(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA),      S_ECDSA, K_ECDHE, C_RC4, B_128, M_SHA, 0, 0, 0, },
 {0,CS(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA), S_ECDSA, K_ECDHE, C_3DES, B_3DES, M_SHA, 1, 0, 0, },
 {0,CS(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA),  S_ECDSA, K_ECDHE, C_AES, B_128, M_SHA, 1, 0, 0, },
-{0,CS(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256), S_ECDSA, K_ECDHE, C_AES, B_128, M_SHA256, 1, 0, 0, },
 {0,CS(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA),  S_ECDSA, K_ECDHE, C_AES, B_256, M_SHA, 1, 0, 0, },
 
 {0,CS(TLS_ECDH_RSA_WITH_NULL_SHA),            S_RSA, K_ECDH, C_NULL, B_0, M_SHA, 0, 0, 0, },
@@ -199,7 +192,6 @@ static const SSLCipherSuiteInfo suiteInfo[] = {
 {0,CS(TLS_ECDHE_RSA_WITH_RC4_128_SHA),        S_RSA, K_ECDHE, C_RC4, B_128, M_SHA, 0, 0, 0, },
 {0,CS(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA),   S_RSA, K_ECDHE, C_3DES, B_3DES, M_SHA, 1, 0, 0, },
 {0,CS(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA),    S_RSA, K_ECDHE, C_AES, B_128, M_SHA, 1, 0, 0, },
-{0,CS(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256), S_RSA, K_ECDHE, C_AES, B_128, M_SHA256, 1, 0, 0, },
 {0,CS(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA),    S_RSA, K_ECDHE, C_AES, B_256, M_SHA, 1, 0, 0, },
 #endif /* NSS_ENABLE_ECC */
 
diff --git a/src/net/third_party/nss/ssl/sslinit.c b/src/net/third_party/nss/ssl/sslinit.c
index 92679bf..57db7bf 100644
--- a/src/net/third_party/nss/ssl/sslinit.c
+++ b/src/net/third_party/nss/ssl/sslinit.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslinit.c,v 1.3 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "prtypes.h"
 #include "prinit.h"
diff --git a/src/net/third_party/nss/ssl/sslmutex.c b/src/net/third_party/nss/ssl/sslmutex.c
index a9f60d9..6b6c9c9 100644
--- a/src/net/third_party/nss/ssl/sslmutex.c
+++ b/src/net/third_party/nss/ssl/sslmutex.c
@@ -1,7 +1,7 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslmutex.c,v 1.28 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "seccomon.h"
 /* This ifdef should match the one in sslsnce.c */
diff --git a/src/net/third_party/nss/ssl/sslmutex.h b/src/net/third_party/nss/ssl/sslmutex.h
index 5914986..b3f3212 100644
--- a/src/net/third_party/nss/ssl/sslmutex.h
+++ b/src/net/third_party/nss/ssl/sslmutex.h
@@ -1,7 +1,7 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslmutex.h,v 1.14 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 #ifndef __SSLMUTEX_H_
 #define __SSLMUTEX_H_ 1
 
diff --git a/src/net/third_party/nss/ssl/sslnonce.c b/src/net/third_party/nss/ssl/sslnonce.c
index da8ab11..16af5f4 100644
--- a/src/net/third_party/nss/ssl/sslnonce.c
+++ b/src/net/third_party/nss/ssl/sslnonce.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslnonce.c,v 1.27 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "cert.h"
 #include "pk11pub.h"
@@ -15,7 +15,7 @@
 #include "sslimpl.h"
 #include "sslproto.h"
 #include "nssilock.h"
-#if defined(XP_UNIX) || defined(XP_WIN) || defined(_WINDOWS) || defined(XP_BEOS)
+#if (defined(XP_UNIX) || defined(XP_WIN) || defined(_WINDOWS) || defined(XP_BEOS)) && !defined(_WIN32_WCE)
 #include <time.h>
 #endif
 
@@ -188,12 +188,6 @@ ssl_DestroySID(sslSessionID *sid)
     for (i = 0; i < MAX_PEER_CERT_CHAIN_SIZE && sid->peerCertChain[i]; i++) {
 	CERT_DestroyCertificate(sid->peerCertChain[i]);
     }
-    if (sid->peerCertStatus.len) {
-        SECITEM_FreeArray(&sid->peerCertStatus, PR_FALSE);
-        sid->peerCertStatus.items = NULL;
-        sid->peerCertStatus.len = 0;
-    }
-
     if ( sid->localCert ) {
 	CERT_DestroyCertificate(sid->localCert);
     }
@@ -462,7 +456,7 @@ PRUint32
 ssl_Time(void)
 {
     PRUint32 myTime;
-#if defined(XP_UNIX) || defined(XP_WIN) || defined(_WINDOWS) || defined(XP_BEOS)
+#if (defined(XP_UNIX) || defined(XP_WIN) || defined(_WINDOWS) || defined(XP_BEOS)) && !defined(_WIN32_WCE)
     myTime = time(NULL);	/* accurate until the year 2038. */
 #else
     /* portable, but possibly slower */
diff --git a/src/net/third_party/nss/ssl/sslplatf.c b/src/net/third_party/nss/ssl/sslplatf.c
index 8802fbf..cc3c7c6 100644
--- a/src/net/third_party/nss/ssl/sslplatf.c
+++ b/src/net/third_party/nss/ssl/sslplatf.c
@@ -38,21 +38,12 @@
  *
  * ***** END LICENSE BLOCK ***** */
 /* $Id$ */
+#include "ssl.h"
 #include "certt.h"
-#include "cryptohi.h"
 #include "keythi.h"
-#include "nss.h"
-#include "secitem.h"
-#include "ssl.h"
 #include "sslimpl.h"
-#include "prerror.h"
-#include "prinit.h"
-
-#ifdef NSS_PLATFORM_CLIENT_AUTH
-#ifdef XP_WIN32
-#include <NCrypt.h>
-#endif
-#endif
+#include "cryptohi.h"
+#include "secitem.h"
 
 #ifdef NSS_PLATFORM_CLIENT_AUTH
 CERTCertificateList*
@@ -107,226 +98,20 @@ loser:
 }
 
 #if defined(XP_WIN32)
-typedef SECURITY_STATUS (WINAPI *NCryptFreeObjectFunc)(NCRYPT_HANDLE);
-typedef SECURITY_STATUS (WINAPI *NCryptSignHashFunc)(
-    NCRYPT_KEY_HANDLE /* hKey */,
-    VOID* /* pPaddingInfo */,
-    PBYTE /* pbHashValue */,
-    DWORD /* cbHashValue */,
-    PBYTE /* pbSignature */,
-    DWORD /* cbSignature */,
-    DWORD* /* pcbResult */,
-    DWORD /* dwFlags */);
-
-static PRCallOnceType cngFunctionsInitOnce;
-static const PRCallOnceType pristineCallOnce;
-
-static PRLibrary *ncrypt_library = NULL;
-static NCryptFreeObjectFunc pNCryptFreeObject = NULL;
-static NCryptSignHashFunc pNCryptSignHash = NULL;
-
-static SECStatus
-ssl_ShutdownCngFunctions(void *appData, void *nssData)
-{
-    pNCryptSignHash = NULL;
-    pNCryptFreeObject = NULL;
-    if (ncrypt_library) {
-        PR_UnloadLibrary(ncrypt_library);
-        ncrypt_library = NULL;
-    }
-
-    cngFunctionsInitOnce = pristineCallOnce;
-
-    return SECSuccess;
-}
-
-static PRStatus
-ssl_InitCngFunctions(void)
-{
-    SECStatus rv;
-
-    ncrypt_library = PR_LoadLibrary("ncrypt.dll");
-    if (ncrypt_library == NULL)
-        goto loser;
-
-    pNCryptFreeObject = (NCryptFreeObjectFunc)PR_FindFunctionSymbol(
-        ncrypt_library, "NCryptFreeObject");
-    if (pNCryptFreeObject == NULL)
-        goto loser;
-
-    pNCryptSignHash = (NCryptSignHashFunc)PR_FindFunctionSymbol(
-        ncrypt_library, "NCryptSignHash");
-    if (pNCryptSignHash == NULL)
-        goto loser;
-
-    rv = NSS_RegisterShutdown(ssl_ShutdownCngFunctions, NULL);
-    if (rv != SECSuccess)
-        goto loser;
-
-    return PR_SUCCESS;
-
-loser:
-    pNCryptSignHash = NULL;
-    pNCryptFreeObject = NULL;
-    if (ncrypt_library) {
-        PR_UnloadLibrary(ncrypt_library);
-        ncrypt_library = NULL;
-    }
-
-    return PR_FAILURE;
-}
-
-static SECStatus
-ssl_InitCng(void)
-{
-    if (PR_CallOnce(&cngFunctionsInitOnce, ssl_InitCngFunctions) != PR_SUCCESS)
-        return SECFailure;
-    return SECSuccess;
-}
-
 void
 ssl_FreePlatformKey(PlatformKey key)
 {
-    if (!key)
-        return;
-
-    if (key->dwKeySpec == CERT_NCRYPT_KEY_SPEC) {
-        if (ssl_InitCng() == SECSuccess) {
-            (*pNCryptFreeObject)(key->hNCryptKey);
-        }
-    } else {
-        CryptReleaseContext(key->hCryptProv, 0);
-    }
-    PORT_Free(key);
-}
-
-static SECStatus
-ssl3_CngPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-                           PRBool isTLS, KeyType keyType)
-{
-    SECStatus       rv                = SECFailure;
-    SECURITY_STATUS ncrypt_status;
-    PRBool          doDerEncode       = PR_FALSE;
-    SECItem         hashItem;
-    DWORD           signatureLen      = 0;
-    DWORD           dwFlags           = 0;
-    VOID           *pPaddingInfo      = NULL;
-
-    /* Always encode using PKCS#1 block type. */
-    BCRYPT_PKCS1_PADDING_INFO rsaPaddingInfo;
-
-    if (key->dwKeySpec != CERT_NCRYPT_KEY_SPEC) {
-        PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
-        return SECFailure;
-    }
-    if (ssl_InitCng() != SECSuccess) {
-        PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
-        return SECFailure;
-    }
-
-    switch (keyType) {
-        case rsaKey:
-            switch (hash->hashAlg) {
-                case SEC_OID_UNKNOWN:
-                    /* No OID/encoded DigestInfo. */
-                    rsaPaddingInfo.pszAlgId = NULL;
-                    break;
-                case SEC_OID_SHA1:
-                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA1_ALGORITHM;
-                    break;
-                case SEC_OID_SHA256:
-                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA256_ALGORITHM;
-                    break;
-                case SEC_OID_SHA384:
-                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA384_ALGORITHM;
-                    break;
-                case SEC_OID_SHA512:
-                    rsaPaddingInfo.pszAlgId = BCRYPT_SHA512_ALGORITHM;
-                    break;
-                default:
-                    PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-                    return SECFailure;
-            }
-            hashItem.data = hash->u.raw;
-            hashItem.len  = hash->len;
-            dwFlags       = BCRYPT_PAD_PKCS1;
-            pPaddingInfo  = &rsaPaddingInfo;
-            break;
-        case dsaKey:
-        case ecKey:
-            if (keyType == ecKey) {
-                doDerEncode = PR_TRUE;
-            } else {
-                doDerEncode = isTLS;
-            }
-            if (hash->hashAlg == SEC_OID_UNKNOWN) {
-                hashItem.data = hash->u.s.sha;
-                hashItem.len  = sizeof(hash->u.s.sha);
-            } else {
-                hashItem.data = hash->u.raw;
-                hashItem.len  = hash->len;
-            }
-            break;
-        default:
-            PORT_SetError(SEC_ERROR_INVALID_KEY);
-            goto done;
-    }
-    PRINT_BUF(60, (NULL, "hash(es) to be signed", hashItem.data, hashItem.len));
-
-    ncrypt_status = (*pNCryptSignHash)(key->hNCryptKey, pPaddingInfo,
-                                       (PBYTE)hashItem.data, hashItem.len,
-                                       NULL, 0, &signatureLen, dwFlags);
-    if (FAILED(ncrypt_status) || signatureLen == 0) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, ncrypt_status);
-        goto done;
-    }
-
-    buf->data = (unsigned char *)PORT_Alloc(signatureLen);
-    if (!buf->data) {
-        goto done;    /* error code was set. */
-    }
-
-    ncrypt_status = (*pNCryptSignHash)(key->hNCryptKey, pPaddingInfo,
-                                       (PBYTE)hashItem.data, hashItem.len,
-                                       (PBYTE)buf->data, signatureLen,
-                                       &signatureLen, dwFlags);
-    if (FAILED(ncrypt_status) || signatureLen == 0) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, ncrypt_status);
-        goto done;
-    }
-
-    buf->len = signatureLen;
-
-    if (doDerEncode) {
-        SECItem   derSig = {siBuffer, NULL, 0};
-
-        /* This also works for an ECDSA signature */
-        rv = DSAU_EncodeDerSigWithLen(&derSig, buf, buf->len);
-        if (rv == SECSuccess) {
-            PORT_Free(buf->data);     /* discard unencoded signature. */
-            *buf = derSig;            /* give caller encoded signature. */
-        } else if (derSig.data) {
-            PORT_Free(derSig.data);
-        }
-    } else {
-        rv = SECSuccess;
+    if (key) {
+        if (key->dwKeySpec != CERT_NCRYPT_KEY_SPEC)
+            CryptReleaseContext(key->hCryptProv, 0);
+        /* FIXME(rsleevi): Close CNG keys. */
+        PORT_Free(key);
     }
-
-    PRINT_BUF(60, (NULL, "signed hashes", buf->data, buf->len));
-
-done:
-    if (rv != SECSuccess && buf->data) {
-        PORT_Free(buf->data);
-        buf->data = NULL;
-        buf->len = 0;
-    }
-
-    return rv;
 }
 
-static SECStatus
-ssl3_CAPIPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-                            PRBool isTLS, KeyType keyType)
+SECStatus
+ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf, 
+                        PRBool isTLS, KeyType keyType)
 {
     SECStatus    rv             = SECFailure;
     PRBool       doDerEncode    = PR_FALSE;
@@ -340,34 +125,11 @@ ssl3_CAPIPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
 
     buf->data = NULL;
 
-    switch (hash->hashAlg) {
-        case SEC_OID_UNKNOWN:
-            hashAlg = 0;
-            break;
-        case SEC_OID_SHA1:
-            hashAlg = CALG_SHA1;
-            break;
-        case SEC_OID_SHA256:
-            hashAlg = CALG_SHA_256;
-            break;
-        case SEC_OID_SHA384:
-            hashAlg = CALG_SHA_384;
-            break;
-        case SEC_OID_SHA512:
-            hashAlg = CALG_SHA_512;
-            break;
-        default:
-            PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-            return SECFailure;
-    }
-
     switch (keyType) {
         case rsaKey:
-            if (hashAlg == 0) {
-                hashAlg = CALG_SSL3_SHAMD5;
-            }
-            hashItem.data = hash->u.raw;
-            hashItem.len = hash->len;
+            hashAlg       = CALG_SSL3_SHAMD5;
+            hashItem.data = hash->md5;
+            hashItem.len  = sizeof(SSL3Hashes);
             break;
         case dsaKey:
         case ecKey:
@@ -376,14 +138,9 @@ ssl3_CAPIPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
             } else {
                 doDerEncode = isTLS;
             }
-            if (hashAlg == 0) {
-                hashAlg = CALG_SHA1;
-                hashItem.data = hash->u.s.sha;
-                hashItem.len = sizeof(hash->u.s.sha);
-            } else {
-                hashItem.data = hash->u.raw;
-                hashItem.len = hash->len;
-            }
+            hashAlg       = CALG_SHA1;
+            hashItem.data = hash->sha;
+            hashItem.len  = sizeof(hash->sha);
             break;
         default:
             PORT_SetError(SEC_ERROR_INVALID_KEY);
@@ -392,25 +149,25 @@ ssl3_CAPIPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
     PRINT_BUF(60, (NULL, "hash(es) to be signed", hashItem.data, hashItem.len));
 
     if (!CryptCreateHash(key->hCryptProv, hashAlg, 0, 0, &hHash)) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
-        goto done;
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
+        goto done;    
     }
     argLen = sizeof(hashLen);
     if (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&hashLen, &argLen, 0)) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
     if (hashLen != hashItem.len) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, 0);
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
     if (!CryptSetHashParam(hHash, HP_HASHVAL, (BYTE*)hashItem.data, 0)) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
     if (!CryptSignHash(hHash, key->dwKeySpec, NULL, 0,
                        NULL, &signatureLen) || signatureLen == 0) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
     buf->data = (unsigned char *)PORT_Alloc(signatureLen);
@@ -419,7 +176,7 @@ ssl3_CAPIPlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
 
     if (!CryptSignHash(hHash, key->dwKeySpec, NULL, 0,
                        (BYTE*)buf->data, &signatureLen)) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, GetLastError());
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
     buf->len = signatureLen;
@@ -456,16 +213,6 @@ done:
     return rv;
 }
 
-SECStatus
-ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
-                        PRBool isTLS, KeyType keyType)
-{
-    if (key->dwKeySpec == CERT_NCRYPT_KEY_SPEC) {
-        return ssl3_CngPlatformSignHashes(hash, key, buf, isTLS, keyType);
-    }
-    return ssl3_CAPIPlatformSignHashes(hash, key, buf, isTLS, keyType);
-}
-
 #elif defined(XP_MACOSX)
 #include <Security/cssm.h>
 
@@ -475,83 +222,8 @@ ssl_FreePlatformKey(PlatformKey key)
     CFRelease(key);
 }
 
-#define SSL_MAX_DIGEST_INFO_PREFIX 20
-
-/* ssl3_GetDigestInfoPrefix sets |out| and |out_len| to point to a buffer that
- * contains ASN.1 data that should be prepended to a hash of the given type in
- * order to create a DigestInfo structure that is valid for use in a PKCS #1
- * v1.5 RSA signature. |out_len| will not be set to a value greater than
- * SSL_MAX_DIGEST_INFO_PREFIX. */
-static SECStatus
-ssl3_GetDigestInfoPrefix(SECOidTag hashAlg,
-                         const SSL3Opaque** out, unsigned int *out_len)
-{
-    /* These are the DER encoding of ASN.1 DigestInfo structures:
-     *   DigestInfo ::= SEQUENCE {
-     *     digestAlgorithm AlgorithmIdentifier,
-     *     digest OCTET STRING
-     *   }
-     * See PKCS #1 v2.2 Section 9.2, Note 1.
-     */
-    static const unsigned char kSHA1[] = {
-        0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e,
-        0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14
-    };
-    static const unsigned char kSHA224[] = {
-        0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
-        0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,
-        0x00, 0x04, 0x1c
-    };
-    static const unsigned char kSHA256[] = {
-        0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
-        0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
-        0x00, 0x04, 0x20
-    };
-    static const unsigned char kSHA384[] = {
-        0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
-        0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
-        0x00, 0x04, 0x30
-    };
-    static const unsigned char kSHA512[] = {
-        0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
-        0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
-        0x00, 0x04, 0x40
-    };
-
-    switch (hashAlg) {
-    case SEC_OID_UNKNOWN:
-        *out_len = 0;
-        break;
-    case SEC_OID_SHA1:
-        *out = kSHA1;
-        *out_len = sizeof(kSHA1);
-        break;
-    case SEC_OID_SHA224:
-        *out = kSHA224;
-        *out_len = sizeof(kSHA224);
-        break;
-    case SEC_OID_SHA256:
-        *out = kSHA256;
-        *out_len = sizeof(kSHA256);
-        break;
-    case SEC_OID_SHA384:
-        *out = kSHA384;
-        *out_len = sizeof(kSHA384);
-        break;
-    case SEC_OID_SHA512:
-        *out = kSHA512;
-        *out_len = sizeof(kSHA512);
-        break;
-    default:
-        PORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);
-        return SECFailure;
-    }
-
-    return SECSuccess;
-}
-
 SECStatus
-ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
+ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf, 
                         PRBool isTLS, KeyType keyType)
 {
     SECStatus       rv                  = SECFailure;
@@ -561,15 +233,11 @@ ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
     CSSM_CSP_HANDLE cspHandle           = 0;
     const CSSM_KEY *cssmKey             = NULL;
     CSSM_ALGORITHMS sigAlg;
-    CSSM_ALGORITHMS digestAlg;
     const CSSM_ACCESS_CREDENTIALS * cssmCreds = NULL;
     CSSM_RETURN     cssmRv;
     CSSM_DATA       hashData;
     CSSM_DATA       signatureData;
     CSSM_CC_HANDLE  cssmSignature       = 0;
-    const SSL3Opaque* prefix;
-    unsigned int    prefixLen;
-    SSL3Opaque      prefixAndHash[SSL_MAX_DIGEST_INFO_PREFIX + HASH_LENGTH_MAX];
 
     buf->data = NULL;
 
@@ -589,7 +257,7 @@ ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
      * needed information is readily available on the key itself.
      */
     signatureLen = (cssmKey->KeyHeader.LogicalKeySizeInBits + 7) / 8;
-
+    
     if (signatureLen == 0) {
         PORT_SetError(SEC_ERROR_INVALID_KEY);
         goto done;
@@ -600,23 +268,11 @@ ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
         goto done;    /* error code was set. */
 
     sigAlg = cssmKey->KeyHeader.AlgorithmId;
-    digestAlg = CSSM_ALGID_NONE;
-
     switch (keyType) {
         case rsaKey:
             PORT_Assert(sigAlg == CSSM_ALGID_RSA);
-            if (ssl3_GetDigestInfoPrefix(hash->hashAlg, &prefix, &prefixLen) !=
-                SECSuccess) {
-                goto done;
-            }
-            if (prefixLen + hash->len > sizeof(prefixAndHash)) {
-                PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
-                goto done;
-            }
-            memcpy(prefixAndHash, prefix, prefixLen);
-            memcpy(prefixAndHash + prefixLen, hash->u.raw, hash->len);
-            hashData.Data   = prefixAndHash;
-            hashData.Length = prefixLen + hash->len;
+            hashData.Data   = hash->md5;
+            hashData.Length = sizeof(SSL3Hashes);
             break;
         case dsaKey:
         case ecKey:
@@ -627,13 +283,8 @@ ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
                 PORT_Assert(sigAlg == CSSM_ALGID_DSA);
                 doDerEncode = isTLS;
             }
-            if (hash->hashAlg == SEC_OID_UNKNOWN) {
-                hashData.Data   = hash->u.s.sha;
-                hashData.Length = sizeof(hash->u.s.sha);
-            } else {
-                hashData.Data   = hash->u.raw;
-                hashData.Length = hash->len;
-            }
+            hashData.Data   = hash->sha;
+            hashData.Length = sizeof(hash->sha);
             break;
         default:
             PORT_SetError(SEC_ERROR_INVALID_KEY);
@@ -648,17 +299,17 @@ ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
     status = SecKeyGetCredentials(key, CSSM_ACL_AUTHORIZATION_SIGN,
                                   kSecCredentialTypeDefault, &cssmCreds);
     if (status != noErr) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, status);
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
 
     signatureData.Length = signatureLen;
     signatureData.Data   = (uint8*)buf->data;
-
+    
     cssmRv = CSSM_CSP_CreateSignatureContext(cspHandle, sigAlg, cssmCreds,
                                              cssmKey, &cssmSignature);
     if (cssmRv) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, cssmRv);
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
 
@@ -671,15 +322,15 @@ ssl3_PlatformSignHashes(SSL3Hashes *hash, PlatformKey key, SECItem *buf,
         blindingAttr.Attribute.Uint32 = 1;
         cssmRv = CSSM_UpdateContextAttributes(cssmSignature, 1, &blindingAttr);
         if (cssmRv) {
-            PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, cssmRv);
+            PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
             goto done;
         }
     }
 
-    cssmRv = CSSM_SignData(cssmSignature, &hashData, 1, digestAlg,
+    cssmRv = CSSM_SignData(cssmSignature, &hashData, 1, CSSM_ALGID_NONE,
                            &signatureData);
     if (cssmRv) {
-        PR_SetError(SSL_ERROR_SIGN_HASHES_FAILURE, cssmRv);
+        PORT_SetError(SSL_ERROR_SIGN_HASHES_FAILURE);
         goto done;
     }
     buf->len = signatureData.Length;
diff --git a/src/net/third_party/nss/ssl/sslproto.h b/src/net/third_party/nss/ssl/sslproto.h
index 885f910..13d1476 100644
--- a/src/net/third_party/nss/ssl/sslproto.h
+++ b/src/net/third_party/nss/ssl/sslproto.h
@@ -6,7 +6,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslproto.h,v 1.20 2012/06/07 02:06:19 wtc%google.com Exp $ */
 
 #ifndef __sslproto_h_
 #define __sslproto_h_
@@ -16,7 +16,6 @@
 #define SSL_LIBRARY_VERSION_3_0			0x0300
 #define SSL_LIBRARY_VERSION_TLS_1_0		0x0301
 #define SSL_LIBRARY_VERSION_TLS_1_1		0x0302
-#define SSL_LIBRARY_VERSION_TLS_1_2		0x0303
 /* Note: this is the internal format, not the wire format */
 #define SSL_LIBRARY_VERSION_DTLS_1_0		0x0302
 
@@ -134,9 +133,6 @@
 #define TLS_DHE_DSS_WITH_AES_256_CBC_SHA  	0x0038
 #define TLS_DHE_RSA_WITH_AES_256_CBC_SHA  	0x0039
 #define TLS_DH_ANON_WITH_AES_256_CBC_SHA  	0x003A
-#define TLS_RSA_WITH_NULL_SHA256		0x003B
-#define TLS_RSA_WITH_AES_128_CBC_SHA256  	0x003C
-#define TLS_RSA_WITH_AES_256_CBC_SHA256  	0x003D
 
 #define TLS_RSA_WITH_CAMELLIA_128_CBC_SHA      	0x0041
 #define TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA   	0x0042
@@ -151,8 +147,6 @@
 #define TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA 0x0063
 #define TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA  0x0065
 #define TLS_DHE_DSS_WITH_RC4_128_SHA            0x0066
-#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     0x0067
-#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     0x006B
 
 #define TLS_RSA_WITH_CAMELLIA_256_CBC_SHA      	0x0084
 #define TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA   	0x0085
@@ -202,9 +196,6 @@
 #define TLS_ECDH_anon_WITH_AES_128_CBC_SHA      0xC018
 #define TLS_ECDH_anon_WITH_AES_256_CBC_SHA      0xC019
 
-#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 0xC023
-#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   0xC027
-
 /* Netscape "experimental" cipher suites. */
 #define SSL_RSA_OLDFIPS_WITH_3DES_EDE_CBC_SHA	0xffe0
 #define SSL_RSA_OLDFIPS_WITH_DES_CBC_SHA	0xffe1
diff --git a/src/net/third_party/nss/ssl/sslreveal.c b/src/net/third_party/nss/ssl/sslreveal.c
index e2d4058..63abe5d 100644
--- a/src/net/third_party/nss/ssl/sslreveal.c
+++ b/src/net/third_party/nss/ssl/sslreveal.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslreveal.c,v 1.9 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "cert.h"
 #include "ssl.h"
diff --git a/src/net/third_party/nss/ssl/sslsecur.c b/src/net/third_party/nss/ssl/sslsecur.c
index c4e9e12..ae9771e 100644
--- a/src/net/third_party/nss/ssl/sslsecur.c
+++ b/src/net/third_party/nss/ssl/sslsecur.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslsecur.c,v 1.61 2012/05/24 20:34:51 wtc%google.com Exp $ */
 #include "cert.h"
 #include "secitem.h"
 #include "keyhi.h"
diff --git a/src/net/third_party/nss/ssl/sslsnce.c b/src/net/third_party/nss/ssl/sslsnce.c
index 6b30f7d..2b0ed08 100644
--- a/src/net/third_party/nss/ssl/sslsnce.c
+++ b/src/net/third_party/nss/ssl/sslsnce.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslsnce.c,v 1.63 2012/06/14 19:04:59 wtc%google.com Exp $ */
 
 /* Note: ssl_FreeSID() in sslnonce.c gets used for both client and server 
  * cache sids!
@@ -2032,7 +2032,7 @@ ssl_GetSessionTicketKeys(unsigned char *keyName, unsigned char *encKey,
     PRBool rv = PR_FALSE;
     PRUint32 now = 0;
     cacheDesc *cache = &globalCache;
-    uint8 ticketMacKey[SHA256_LENGTH], ticketEncKey[AES_256_KEY_LENGTH];
+    uint8 ticketMacKey[AES_256_KEY_LENGTH], ticketEncKey[SHA256_LENGTH];
     uint8 ticketKeyNameSuffixLocal[SESS_TICKET_KEY_VAR_NAME_LEN];
     uint8 *ticketMacKeyPtr, *ticketEncKeyPtr, *ticketKeyNameSuffix;
     PRBool cacheIsEnabled = PR_TRUE;
diff --git a/src/net/third_party/nss/ssl/sslsock.c b/src/net/third_party/nss/ssl/sslsock.c
index b76202f..46f1c80 100644
--- a/src/net/third_party/nss/ssl/sslsock.c
+++ b/src/net/third_party/nss/ssl/sslsock.c
@@ -6,7 +6,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslsock.c,v 1.96 2012/09/24 23:57:42 wtc%google.com Exp $ */
 #include "seccomon.h"
 #include "cert.h"
 #include "keyhi.h"
@@ -18,15 +18,8 @@
 #ifndef NO_PKCS11_BYPASS
 #include "blapi.h"
 #endif
-#include "pk11pub.h"
 #include "nss.h"
 
-/* This is a bodge to allow this code to be compiled against older NSS headers
- * that don't contain the TLS 1.2 changes. */
-#ifndef CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256
-#define CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256 (CKM_NSS + 24)
-#endif
-
 #define SET_ERROR_CODE   /* reminder */
 
 struct cipherPolicyStr {
@@ -38,8 +31,8 @@ struct cipherPolicyStr {
 typedef struct cipherPolicyStr cipherPolicy;
 
 /* This table contains two preconfigured policies: Export and France.
-** It is used only by the functions NSS_SetDomesticPolicy, 
-** NSS_SetExportPolicy, and NSS_SetFrancePolicy.
+** It is used only by the functions SSL_SetDomesticPolicy, 
+** SSL_SetExportPolicy, and SSL_SetFrancyPolicy.
 ** Order of entries is not important.
 */
 static cipherPolicy ssl_ciphers[] = {	   /*   Export           France   */
@@ -62,19 +55,14 @@ static cipherPolicy ssl_ciphers[] = {	   /*   Export           France   */
  {  SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA,      SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA,      SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_DHE_DSS_WITH_RC4_128_SHA,           SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  SSL_RSA_WITH_NULL_MD5,		    SSL_ALLOWED,     SSL_ALLOWED },
  {  SSL_RSA_WITH_NULL_SHA,		    SSL_ALLOWED,     SSL_ALLOWED },
- {  TLS_RSA_WITH_NULL_SHA256,		    SSL_ALLOWED,     SSL_ALLOWED },
+ {  SSL_RSA_WITH_NULL_MD5,		    SSL_ALLOWED,     SSL_ALLOWED },
  {  TLS_DHE_DSS_WITH_AES_128_CBC_SHA, 	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_DHE_RSA_WITH_AES_128_CBC_SHA,       SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_RSA_WITH_AES_128_CBC_SHA,     	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  TLS_RSA_WITH_AES_128_CBC_SHA256,        SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_DHE_DSS_WITH_AES_256_CBC_SHA, 	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_DHE_RSA_WITH_AES_256_CBC_SHA,       SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_RSA_WITH_AES_256_CBC_SHA,     	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  TLS_RSA_WITH_AES_256_CBC_SHA256,        SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA, 	    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
@@ -94,7 +82,6 @@ static cipherPolicy ssl_ciphers[] = {	   /*   Export           France   */
  {  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,       SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,   SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,   SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDH_RSA_WITH_NULL_SHA,             SSL_ALLOWED,     SSL_ALLOWED },
  {  TLS_ECDH_RSA_WITH_RC4_128_SHA,          SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
@@ -105,7 +92,6 @@ static cipherPolicy ssl_ciphers[] = {	   /*   Export           France   */
  {  TLS_ECDHE_RSA_WITH_RC4_128_SHA,         SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,     SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
- {  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,  SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
  {  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,     SSL_NOT_ALLOWED, SSL_NOT_ALLOWED },
 #endif /* NSS_ENABLE_ECC */
  {  0,					    SSL_NOT_ALLOWED, SSL_NOT_ALLOWED }
@@ -168,7 +154,7 @@ static sslOptions ssl_defaults = {
     PR_FALSE,   /* requireSafeNegotiation */
     PR_FALSE,   /* enableFalseStart   */
     PR_TRUE,    /* cbcRandomIV        */
-    PR_FALSE    /* enableOCSPStapling */
+    PR_FALSE,   /* enableOCSPStapling */
 };
 
 /*
@@ -341,8 +327,6 @@ ssl_DupSocket(sslSocket *os)
 		                  ssl3_GetKeyPairRef(os->stepDownKeyPair);
 	    ss->ephemeralECDHKeyPair = !os->ephemeralECDHKeyPair ? NULL :
 		                  ssl3_GetKeyPairRef(os->ephemeralECDHKeyPair);
-	    ss->certStatusArray = !os->certStatusArray ? NULL :
-				  SECITEM_DupArray(NULL, os->certStatusArray);
 /*
  * XXX the preceding CERT_ and SECKEY_ functions can fail and return NULL.
  * XXX We should detect this, and not just march on with NULL pointers.
@@ -460,10 +444,6 @@ ssl_DestroySocketContents(sslSocket *ss)
 	ssl3_FreeKeyPair(ss->ephemeralECDHKeyPair);
 	ss->ephemeralECDHKeyPair = NULL;
     }
-    if (ss->certStatusArray) {
-	SECITEM_FreeArray(ss->certStatusArray, PR_TRUE);
-	ss->certStatusArray = NULL;
-    }
     SECITEM_FreeItem(&ss->opt.nextProtoNego, PR_FALSE);
     PORT_Assert(!ss->xtnData.sniNameArr);
     if (ss->xtnData.sniNameArr) {
@@ -798,15 +778,15 @@ SSL_OptionSet(PRFileDesc *fd, PRInt32 which, PRBool on)
             if (PR_FALSE != on) {
                 if (PR_SUCCESS == SSL_BypassSetup() ) {
 #ifdef NO_PKCS11_BYPASS
-                    ss->opt.bypassPKCS11 = PR_FALSE;
+                    ss->opt.bypassPKCS11   = PR_FALSE;
 #else
-                    ss->opt.bypassPKCS11 = on;
+                    ss->opt.bypassPKCS11   = on;
 #endif
                 } else {
                     rv = SECFailure;
                 }
             } else {
-                ss->opt.bypassPKCS11 = PR_FALSE;
+                ss->opt.bypassPKCS11   = PR_FALSE;
             }
 	}
 	break;
@@ -855,8 +835,8 @@ SSL_OptionSet(PRFileDesc *fd, PRInt32 which, PRBool on)
 	break;
 
       case SSL_ENABLE_OCSP_STAPLING:
-       ss->opt.enableOCSPStapling = on;
-       break;
+	ss->opt.enableOCSPStapling = on;
+	break;
 
       default:
 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
@@ -987,8 +967,8 @@ SSL_OptionGetDefault(PRInt32 which, PRBool *pOn)
     case SSL_ENABLE_FALSE_START:  on = ssl_defaults.enableFalseStart;   break;
     case SSL_CBC_RANDOM_IV:       on = ssl_defaults.cbcRandomIV;        break;
     case SSL_ENABLE_OCSP_STAPLING:
-       on = ssl_defaults.enableOCSPStapling;
-       break;
+	on = ssl_defaults.enableOCSPStapling;
+	break;
 
     default:
 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
@@ -1153,8 +1133,8 @@ SSL_OptionSetDefault(PRInt32 which, PRBool on)
 	break;
 
       case SSL_ENABLE_OCSP_STAPLING:
-       ssl_defaults.enableOCSPStapling = on;
-       break;
+	ssl_defaults.enableOCSPStapling = on;
+	break;
 
       default:
 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
@@ -1740,13 +1720,6 @@ SSL_ReconfigFD(PRFileDesc *model, PRFileDesc *fd)
         ss->ephemeralECDHKeyPair =
             ssl3_GetKeyPairRef(sm->ephemeralECDHKeyPair);
     }
-    if (sm->certStatusArray) {
-	if (ss->certStatusArray) {
-	    SECITEM_FreeArray(ss->certStatusArray, PR_TRUE);
-	    ss->certStatusArray = NULL;
-	}
-	ss->certStatusArray = SECITEM_DupArray(NULL, sm->certStatusArray);
-    }
     /* copy trust anchor names */
     if (sm->ssl3.ca_list) {
         if (ss->ssl3.ca_list) {
@@ -1909,24 +1882,6 @@ SSL_VersionRangeGet(PRFileDesc *fd, SSLVersionRange *vrange)
     return SECSuccess;
 }
 
-static PRCallOnceType checkTLS12TokenOnce;
-static PRBool tls12TokenExists;
-
-static PRStatus  
-ssl_CheckTLS12Token(void)
-{
-    tls12TokenExists =
-	PK11_TokenExists(CKM_NSS_TLS_MASTER_KEY_DERIVE_DH_SHA256);
-    return PR_SUCCESS;
-}
-
-static PRBool
-ssl_TLS12TokenExists(void)
-{
-    (void) PR_CallOnce(&checkTLS12TokenOnce, ssl_CheckTLS12Token);
-    return tls12TokenExists;
-}
-
 SECStatus
 SSL_VersionRangeSet(PRFileDesc *fd, const SSLVersionRange *vrange)
 {
@@ -1947,20 +1902,6 @@ SSL_VersionRangeSet(PRFileDesc *fd, const SSLVersionRange *vrange)
     ssl_GetSSL3HandshakeLock(ss);
 
     ss->vrange = *vrange;
-    /* If we don't have a sufficiently up-to-date softoken then we cannot do
-     * TLS 1.2. */
-    if (ss->vrange.max >= SSL_LIBRARY_VERSION_TLS_1_2 &&
-        !ssl_TLS12TokenExists()) {
-	/* If the user requested a minimum version of 1.2, then we don't
-	 * silently downgrade. */
-	if (ss->vrange.min >= SSL_LIBRARY_VERSION_TLS_1_2) {
-	    ssl_ReleaseSSL3HandshakeLock(ss);
-	    ssl_Release1stHandshakeLock(ss);
-	    PORT_SetError(SSL_ERROR_INVALID_VERSION_RANGE);
-	    return SECFailure;
-	}
-	ss->vrange.max = SSL_LIBRARY_VERSION_TLS_1_1;
-    }
 
     ssl_ReleaseSSL3HandshakeLock(ss);
     ssl_Release1stHandshakeLock(ss);
@@ -1968,23 +1909,34 @@ SSL_VersionRangeSet(PRFileDesc *fd, const SSLVersionRange *vrange)
     return SECSuccess;
 }
 
-const SECItemArray *
-SSL_PeerStapledOCSPResponses(PRFileDesc *fd)
-{
+SECStatus
+SSL_GetStapledOCSPResponse(PRFileDesc *fd, unsigned char *out_data,
+			   unsigned int *len) {
     sslSocket *ss = ssl_FindSocket(fd);
 
     if (!ss) {
-       SSL_DBG(("%d: SSL[%d]: bad socket in SSL_PeerStapledOCSPResponses",
-                SSL_GETPID(), fd));
-       return NULL;
+	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_GetStapledOCSPResponse",
+		 SSL_GETPID(), fd));
+	return SECFailure;
     }
 
-    if (!ss->sec.ci.sid) {
-       PORT_SetError(SEC_ERROR_NOT_INITIALIZED);
-       return NULL;
+    ssl_Get1stHandshakeLock(ss);
+    ssl_GetSSL3HandshakeLock(ss);
+
+    if (ss->ssl3.hs.cert_status.data) {
+	unsigned int todo = ss->ssl3.hs.cert_status.len;
+	if (todo > *len)
+	    todo = *len;
+	*len = ss->ssl3.hs.cert_status.len;
+	PORT_Memcpy(out_data, ss->ssl3.hs.cert_status.data, todo);
+    } else {
+	*len = 0;
     }
-    
-    return &ss->sec.ci.sid->peerCertStatus;
+
+    ssl_ReleaseSSL3HandshakeLock(ss);
+    ssl_Release1stHandshakeLock(ss);
+
+    return SECSuccess;
 }
 
 SECStatus
@@ -2353,41 +2305,13 @@ ssl_GetSockName(PRFileDesc *fd, PRNetAddr *name)
 }
 
 SECStatus
-SSL_SetStapledOCSPResponses(PRFileDesc *fd, SECItemArray *responses,
-			    PRBool takeOwnership)
-{
-    sslSocket *ss;
-
-    ss = ssl_FindSocket(fd);
-    if (!ss) {
-	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_SetStapledOCSPResponses",
-		 SSL_GETPID(), fd));
-	return SECFailure;
-    }
-
-    if (ss->certStatusArray) {
-        SECITEM_FreeArray(ss->certStatusArray, PR_TRUE);
-        ss->certStatusArray = NULL;
-    }
-    if (responses) {
-	if (takeOwnership) {
-	    ss->certStatusArray = responses;
-	}
-	else {
-	    ss->certStatusArray = SECITEM_DupArray(NULL, responses);
-	}
-    }
-    return (ss->certStatusArray || !responses) ? SECSuccess : SECFailure;
-}
-
-SECStatus
 SSL_SetSockPeerID(PRFileDesc *fd, const char *peerID)
 {
     sslSocket *ss;
 
     ss = ssl_FindSocket(fd);
     if (!ss) {
-	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_SetSockPeerID",
+	SSL_DBG(("%d: SSL[%d]: bad socket in SSL_SetCacheIndex",
 		 SSL_GETPID(), fd));
 	return SECFailure;
     }
@@ -2943,7 +2867,7 @@ loser:
     return SECFailure;
 }
 
-#if defined(XP_UNIX) || defined(XP_WIN32) || defined(XP_BEOS)
+#if (defined(XP_UNIX) || defined(XP_WIN32) || defined(XP_BEOS)) && !defined(_WIN32_WCE)
 #define NSS_HAVE_GETENV 1
 #endif
 
@@ -2983,7 +2907,7 @@ ssl_SetDefaultsFromEnvironment(void)
 	if (ev && ev[0]) {
 	    ssl_keylog_iob = fopen(ev, "a");
 	    if (!ssl_keylog_iob) {
-		SSL_TRACE(("SSL: failed to open key log file"));
+		SSL_TRACE(("Failed to open key log file"));
 	    } else {
 		if (ftell(ssl_keylog_iob) == 0) {
 		    fputs("# SSL/TLS secrets log file, generated by NSS\n",
@@ -3081,7 +3005,6 @@ ssl_NewSocket(PRBool makeLocks, SSLProtocolVariant protocolVariant)
 	ss->requestedCertTypes = NULL;
 	ss->stepDownKeyPair    = NULL;
 	ss->dbHandle           = CERT_GetDefaultCertDB();
-	ss->certStatusArray    = NULL;
 
 	/* Provide default implementation of hooks */
 	ss->authCertificate    = SSL_AuthCertificate;
@@ -3096,7 +3019,6 @@ ssl_NewSocket(PRBool makeLocks, SSLProtocolVariant protocolVariant)
 	ss->handleBadCert      = NULL;
 	ss->badCertArg         = NULL;
 	ss->pkcs11PinArg       = NULL;
-	ss->ephemeralECDHKeyPair = NULL;
 	ss->getChannelID       = NULL;
 	ss->getChannelIDArg    = NULL;
 
diff --git a/src/net/third_party/nss/ssl/sslt.h b/src/net/third_party/nss/ssl/sslt.h
index 109640c..6af09bb 100644
--- a/src/net/third_party/nss/ssl/sslt.h
+++ b/src/net/third_party/nss/ssl/sslt.h
@@ -4,26 +4,13 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: sslt.h,v 1.23 2012/06/07 02:06:19 wtc%google.com Exp $ */
 
 #ifndef __sslt_h_
 #define __sslt_h_
 
 #include "prtypes.h"
 
-/* SECItemArray is added in NSS 3.15.  Define the type if compiling
-** against an older version of NSS.
-*/
-#include "nssutil.h"
-#if NSSUTIL_VMAJOR == 3 && NSSUTIL_VMINOR < 15
-typedef struct SECItemArrayStr SECItemArray;
-
-struct SECItemArrayStr {
-    SECItem *items;
-    unsigned int len;
-};
-#endif  /* NSSUTIL_VMAJOR == 3 && NSSUTIL_VMINOR < 15 */
-
 typedef struct SSL3StatisticsStr {
     /* statistics from ssl3_SendClientHello (sch) */
     long sch_sid_cache_hits;
@@ -102,8 +89,7 @@ typedef enum {
     ssl_mac_md5       = 1, 
     ssl_mac_sha       = 2, 
     ssl_hmac_md5      = 3, 	/* TLS HMAC version of mac_md5 */
-    ssl_hmac_sha      = 4, 	/* TLS HMAC version of mac_sha */
-    ssl_hmac_sha256   = 5
+    ssl_hmac_sha      = 4 	/* TLS HMAC version of mac_sha */
 } SSLMACAlgorithm;
 
 typedef enum {
@@ -194,7 +180,6 @@ typedef enum {
     ssl_elliptic_curves_xtn          = 10,
     ssl_ec_point_formats_xtn         = 11,
 #endif
-    ssl_signature_algorithms_xtn     = 13,
     ssl_use_srtp_xtn                 = 14,
     ssl_session_ticket_xtn           = 35,
     ssl_next_proto_nego_xtn          = 13172,
@@ -202,6 +187,6 @@ typedef enum {
     ssl_renegotiation_info_xtn       = 0xff01	/* experimental number */
 } SSLExtensionType;
 
-#define SSL_MAX_EXTENSIONS             10
+#define SSL_MAX_EXTENSIONS             9
 
 #endif /* __sslt_h_ */
diff --git a/src/net/third_party/nss/ssl/ssltrace.c b/src/net/third_party/nss/ssl/ssltrace.c
index c1c6cdd..3ebd715 100644
--- a/src/net/third_party/nss/ssl/ssltrace.c
+++ b/src/net/third_party/nss/ssl/ssltrace.c
@@ -4,7 +4,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: ssltrace.c,v 1.5 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 #include <stdarg.h>
 #include "cert.h"
 #include "ssl.h"
diff --git a/src/net/third_party/nss/ssl/unix_err.c b/src/net/third_party/nss/ssl/unix_err.c
index 21c9663..eb3d000 100644
--- a/src/net/third_party/nss/ssl/unix_err.c
+++ b/src/net/third_party/nss/ssl/unix_err.c
@@ -10,7 +10,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: unix_err.c,v 1.9 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #if 0
 #include "primpl.h"
diff --git a/src/net/third_party/nss/ssl/unix_err.h b/src/net/third_party/nss/ssl/unix_err.h
index bf4f77e..b177987 100644
--- a/src/net/third_party/nss/ssl/unix_err.h
+++ b/src/net/third_party/nss/ssl/unix_err.h
@@ -9,7 +9,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: unix_err.h,v 1.4 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 /*  NSPR doesn't make these functions public, so we have to duplicate
 **  them in NSS.
diff --git a/src/net/third_party/nss/ssl/win32err.c b/src/net/third_party/nss/ssl/win32err.c
index 9d38e38..765dc5b 100644
--- a/src/net/third_party/nss/ssl/win32err.c
+++ b/src/net/third_party/nss/ssl/win32err.c
@@ -10,7 +10,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: win32err.c,v 1.6 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 #include "prerror.h"
 #include "prlog.h"
diff --git a/src/net/third_party/nss/ssl/win32err.h b/src/net/third_party/nss/ssl/win32err.h
index a72548d..2501a98 100644
--- a/src/net/third_party/nss/ssl/win32err.h
+++ b/src/net/third_party/nss/ssl/win32err.h
@@ -9,7 +9,7 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-/* $Id$ */
+/* $Id: win32err.h,v 1.4 2012/04/25 14:50:12 gerv%gerv.net Exp $ */
 
 /*  NSPR doesn't make these functions public, so we have to duplicate
 **  them in NSS.
-- 
1.7.9.5

